// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Client
    {
    public partial class Main : TorqueScriptTemplate
        {
        /*

        ================================================================================
         The DOFPostEffect API
        ================================================================================

        DOFPostEffect::setFocalDist( %dist )

        @summary
        This method is for manually controlling the focus distance. It will have no 
        effect if auto focus is currently enabled. Makes use of the parameters set by 
        setFocusParams.

        @param dist 
        float distance in meters

        --------------------------------------------------------------------------------

        DOFPostEffect::setAutoFocus( %enabled )

        @summary
        This method sets auto focus enabled or disabled. Makes use of the parameters set 
        by setFocusParams. When auto focus is enabled it determines the focal depth
        by performing a raycast at the screen-center.

        @param enabled
        bool

        --------------------------------------------------------------------------------

        DOFPostEffect::setFocusParams( %nearBlurMax, %farBlurMax, %minRange, %maxRange, %nearSlope, %farSlope )

        Set the parameters that control how the near and far equations are calculated
        from the focal distance. If you are not using auto focus you will need to call
        setFocusParams PRIOR to calling setFocalDist.

        @param nearBlurMax   
        float between 0.0 and 1.0
        The max allowed value of near blur.

        @param farBlurMax    
        float between 0.0 and 1.0
        The max allowed value of far blur.

        @param minRange/maxRange 
        float in meters
        The distance range around the focal distance that remains in focus is a lerp 
        between the min/maxRange using the normalized focal distance as the parameter. 
        The point is to allow the focal range to expand as you focus farther away since this is 
        visually appealing.

        Note: since min/maxRange are lerped by the "normalized" focal distance it is
        dependant on the visible distance set in your level.

        @param nearSlope
        float less than zero
        The slope of the near equation. A small number causes bluriness to increase gradually
        at distances closer than the focal distance. A large number causes bluriness to 
        increase quickly.

        @param farSlope
        float greater than zero
        The slope of the far equation. A small number causes bluriness to increase gradually
        at distances farther than the focal distance. A large number causes bluriness to
        increase quickly.

        Note: To rephrase, the min/maxRange parameters control how much area around the
        focal distance is completely in focus where the near/farSlope parameters control
        how quickly or slowly bluriness increases at distances outside of that range.

        ================================================================================
         Examples
        ================================================================================

        Example1: Turn on DOF while zoomed in with a weapon.

        NOTE: These are not real callbacks! Hook these up to your code where appropriate!

        function onSniperZoom()
        {
           // Parameterize how you want DOF to look.
           DOFPostEffect.setFocusParams( 0.3, 0.3, 50, 500, -5, 5 );
   
           // Turn on auto focus
           DOFPostEffect.setAutoFocus( true );
   
           // Turn on the PostEffect
           DOFPostEffect.enable();
        }

        function onSniperUnzoom()
        {
           // Turn off the PostEffect
           DOFPostEffect.disable();
        }

        Example2: Manually control DOF with the mouse wheel.

        // Somewhere on startup...

        // Parameterize how you want DOF to look.
        DOFPostEffect.setFocusParams( 0.3, 0.3, 50, 500, -5, 5 );

        // Turn off auto focus
        DOFPostEffect.setAutoFocus( false );

        // Turn on the PostEffect
        DOFPostEffect.enable();


        NOTE: These are not real callbacks! Hook these up to your code where appropriate!

        function onMouseWheelUp()
        {
           // Since setFocalDist is really just a wrapper to assign to the focalDist
           // dynamic field we can shortcut and increment it directly.
           DOFPostEffect.focalDist += 8;
        }

        function onMouseWheelDown()
        {
           DOFPostEffect.focalDist -= 8;
        }
        */

        /// This method is for manually controlling the focal distance. It will have no 
        /// effect if auto focus is currently enabled. Makes use of the parameters set by 
        /// setFocusParams.
        [Torque_Decorations.TorqueCallBack("", "DOFPostEffect", "setFocalDist", "%this, %dist", 2, 92000, false)]
        public void DOFPostEffectsetFocalDist(coPostEffect thisobj, string dist)
            {
            thisobj["focalDist"] = dist;
            }

        // This method sets auto focus enabled or disabled. Makes use of the parameters set 
        // by setFocusParams. When auto focus is enabled it determine the focal depth
        // by performing a raycast at the screen-center.

        [Torque_Decorations.TorqueCallBack("", "DOFPostEffect", "setAutoFocus", "%this, %enabled", 2, 92100, false)]
        public void DOFPostEffectsetAutoFocus(coPostEffect thisobj, bool enabled)
            {
            thisobj["autoFocusEnabled"] = enabled.AsString();
            }

        // Set the parameters that control how the near and far equations are calculated
        // from the focal distance. If you are not using auto focus you will need to call
        // setFocusParams PRIOR to calling setFocalDist.


        [Torque_Decorations.TorqueCallBack("", "DOFPostEffect", "setFocusParams", "%this, %nearBlurMax, %farBlurMax, %minRange, %maxRange, %nearSlope, %farSlope", 7, 92200, false)]
        public void DOFPostEffectsetFocusParams(coPostEffect thisobj, float nearBlurMax, float farBlurMax, float minRange, float maxRange, float nearSlope, float farSlope)
            {
            thisobj["nearBlurMax"] = nearBlurMax.AsString();
            thisobj["farBlurMax"] = farBlurMax.AsString();
            thisobj["minRange"] = minRange.AsString();
            thisobj["maxRange"] = maxRange.AsString();
            thisobj["nearSlope"] = nearSlope.AsString();
            thisobj["farSlope"] = farSlope.AsString();
            }

        /*

        More information...

        This DOF technique is based on this paper:
        http://http.developer.nvidia.com/GPUGems3/gpugems3_ch28.html

        ================================================================================
        1. Overview of how we represent "Depth of Field"
        ================================================================================

        DOF is expressed as an amount of bluriness per pixel according to its depth.
        We represented this by a piecewise linear curve depicted below.

        Note: we also refer to "bluriness" as CoC ( circle of confusion ) which is the term
        used in the basis paper and in photography.
   

        X-axis (depth) 
        x = 0.0----------------------------------------------x = 1.0       

        Y-axis (bluriness)
        y = 1.0   
          |
          |   ____(x1,y1)                         (x4,y4)____
          |       (ns,nb)\  <--Line1  line2--->  /(fe,fb)
          |               \                     /
          |                \(x2,y2)     (x3,y3)/
          |                 (ne,0)------(fs,0)  
        y = 0.0
                 

        I have labeled the "corners" of this graph with (Xn,Yn) to illustrate that
        this is in fact a collection of line segments where the x/y of each point
        corresponds to the key below.

        key:
        ns - (n)ear blur (s)tart distance
        nb - (n)ear (b)lur amount (max value)
        ne - (n)ear blur (e)nd distance
        fs - (f)ar blur (s)tart distance
        fe - (f)ar blur (e)nd distance
        fb - (f)ar (b)lur amount (max value)

        Of greatest importance in this graph is Line1 and Line2. Where...
        L1 { (x1,y1), (x2,y2) }
        L2 { (x3,y3), (x4,y4) }

        Line one represents the amount of "near" blur given a pixels depth and line two
        represents the amount of "far" blur at that depth.

        Both these equations are evaluated for each pixel and then the larger of the two
        is kept. Also the output blur (for each equation) is clamped between 0 and its
        maximum allowable value.

        Therefore, to specify a DOF "qualify" you need to specify the near-blur-line, 
        far-blur-line, and maximum near and far blur value.

        ================================================================================
        2. Abstracting a "focal depth"
        ================================================================================

        Although the shader(s) work in terms of a near and far equation it is more
        useful to express DOF as an adjustable focal depth and derive the other parameters
        "under the hood".

        Given a maximum near/far blur amount and a near/far slope we can calculate the
        near/far equations for any focal depth. We extend this to also support a range
        of depth around the focal depth that is also in focus and for that range to
        shrink or grow as the focal depth moves closer or farther.

        Keep in mind this is only one implementation and depending on the effect you
        desire you may which to express the relationship between focal depth and 
        the shader paramaters different. 

        */

        //-----------------------------------------------------------------------------
        // GFXStateBlockData / ShaderData
        //-----------------------------------------------------------------------------

        [Torque_Decorations.TorqueCallBack("", "", "dof_init", "", 0, 92300, true)]
        public void dof_init()
            {
            TorqueSingleton ts = new TorqueSingleton("GFXStateBlockData", "PFX_DefaultDOFStateBlock");
            ts.Props.Add("zDefined", "true");
            ts.Props.Add("zEnable", "false");
            ts.Props.Add("zWriteEnable", "false");

            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampPoint");
            ts.Props.Add("samplerStates[1]", "SamplerClampPoint");
            ts.Create();

            ts = new TorqueSingleton("GFXStateBlockData", "PFX_DOFCalcCoCStateBlock");
            ts.Props.Add("zDefined", "true");
            ts.Props.Add("zEnable", "false");
            ts.Props.Add("zWriteEnable", "false");

            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[1]", "SamplerClampLinear");
            ts.Create();

            ts = new TorqueSingleton("GFXStateBlockData", "PFX_DOFDownSampleStateBlock");
            ts.Props.Add("zDefined", "true");
            ts.Props.Add("zEnable", "false");
            ts.Props.Add("zWriteEnable", "false");

            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[1]", "SamplerClampPoint");
            ts.Create();


            ts = new TorqueSingleton("GFXStateBlockData", "PFX_DOFBlurStateBlock");
            ts.Props.Add("zDefined", "true");
            ts.Props.Add("zEnable", "false");
            ts.Props.Add("zWriteEnable", "false");

            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampLinear");
            ts.Create();

            ts = new TorqueSingleton("GFXStateBlockData", "PFX_DOFFinalStateBlock");
            ts.Props.Add("zDefined", "true");
            ts.Props.Add("zEnable", "false");
            ts.Props.Add("zWriteEnable", "false");

            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[1]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[2]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[3]", "SamplerClampPoint");

            ts.Props.Add("blendDefined", "true");
            ts.Props.Add("blendEnable", "true");
            ts.Props.Add("blendDest", "GFXBlendInvSrcAlpha");
            ts.Props.Add("blendSrc", "GFXBlendOne");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "PFX_DOFDownSampleShader");

            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/dof/DOF_DownSample_V.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/dof/DOF_DownSample_P.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "PFX_DOFBlurYShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/dof/DOF_Gausian_V.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/dof/DOF_Gausian_P.hlsl");
            ts.Props.Add("pixVersion", "2.0");
            ts.PropsAddString("defines", "BLUR_DIR=float2(0.0,1.0)");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "PFX_DOFBlurXShader : PFX_DOFBlurYShader");
            ts.PropsAddString("defines", "BLUR_DIR=float2(1.0,0.0)");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "PFX_DOFCalcCoCShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/dof/DOF_CalcCoC_V.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/dof/DOF_CalcCoC_P.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "PFX_DOFSmallBlurShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/dof/DOF_SmallBlur_V.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/dof/DOF_SmallBlur_P.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "PFX_DOFFinalShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/dof/DOF_Final_V.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/dof/DOF_Final_P.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();
            }

        //-----------------------------------------------------------------------------
        // PostEffects
        //-----------------------------------------------------------------------------


        [Torque_Decorations.TorqueCallBack("", "DOFPostEffect", "onAdd", "%this", 1, 92400, false)]
        public void DOFPostEffectonAdd(coPostEffect thisobj)
            {
            // The weighted distribution of CoC value to the three blur textures
            // in the order small, medium, large. Most likely you will not need to
            // change this value.
            DOFPostEffectsetLerpDist(thisobj, "0.2", "0.3", "0.5");

            thisobj["autoFocusEnabled"] = false.AsString();
            thisobj["focalDist"] = "0";
            thisobj["nearBlurMax"] = ".5";
            thisobj["farBlurMax"] = ".5";
            thisobj["minRange"] = "50";
            thisobj["maxRange"] = "500";
            thisobj["nearSlope"] = "-5";
            thisobj["farSlope"] = "5";
            }

        [Torque_Decorations.TorqueCallBack("", "DOFPostEffect", "setLerpDist", "%this, %d0, %d1, %d2", 4, 92500, false)]
        public void DOFPostEffectsetLerpDist(coPostEffect thisobj, string d0, string d1, string d2)
            {
            thisobj["lerpScale"] = (-1.0/d0.AsFloat()).AsString() + " " + (-1.0/d1.AsFloat()).AsString() + " " + (-1.0/d2.AsFloat()).AsString() + " " + (1.0/d2.AsFloat()).AsString();


            string lerpbias = "1.0 ";
            lerpbias += ((1 - d2.AsFloat())/d1.AsFloat()).AsString() + " ";
            lerpbias += (1.0/d2.AsFloat()).AsString() + " ";
            lerpbias += ((d2.AsFloat() - 1.0)/d2.AsFloat()).AsString();

            thisobj["lerpBias"] = lerpbias;
            }

        [Torque_Decorations.TorqueCallBack("", "", "dof_init1", "", 0, 92600, true)]
        public void dof_init1()
            {
            TorqueSingleton ts = new TorqueSingleton("PostEffect", "DOFPostEffect");
            ts.PropsAddString("renderTime", "PFXAfterBin");
            ts.PropsAddString("renderBin", "GlowBin");
            ts.Props.Add("renderPriority", "0.1");

            ts.Props.Add("shader", "PFX_DOFDownSampleShader");
            ts.Props.Add("stateBlock", "PFX_DOFDownSampleStateBlock");
            ts.PropsAddString("texture[0]", "$backBuffer");
            ts.PropsAddString("texture[1]", "#prepass");
            ts.PropsAddString("target", "#shrunk");
            ts.PropsAddString("targetScale", "0.25 0.25");

            ts.Props.Add("isEnabled", "false");
            coPostEffect DOFPostEffect = ts.Create();

            ts = new TorqueSingleton("PostEffect", "DOFBlurY");
            ts.Props.Add("shader", "PFX_DOFBlurYShader");
            ts.Props.Add("stateBlock", "PFX_DOFBlurStateBlock");
            ts.PropsAddString("texture[0]", "#shrunk");
            ts.PropsAddString("target", "$outTex");
            coPostEffect DOFBlurY = ts.Create();

            DOFPostEffect.add(DOFBlurY);


            ts = new TorqueSingleton("PostEffect", "DOFBlurX");
            ts.Props.Add("shader", "PFX_DOFBlurXShader");
            ts.Props.Add("stateBlock", "PFX_DOFBlurStateBlock");
            ts.PropsAddString("texture[0]", "$inTex");
            ts.PropsAddString("target", "#largeBlur");
            coPostEffect DOFBlurX = ts.Create();
            DOFPostEffect.add(DOFBlurX);

            ts = new TorqueSingleton("PostEffect", "DOFCalcCoC");
            ts.Props.Add("shader", "PFX_DOFCalcCoCShader");
            ts.Props.Add("stateBlock", "PFX_DOFCalcCoCStateBlock");
            ts.PropsAddString("texture[0]", "#shrunk");
            ts.PropsAddString("texture[1]", "#largeBlur");
            ts.PropsAddString("target", "$outTex");
            coPostEffect DOFCalcCoC = ts.Create();
            DOFPostEffect.add(DOFCalcCoC);


            ts = new TorqueSingleton("PostEffect", "DOFSmallBlur");
            ts.Props.Add("shader", "PFX_DOFSmallBlurShader");
            ts.Props.Add("stateBlock", "PFX_DefaultDOFStateBlock");
            ts.PropsAddString("texture[0]", "$inTex");
            ts.PropsAddString("target", "$outTex");
            coPostEffect DOFSmallBlur = ts.Create();
            DOFPostEffect.add(DOFSmallBlur);


            ts = new TorqueSingleton("PostEffect", "DOFFinalPFX");
            ts.Props.Add("shader", "PFX_DOFFinalShader");
            ts.Props.Add("stateBlock", "PFX_DOFFinalStateBlock");
            ts.PropsAddString("texture[0]", "$backBuffer");
            ts.PropsAddString("texture[1]", "$inTex");
            ts.PropsAddString("texture[2]", "#largeBlur");
            ts.PropsAddString("texture[3]", "#prepass");
            ts.PropsAddString("target", "$backBuffer");
            coPostEffect DOFFinalPFX = ts.Create();
            DOFPostEffect.add(DOFFinalPFX);
            }

        //-----------------------------------------------------------------------------
        // Scripts
        //-----------------------------------------------------------------------------

        [Torque_Decorations.TorqueCallBack("", "DOFPostEffect", "setShaderConsts", "this", 1, 92700, false)]
        public void DOFPostEffectsetShaderConsts(coPostEffect posteffect)
            {
            if (posteffect["autoFocusEnabled"].AsBool())
                DOFPostEffectautoFocus(posteffect);


            double fd = posteffect["focalDist"].AsFloat()/fGlobal["$Param::FarDist"];
            double range = Util.mLerp(posteffect["minRange"].AsFloat(), posteffect["maxRange"].AsFloat(), (float) fd)/fGlobal["$Param::FarDist"]*.5;
            // We work in "depth" space rather than real-world units for the
            // rest of this method...

            // Given the focal distance and the range around it we want in focus
            // we can determine the near-end-distance and far-start-distance

            double ned = Util.getMax((float) fd - (float) range, (float) 0.0);
            double fsd = Util.getMin((float) fd + (float) range, (float) 1.0);
            // near slope
            float nsl = posteffect["nearSlope"].AsFloat();
            // Given slope of near blur equation and the near end dist and amount (x2,y2)
            // solve for the y-intercept
            // y = mx + b
            // so...
            // y - mx = b

            float b = (float) 0.0 - nsl*(float) ned;
            string eqNear = nsl.AsString() + " " + b.AsString() + " 0.0";

            // Do the same for the far blur equation...

            float fsl = posteffect["farSlope"].AsFloat();
            b = (float) 0.0 - fsl*(float) fsd;

            string eqFar = fsl.AsString() + " " + b.AsString() + " " + "1.0";

            coPostEffect DOFFinalPFX = "DOFFinalPFX";

            posteffect.setShaderConst("$dofEqWorld", eqNear);
            DOFFinalPFX.setShaderConst("$dofEqFar", eqFar);
            posteffect.setShaderConst("$maxWorldCoC", posteffect["nearBlurMax"]);
            DOFFinalPFX.setShaderConst("$maxFarCoC", posteffect["farBlurMax"]);
            DOFFinalPFX.setShaderConst("$dofLerpScale", posteffect["lerpScale"]);
            DOFFinalPFX.setShaderConst("$dofLerpBias", posteffect["lerpBias"]);
            }

        [Torque_Decorations.TorqueCallBack("", "DOFPostEffect", "autoFocus", "this", 1, 92800, false)]
        public void DOFPostEffectautoFocus(coPostEffect thisobj)
            {
            try
                {
                coGameConnection serverconnection = "ServerConnection";
                coCamera camera = serverconnection.getCameraObject();

                uint mask = (uint) (WinterLeaf.Enums.SceneObjectTypesAsUint.StaticObjectType | WinterLeaf.Enums.SceneObjectTypesAsUint.TerrainObjectType);


                //string control = GameConnection.getCameraObject("ServerConnection"); //console.Call("ServerConnection", "getCameraObject");

                Point3F fvec = camera.getEyeVector();
                Point3F start = camera.getEyePoint();

                //Point3F fvec = ShapeBase.getEyeVector(control); // console.Call(control, "getEyeVector");
                //Point3F start = ShapeBase.getEyePoint(control); // console.Call(control, "getEyePoint");

                Point3F end = Util.VectorAdd(start, Util.VectorScale(fvec, fGlobal["$Param::FarDist"]));

                string result = Util.containerRayCast(start, end, mask, camera, true);

                string hitPos = Util.getWords(result, 1, 3);
                string focDist = sGlobal["$Param::FarDist"];
                if (hitPos != "")
                    focDist = Util.VectorDist(new Point3F(hitPos), start).AsString();

                thisobj["focalDist"] = focDist;
                }
            catch (Exception)
                {
                //Do nothing, this only gets hit when it can't find the serverconnection or the camera.
                }
            }
        }
    }
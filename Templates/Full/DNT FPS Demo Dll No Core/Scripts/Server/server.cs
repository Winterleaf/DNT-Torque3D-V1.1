// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using WinterLeaf;
using WinterLeaf.Classes;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Server
    {
    public partial class Main : TorqueScriptTemplate
        {
        private bool mDisplayOnMaster;

        [Torque_Decorations.TorqueCallBack("", "", "initBaseServer", "()", 0, -10000, false)]
        public void InitBaseServer()
            {
            dnt.DoScriptInjection(ScriptType.Server, 10000, 20000);
            }

        [Torque_Decorations.TorqueCallBack("", "", "portInit", "(%port)", 1, -10000, false)]
        public void PortInit(int port)
            {
            // Attempt to find an open port to initialize the server with
            int failedCount = 0;
            while (failedCount < 10 && !Util._setNetPort(port.AsString()))
                {
                console.error("Port init failed on port " + port + " trying next port.");
                port = (port + 1);
                failedCount++;
                }
            }

        [Torque_Decorations.TorqueCallBack("", "", "createAndConnectToLocalServer", "(%serverType, %level", 2, -10000, false)]
        public bool CreateAndConnectToLocalServer(string serverType, string level)
            {
            if (!CreateServer(serverType, level))

                return false;


            coGameConnection client = new Torque_Class_Helper("GameConnection", "ServerConnection").Create();


            client.setConnectArgs(sGlobal["$pref::Player::Name"]);

            client.setJoinPassword(sGlobal["$Client::Password"]);

            string result = client.connectLocal();

            if (result != "")
                {
                client.delete();
                DestroyServer();
                return false;
                }
            return true;
            }

        /// Create a server with either a "SinglePlayer" or "MultiPlayer" type
        /// Specify the level to load on the server
        [Torque_Decorations.TorqueCallBack("", "", "createServer", "(%serverType, %level)", 2, -10000, false)]
        public bool CreateServer(string serverType, string level)
            {
            // Increase the server session number.  This is used to make sure we're
            // working with the server session we think we are.

            iGlobal["$Server::Session"] = iGlobal["$Server::Session"] + 1;

            if (level == "")
                {
                console.error("createServer(): level name unspecified");
                return false;
                }
            // Make sure our level name is relative so that it can send
            // across the network correctly
            level = Util.makeRelativePath(level, Util.getWorkingDirectory());
            DestroyServer();

            iGlobal["$missionSequence"] = 0;


            Server__PlayerCount = 0;

            sGlobal["$Server::ServerType"] = serverType;


            Server__LoadFailMsg = "";

            bGlobal["$Physics::isSinglePlayer"] = true;

            // Setup for multi-player, the network must have been
            // initialized before now.

            if (serverType == "MultiPlayer")
                {
                bGlobal["$Physics::isSinglePlayer"] = false;
                console.print("Starting multiplayer mode");
                // Make sure the network port is set to the correct pref.
                PortInit(iGlobal["$Pref::Server::Port"]);


                console.Call("allowConnections", new[] {"true"});

                if (mDisplayOnMaster)
                    Util._schedule("0", "0", "startHeartbeat");
                }

            // Create the ServerGroup that will persist for the lifetime of the server.
            new Torque_Class_Helper("SimGroup", "ServerGroup").Create();

            Util.exec(@"core/art/datablocks/datablockExec.cs", false, false);
            // Let the game initialize some things now that the
            // the server has been created


            onServerCreated();


            LoadMission(level, true);
            return true;
            }

        [Torque_Decorations.TorqueCallBack("", "", "destroyServer", "", 0, -10000, false)]
        public void DestroyServer()
            {
            sGlobal["$Server::ServerType"] = "";

            console.Call("allowConnections", new[] {"false"});

            console.Call("stopHeartBeat");

            bGlobal["$missionRunning"] = false;

            missionRunning = false;

            // End any running levels
            EndMission();


            onServerDestroyed();

            // Delete all the server objects
            if ("ServerGroup".isObject())
                "ServerGroup".delete();

            // Delete all the connections:
            foreach (coGameConnection client in ClientGroup)
                client.delete();

            sGlobal["$Server::GuidList"] = "";


            // Delete all the data blocks...
            Util.deleteDataBlocks();
            // Save any server settings
            console.print("Exporting server prefs...");
            Util.export(" $Pref::Server::*", @"core/prefs.cs", false);
            // Increase the server session number.  This is used to make sure we're
            // working with the server session we think we are.

            iGlobal["$Server::Session"] = iGlobal["$Server::Session"] + 1;
            }

        [Torque_Decorations.TorqueCallBack("", "", "resetServerDefaults", "", 0, -10000, false)]
        public void ResetServerDefaults()
            {
            console.print("Resetting server defaults...");
            Util.exec(@"core/default.cs", false, false);
            Util.exec(@"core/prefs.cs", false, false);
            // Reload the current level

            LoadMission(sGlobal["$Server::MissionFile"], false);
            }

        [Torque_Decorations.TorqueCallBack("", "", "addToServerGuidList", "(%guid)", 1, -10000, false)]
        public void AddToServerGuidList(string guid)
            {
            int count = Util.getFieldCount(sGlobal["$Server::GuidList"]);
            for (int i = 0; i < count; i++)
                {
                if (Util.getField(console.GetVarString("$Server::GuidList"), i) == guid)
                    return;
                }
            sGlobal["$Server::GuidList"] = sGlobal["$Server::GuidList"] == "" ? guid : sGlobal["$Server::GuidList"];
            }

        [Torque_Decorations.TorqueCallBack("", "", "removeFromServerGuidList", "(%guid)", 1, -10000, false)]
        public void RemoveFromServerGuidList(string guid)
            {
            int count = Util.getFieldCount(sGlobal["$Server::GuidList"]);
            for (int i = 0; i < count; i++)
                {
                if (Util.getField(sGlobal["$Server::GuidList"], i) != guid)
                    continue;
                sGlobal["$Server::GuidList"] = Util.removeField(sGlobal["$Server::GuidList"], i);
                return;
                }
            }

        /// When the server is queried for information, the value of this function is
        /// returned as the status field of the query packet.  This information is
        /// accessible as the ServerInfo::State variable.
        [Torque_Decorations.TorqueCallBack("", "", "onServerInfoQuery", "()", 0, -10000, false)]
        public string OnServerInfoQuery()
            {
            return "Doing Ok";
            }
        }
    }
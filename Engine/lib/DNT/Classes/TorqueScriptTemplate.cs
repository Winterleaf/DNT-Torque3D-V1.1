// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using WinterLeaf.Containers;
using WinterLeaf.Enums;

#endregion

namespace WinterLeaf.Classes
    {
    /// <summary>
    /// This class is a function organizer for the externs.  All calls to Torque from C# go through this helper class.
    /// </summary>
    public class TorqueScriptTemplate
        {
        /// <summary>
        /// A reference to the dnTorque Object, this must be set at construction time.
        /// </summary>
        public static dnTorque m_ts;

        private readonly AIClientObject _mAIClient;
        private readonly AIConnectionObject _mAIConnection;
        private readonly AIPlayerObject _mAIPlayer;
        private readonly AITurretShapeObject _mAITurretShape;
        private readonly ActionMapObject _mActionMap;
        private readonly ArrayObjectObject _mArrayObject;
        private readonly CameraObject _mCamera;
        private readonly CompoundUndoActionObject _mCompoundUndoAction;
        private readonly ConsoleLoggerObject _mConsoleLogger;

        /// <summary>
        /// A property exposing Custom dnTorque Console Functions.
        /// </summary>
        private readonly ConsoleObject _mConsoleobject;

        private readonly CubemapDataObject _mCubemapData;
        private readonly DbgFileViewObject _mDbgFileView;
        private readonly DebrisObject _mDebris;
        private readonly DebugDrawerObject _mDebugDrawer;
        private readonly DecalDataObject _mDecalData;
        private readonly DecalRoadObject _mDecalRoad;
        private readonly DynamicConsoleMethodComponentObject _mDynamicConsoleMethodComponent;
        private readonly EditTSCtrlObject _mEditTSCtrl;
        private readonly EventManagerObject _mEventManager;
        private readonly FieldBrushObjectObject _mFieldBrushObject;
        private readonly FileDialogObject _mFileDialog;
        private readonly FileObjectObject _mFileObject;
        private readonly FileStreamObjectObject _mFileStreamObject;
        private readonly FlyingVehicleObject _mFlyingVehicle;
        private readonly ForestObject _mForest;
        private readonly ForestBrushObject _mForestBrush;
        private readonly ForestBrushToolObject _mForestBrushTool;
        private readonly ForestEditorCtrlObject _mForestEditorCtrl;
        private readonly ForestSelectionToolObject _mForestSelectionTool;
        private readonly ForestWindEmitterObject _mForestWindEmitter;
        private readonly GameBaseObject _mGameBase;
        private readonly GameConnectionObject _mGameConnection;
        private readonly GroundPlaneObject _mGroundPlane;
        private readonly GuiAutoScrollCtrlObject _mGuiAutoScrollCtrl;
        private readonly GuiBitmapButtonCtrlObject _mGuiBitmapButtonCtrl;
        private readonly GuiBitmapCtrlObject _mGuiBitmapCtrl;
        private readonly GuiButtonBaseCtrlObject _mGuiButtonBaseCtrl;
        private readonly GuiCanvasObject _mGuiCanvas;
        private readonly GuiCheckBoxCtrlObject _mGuiCheckBoxCtrl;
        private readonly GuiColorPickerCtrlObject _mGuiColorPickerCtrl;
        private readonly GuiControlObject _mGuiControl;
        private readonly GuiControlProfileObject _mGuiControlProfile;
        private readonly GuiDirectoryFileListCtrlObject _mGuiDirectoryFileListCtrl;
        private readonly GuiDragAndDropControlObject _mGuiDragAndDropControl;
        private readonly GuiDynamicCtrlArrayControlObject _mGuiDynamicCtrlArrayControl;
        private readonly GuiEditCtrlObject _mGuiEditCtrl;
        private readonly GuiFileTreeCtrlObject _mGuiFileTreeCtrl;
        private readonly GuiFilterCtrlObject _mGuiFilterCtrl;
        private readonly GuiFormCtrlObject _mGuiFormCtrl;
        private readonly GuiFrameSetCtrlObject _mGuiFrameSetCtrl;
        private readonly GuiGameListMenuCtrlObject _mGuiGameListMenuCtrl;
        private readonly GuiGameListOptionsCtrlObject _mGuiGameListOptionsCtrl;
        private readonly GuiGradientCtrlObject _mGuiGradientCtrl;
        private readonly GuiGraphCtrlObject _mGuiGraphCtrl;
        private readonly GuiIconButtonCtrlObject _mGuiIconButtonCtrl;
        private readonly GuiImageListObject _mGuiImageList;
        private readonly GuiInspectorObject _mGuiInspector;
        private readonly GuiInspectorDynamicFieldObject _mGuiInspectorDynamicField;
        private readonly GuiInspectorDynamicGroupObject _mGuiInspectorDynamicGroup;
        private readonly GuiInspectorFieldObject _mGuiInspectorField;
        private readonly GuiInspectorTypeBitMask32Object _mGuiInspectorTypeBitMask32;
        private readonly GuiInspectorTypeFileNameObject _mGuiInspectorTypeFileName;
        private readonly GuiListBoxCtrlObject _mGuiListBoxCtrl;
        private readonly GuiMLTextCtrlObject _mGuiMLTextCtrl;
        private readonly GuiMaterialCtrlObject _mGuiMaterialCtrl;
        private readonly GuiMaterialPreviewObject _mGuiMaterialPreview;
        private readonly GuiMenuBarObject _mGuiMenuBar;
        private readonly GuiMessageVectorCtrlObject _mGuiMessageVectorCtrl;
        private readonly GuiMissionAreaCtrlObject _mGuiMissionAreaCtrl;
        private readonly GuiObjectViewObject _mGuiObjectView;
        private readonly GuiPaneControlObject _mGuiPaneControl;
        private readonly GuiParticleGraphCtrlObject _mGuiParticleGraphCtrl;
        private readonly GuiPopUpMenuCtrlObject _mGuiPopUpMenuCtrl;
        private readonly GuiPopUpMenuCtrlExObject _mGuiPopUpMenuCtrlEx;
        private readonly GuiProgressBitmapCtrlObject _mGuiProgressBitmapCtrl;
        private readonly GuiRoadEditorCtrlObject _mGuiRoadEditorCtrl;
        private readonly GuiRolloutCtrlObject _mGuiRolloutCtrl;
        private readonly GuiScrollCtrlObject _mGuiScrollCtrl;
        private readonly GuiShapeEdPreviewObject _mGuiShapeEdPreview;
        private readonly GuiSliderCtrlObject _mGuiSliderCtrl;
        private readonly GuiStackControlObject _mGuiStackControl;
        private readonly GuiSwatchButtonCtrlObject _mGuiSwatchButtonCtrl;
        private readonly GuiTSCtrlObject _mGuiTSCtrl;
        private readonly GuiTabBookCtrlObject _mGuiTabBookCtrl;
        private readonly GuiTabPageCtrlObject _mGuiTabPageCtrl;
        private readonly GuiTextCtrlObject _mGuiTextCtrl;
        private readonly GuiTextEditCtrlObject _mGuiTextEditCtrl;
        private readonly GuiTextListCtrlObject _mGuiTextListCtrl;
        private readonly GuiTheoraCtrlObject _mGuiTheoraCtrl;
        private readonly GuiTickCtrlObject _mGuiTickCtrl;
        private readonly GuiToolboxButtonCtrlObject _mGuiToolboxButtonCtrl;
        private readonly GuiTreeViewCtrlObject _mGuiTreeViewCtrl;
        private readonly GuiVariableInspectorObject _mGuiVariableInspector;
        private readonly GuiWindowCtrlObject _mGuiWindowCtrl;
        private readonly HTTPObjectObject _mHTTPObject;
        private readonly InteriorInstanceObject _mInteriorInstance;
        private readonly ItemObject _mItem;
        private readonly LangTableObject _mLangTable;
        private readonly LightBaseObject _mLightBase;
        private readonly LightDescriptionObject _mLightDescription;
        private readonly LightFlareDataObject _mLightFlareData;
        private readonly LightningObject _mLightning;
        private readonly MECreateUndoActionObject _mMECreateUndoAction;
        private readonly MEDeleteUndoActionObject _mMEDeleteUndoAction;
        private readonly MaterialObject _mMaterial;

        /// <summary>
        /// A property exposing Custom Math console functions.
        /// </summary>
        private readonly tMath _mMathobject;

        private readonly MenuBarObject _mMenuBar;
        private readonly MeshRoadObject _mMeshRoad;
        private readonly MessageObject _mMessage;
        private readonly MessageVectorObject _mMessageVector;
        private readonly MissionAreaObject _mMissionArea;
        private readonly NetConnectionObject _mNetConnection;
        private readonly NetObjectObject _mNetObject;
        private readonly ParticleDataObject _mParticleData;
        private readonly ParticleEmitterDataObject _mParticleEmitterData;
        private readonly ParticleEmitterNodeObject _mParticleEmitterNode;
        private readonly PathCameraObject _mPathCamera;
        private readonly PathedInteriorObject _mPathedInterior;
        private readonly PersistenceManagerObject _mPersistenceManager;
        private readonly PhysicalZoneObject _mPhysicalZone;
        private readonly PhysicsDebrisDataObject _mPhysicsDebrisData;
        private readonly PhysicsForceObject _mPhysicsForce;
        private readonly PhysicsShapeObject _mPhysicsShape;
        private readonly PlayerObject _mPlayer;
        private readonly PopupMenuObject _mPopupMenu;
        private readonly PortalObject _mPortal;
        private readonly PostEffectObject _mPostEffect;
        private readonly PrecipitationObject _mPrecipitation;
        private readonly ProjectileObject _mProjectile;
        private readonly ProximityMineObject _mProximityMine;
        private readonly RenderBinManagerObject _mRenderBinManager;
        private readonly RenderMeshExampleObject _mRenderMeshExample;
        private readonly RenderPassManagerObject _mRenderPassManager;
        private readonly RenderPassStateTokenObject _mRenderPassStateToken;
        private readonly RigidShapeObject _mRigidShape;
        private readonly RiverObject _mRiver;
        private readonly SFXControllerObject _mSFXController;
        private readonly SFXEmitterObject _mSFXEmitter;
        private readonly SFXParameterObject _mSFXParameter;
        private readonly SFXProfileObject _mSFXProfile;
        private readonly SFXSoundObject _mSFXSound;
        private readonly SFXSourceObject _mSFXSource;
        private readonly SFXStateObject _mSFXState;
        private readonly ScatterSkyObject _mScatterSky;
        private readonly SceneObjectObject _mSceneObject;
        private readonly SettingsObject _mSettings;
        private readonly ShaderDataObject _mShaderData;
        private readonly ShapeBaseObject _mShapeBase;
        private readonly ShapeBaseDataObject _mShapeBaseData;
        private readonly SimComponentObject _mSimComponent;
        private readonly SimDataBlockObject _mSimDataBlock;
        private readonly SimObjectObject _mSimObject;
        private readonly SimPersistSetObject _mSimPersistSet;
        private readonly SimResponseCurveObject _mSimResponseCurve;
        private readonly SimSetObject _mSimSet;
        private readonly SimXMLDocumentObject _mSimXMLDocument;
        private readonly SkyBoxObject _mSkyBox;
        private readonly SpawnSphereObject _mSpawnSphere;
        private readonly StaticShapeObject _mStaticShape;
        private readonly StreamObjectObject _mStreamObject;
        private readonly SunObject _mSun;
        private readonly TCPObjectObject _mTCPObject;
        private readonly TSStaticObject _mTSStatic;
        private readonly TerrainBlockObject _mTerrainBlock;
        private readonly TimeOfDayObject _mTimeOfDay;
        private readonly TriggerObject _mTrigger;
        private readonly TurretShapeObject _mTurretShape;
        private readonly UndoActionObject _mUndoAction;
        private readonly UndoManagerObject _mUndoManager;
        private readonly UtilObject _mUtil;
        private readonly WheeledVehicleObject _mWheeledVehicle;
        private readonly WorldEditorObject _mWorldEditor;
        private readonly ZipObjectObject _mZipObject;
        private readonly ZoneObject _mZone;
        private readonly mbglobals _mbglobals = new mbglobals();
        private readonly mdglobals _mdglobals = new mdglobals();
        private readonly mfglobals _mfglobals = new mfglobals();

        private readonly mglobalsIsDefined _mglobalsIsDefined = new mglobalsIsDefined();
        private readonly miglobals _miglobals = new miglobals();

        private readonly msglobals _msglobals = new msglobals();

        /// <summary>
        /// 
        /// </summary>
        public TorqueScriptTemplate()
            {
            throw new Exception("Do Not Use");
            }

        /// <summary>
        /// Container Class for all the properties for organization.
        /// </summary>
        /// <param name="c"></param>
        public TorqueScriptTemplate(ref dnTorque c)
            {
            m_ts = c;
            _mConsoleobject = new ConsoleObject(ref c);
            _mMathobject = new tMath(ref c);
            _mUtil = new UtilObject(ref c);
            _mSimDataBlock = new SimDataBlockObject(ref c);
            _mSimObject = new SimObjectObject(ref c);
            _mActionMap = new ActionMapObject(ref c);
            _mAIClient = new AIClientObject(ref c);
            _mAIConnection = new AIConnectionObject(ref c);
            _mAIPlayer = new AIPlayerObject(ref c);
            _mAITurretShape = new AITurretShapeObject(ref c);
            _mArrayObject = new ArrayObjectObject(ref c);
            _mCamera = new CameraObject(ref c);
            _mCompoundUndoAction = new CompoundUndoActionObject(ref c);
            _mConsoleLogger = new ConsoleLoggerObject(ref c);
            _mCubemapData = new CubemapDataObject(ref c);
            _mDbgFileView = new DbgFileViewObject(ref c);
            _mDebris = new DebrisObject(ref c);
            _mDebugDrawer = new DebugDrawerObject(ref c);
            _mDecalData = new DecalDataObject(ref c);
            _mDecalRoad = new DecalRoadObject(ref c);
            _mDynamicConsoleMethodComponent = new DynamicConsoleMethodComponentObject(ref c);
            _mEditTSCtrl = new EditTSCtrlObject(ref c);
            _mEventManager = new EventManagerObject(ref c);
            _mFieldBrushObject = new FieldBrushObjectObject(ref c);
            _mFileDialog = new FileDialogObject(ref c);
            _mFileObject = new FileObjectObject(ref c);
            _mFileStreamObject = new FileStreamObjectObject(ref c);
            _mFlyingVehicle = new FlyingVehicleObject(ref c);
            _mForest = new ForestObject(ref c);
            _mForestBrush = new ForestBrushObject(ref c);
            _mForestBrushTool = new ForestBrushToolObject(ref c);
            _mForestEditorCtrl = new ForestEditorCtrlObject(ref c);
            _mForestSelectionTool = new ForestSelectionToolObject(ref c);
            _mForestWindEmitter = new ForestWindEmitterObject(ref c);
            _mGameBase = new GameBaseObject(ref c);
            _mGameConnection = new GameConnectionObject(ref c);
            _mGroundPlane = new GroundPlaneObject(ref c);
            _mGuiAutoScrollCtrl = new GuiAutoScrollCtrlObject(ref c);
            _mGuiBitmapButtonCtrl = new GuiBitmapButtonCtrlObject(ref c);
            _mGuiBitmapCtrl = new GuiBitmapCtrlObject(ref c);
            _mGuiButtonBaseCtrl = new GuiButtonBaseCtrlObject(ref c);
            _mGuiCanvas = new GuiCanvasObject(ref c);
            _mGuiCheckBoxCtrl = new GuiCheckBoxCtrlObject(ref c);
            _mGuiColorPickerCtrl = new GuiColorPickerCtrlObject(ref c);
            _mGuiControl = new GuiControlObject(ref c);
            _mGuiControlProfile = new GuiControlProfileObject(ref c);
            _mGuiDirectoryFileListCtrl = new GuiDirectoryFileListCtrlObject(ref c);
            _mGuiDragAndDropControl = new GuiDragAndDropControlObject(ref c);
            _mGuiDynamicCtrlArrayControl = new GuiDynamicCtrlArrayControlObject(ref c);
            _mGuiEditCtrl = new GuiEditCtrlObject(ref c);
            _mGuiFileTreeCtrl = new GuiFileTreeCtrlObject(ref c);
            _mGuiFilterCtrl = new GuiFilterCtrlObject(ref c);
            _mGuiFormCtrl = new GuiFormCtrlObject(ref c);
            _mGuiFrameSetCtrl = new GuiFrameSetCtrlObject(ref c);
            _mGuiGameListMenuCtrl = new GuiGameListMenuCtrlObject(ref c);
            _mGuiGameListOptionsCtrl = new GuiGameListOptionsCtrlObject(ref c);
            _mGuiGradientCtrl = new GuiGradientCtrlObject(ref c);
            _mGuiGraphCtrl = new GuiGraphCtrlObject(ref c);
            _mGuiIconButtonCtrl = new GuiIconButtonCtrlObject(ref c);
            _mGuiImageList = new GuiImageListObject(ref c);
            _mGuiInspector = new GuiInspectorObject(ref c);
            _mGuiInspectorDynamicField = new GuiInspectorDynamicFieldObject(ref c);
            _mGuiInspectorDynamicGroup = new GuiInspectorDynamicGroupObject(ref c);
            _mGuiInspectorField = new GuiInspectorFieldObject(ref c);
            _mGuiInspectorTypeBitMask32 = new GuiInspectorTypeBitMask32Object(ref c);
            _mGuiInspectorTypeFileName = new GuiInspectorTypeFileNameObject(ref c);
            _mGuiListBoxCtrl = new GuiListBoxCtrlObject(ref c);
            _mGuiMaterialCtrl = new GuiMaterialCtrlObject(ref c);
            _mGuiMaterialPreview = new GuiMaterialPreviewObject(ref c);
            _mGuiMenuBar = new GuiMenuBarObject(ref c);
            _mGuiMessageVectorCtrl = new GuiMessageVectorCtrlObject(ref c);
            _mGuiMissionAreaCtrl = new GuiMissionAreaCtrlObject(ref c);
            _mGuiMLTextCtrl = new GuiMLTextCtrlObject(ref c);
            _mGuiObjectView = new GuiObjectViewObject(ref c);
            _mGuiPaneControl = new GuiPaneControlObject(ref c);
            _mGuiParticleGraphCtrl = new GuiParticleGraphCtrlObject(ref c);
            _mGuiPopUpMenuCtrl = new GuiPopUpMenuCtrlObject(ref c);
            _mGuiPopUpMenuCtrlEx = new GuiPopUpMenuCtrlExObject(ref c);
            _mGuiProgressBitmapCtrl = new GuiProgressBitmapCtrlObject(ref c);
            _mGuiRoadEditorCtrl = new GuiRoadEditorCtrlObject(ref c);
            _mGuiRolloutCtrl = new GuiRolloutCtrlObject(ref c);
            _mGuiScrollCtrl = new GuiScrollCtrlObject(ref c);
            _mGuiShapeEdPreview = new GuiShapeEdPreviewObject(ref c);
            _mGuiSliderCtrl = new GuiSliderCtrlObject(ref c);
            _mGuiStackControl = new GuiStackControlObject(ref c);
            _mGuiSwatchButtonCtrl = new GuiSwatchButtonCtrlObject(ref c);
            _mGuiTabBookCtrl = new GuiTabBookCtrlObject(ref c);
            _mGuiTabPageCtrl = new GuiTabPageCtrlObject(ref c);
            _mGuiTextCtrl = new GuiTextCtrlObject(ref c);
            _mGuiTextEditCtrl = new GuiTextEditCtrlObject(ref c);
            _mGuiTextListCtrl = new GuiTextListCtrlObject(ref c);
            _mGuiTheoraCtrl = new GuiTheoraCtrlObject(ref c);
            _mGuiTickCtrl = new GuiTickCtrlObject(ref c);
            _mGuiToolboxButtonCtrl = new GuiToolboxButtonCtrlObject(ref c);
            _mGuiTreeViewCtrl = new GuiTreeViewCtrlObject(ref c);
            _mGuiTSCtrl = new GuiTSCtrlObject(ref c);
            _mGuiVariableInspector = new GuiVariableInspectorObject(ref c);
            _mGuiWindowCtrl = new GuiWindowCtrlObject(ref c);
            _mHTTPObject = new HTTPObjectObject(ref c);
            _mInteriorInstance = new InteriorInstanceObject(ref c);
            _mItem = new ItemObject(ref c);
            _mLangTable = new LangTableObject(ref c);
            _mLightBase = new LightBaseObject(ref c);
            _mLightDescription = new LightDescriptionObject(ref c);
            _mLightFlareData = new LightFlareDataObject(ref c);
            _mLightning = new LightningObject(ref c);
            _mMaterial = new MaterialObject(ref c);
            _mMECreateUndoAction = new MECreateUndoActionObject(ref c);
            _mMEDeleteUndoAction = new MEDeleteUndoActionObject(ref c);
            _mMenuBar = new MenuBarObject(ref c);
            _mMeshRoad = new MeshRoadObject(ref c);
            _mMessage = new MessageObject(ref c);
            _mMessageVector = new MessageVectorObject(ref c);
            _mMissionArea = new MissionAreaObject(ref c);
            _mNetConnection = new NetConnectionObject(ref c);
            _mNetObject = new NetObjectObject(ref c);
            _mParticleData = new ParticleDataObject(ref c);
            _mParticleEmitterData = new ParticleEmitterDataObject(ref c);
            _mParticleEmitterNode = new ParticleEmitterNodeObject(ref c);
            _mPathCamera = new PathCameraObject(ref c);
            _mPathedInterior = new PathedInteriorObject(ref c);
            _mPersistenceManager = new PersistenceManagerObject(ref c);
            _mPhysicalZone = new PhysicalZoneObject(ref c);
            _mPhysicsDebrisData = new PhysicsDebrisDataObject(ref c);
            _mPhysicsForce = new PhysicsForceObject(ref c);
            _mPhysicsShape = new PhysicsShapeObject(ref c);
            _mPlayer = new PlayerObject(ref c);
            _mPopupMenu = new PopupMenuObject(ref c);
            _mPortal = new PortalObject(ref c);
            _mPostEffect = new PostEffectObject(ref c);
            _mPrecipitation = new PrecipitationObject(ref c);
            _mProjectile = new ProjectileObject(ref c);
            _mProximityMine = new ProximityMineObject(ref c);
            _mRenderBinManager = new RenderBinManagerObject(ref c);
            _mRenderMeshExample = new RenderMeshExampleObject(ref c);
            _mRenderPassManager = new RenderPassManagerObject(ref c);
            _mRenderPassStateToken = new RenderPassStateTokenObject(ref c);
            _mRigidShape = new RigidShapeObject(ref c);
            _mRiver = new RiverObject(ref c);
            _mScatterSky = new ScatterSkyObject(ref c);
            _mSceneObject = new SceneObjectObject(ref c);
            _mSettings = new SettingsObject(ref c);
            _mSFXController = new SFXControllerObject(ref c);
            _mSFXEmitter = new SFXEmitterObject(ref c);
            _mSFXParameter = new SFXParameterObject(ref c);
            _mSFXProfile = new SFXProfileObject(ref c);
            _mSFXSound = new SFXSoundObject(ref c);
            _mSFXSource = new SFXSourceObject(ref c);
            _mSFXState = new SFXStateObject(ref c);
            _mShaderData = new ShaderDataObject(ref c);
            _mShapeBase = new ShapeBaseObject(ref c);
            _mShapeBaseData = new ShapeBaseDataObject(ref c);
            _mSimComponent = new SimComponentObject(ref c);
            _mSimPersistSet = new SimPersistSetObject(ref c);
            _mSimResponseCurve = new SimResponseCurveObject(ref c);
            _mSimSet = new SimSetObject(ref c);
            _mSimXMLDocument = new SimXMLDocumentObject(ref c);
            _mSkyBox = new SkyBoxObject(ref c);
            _mSpawnSphere = new SpawnSphereObject(ref c);
            _mStaticShape = new StaticShapeObject(ref c);
            _mStreamObject = new StreamObjectObject(ref c);
            _mSun = new SunObject(ref c);
            _mTCPObject = new TCPObjectObject(ref c);
            _mTerrainBlock = new TerrainBlockObject(ref c);
            _mTimeOfDay = new TimeOfDayObject(ref c);
            _mTrigger = new TriggerObject(ref c);
            _mTSStatic = new TSStaticObject(ref c);
            _mTurretShape = new TurretShapeObject(ref c);
            _mUndoAction = new UndoActionObject(ref c);
            _mUndoManager = new UndoManagerObject(ref c);
            _mWheeledVehicle = new WheeledVehicleObject(ref c);
            _mWorldEditor = new WorldEditorObject(ref c);
            _mZipObject = new ZipObjectObject(ref c);
            _mZone = new ZoneObject(ref c);
            }

        /// <summary>
        /// Used to grab string globals
        /// </summary>
        public mglobalsIsDefined isGlobal
            {
            get { return _mglobalsIsDefined; }
            }

        /// <summary>
        /// Used to grab string globals
        /// </summary>
        public msglobals sGlobal
            {
            get { return _msglobals; }
            }

        /// <summary>
        /// used to set/get int globals
        /// </summary>
        public miglobals iGlobal
            {
            get { return _miglobals; }
            }

        /// <summary>
        /// used to set/get bool globals
        /// </summary>
        public mbglobals bGlobal
            {
            get { return _mbglobals; }
            }


        /// <summary>
        /// used to set/get bool globals
        /// </summary>
        public mfglobals fGlobal
            {
            get { return _mfglobals; }
            }


        /// <summary>
        /// used to set/get bool globals
        /// </summary>
        public mdglobals dGlobal
            {
            get { return _mdglobals; }
            }

        /// <summary>
        /// A property exposing Custom dnTorque Console Functions.
        /// </summary>
        public ConsoleObject console
            {
            get { return _mConsoleobject; }
            }

        /// <summary>
        /// A property exposing Custom Math console functions.
        /// </summary>
        public tMath math
            {
            get { return _mMathobject; }
            }

        /// <summary>
        /// 
        /// </summary>
        public UtilObject Util
            {
            get { return _mUtil; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SimDataBlockObject SimDataBlock
            {
            get { return _mSimDataBlock; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SimObjectObject SimObject
            {
            get { return _mSimObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ActionMapObject ActionMap
            {
            get { return _mActionMap; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal AIClientObject AIClient
            {
            get { return _mAIClient; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal AIConnectionObject AIConnection
            {
            get { return _mAIConnection; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal AIPlayerObject AIPlayer
            {
            get { return _mAIPlayer; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal AITurretShapeObject AITurretShape
            {
            get { return _mAITurretShape; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ArrayObjectObject ArrayObject
            {
            get { return _mArrayObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal CameraObject Camera
            {
            get { return _mCamera; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal CompoundUndoActionObject CompoundUndoAction
            {
            get { return _mCompoundUndoAction; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ConsoleLoggerObject ConsoleLogger
            {
            get { return _mConsoleLogger; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal CubemapDataObject CubemapData
            {
            get { return _mCubemapData; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal DbgFileViewObject DbgFileView
            {
            get { return _mDbgFileView; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal DebrisObject Debris
            {
            get { return _mDebris; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal DebugDrawerObject DebugDrawer
            {
            get { return _mDebugDrawer; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal DecalDataObject DecalData
            {
            get { return _mDecalData; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal DecalRoadObject DecalRoad
            {
            get { return _mDecalRoad; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal DynamicConsoleMethodComponentObject DynamicConsoleMethodComponent
            {
            get { return _mDynamicConsoleMethodComponent; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal EditTSCtrlObject EditTSCtrl
            {
            get { return _mEditTSCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal EventManagerObject EventManager
            {
            get { return _mEventManager; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal FieldBrushObjectObject FieldBrushObject
            {
            get { return _mFieldBrushObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal FileDialogObject FileDialog
            {
            get { return _mFileDialog; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal FileObjectObject FileObject
            {
            get { return _mFileObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal FileStreamObjectObject FileStreamObject
            {
            get { return _mFileStreamObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal FlyingVehicleObject FlyingVehicle
            {
            get { return _mFlyingVehicle; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ForestObject Forest
            {
            get { return _mForest; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ForestBrushObject ForestBrush
            {
            get { return _mForestBrush; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ForestBrushToolObject ForestBrushTool
            {
            get { return _mForestBrushTool; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ForestEditorCtrlObject ForestEditorCtrl
            {
            get { return _mForestEditorCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ForestSelectionToolObject ForestSelectionTool
            {
            get { return _mForestSelectionTool; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ForestWindEmitterObject ForestWindEmitter
            {
            get { return _mForestWindEmitter; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GameBaseObject GameBase
            {
            get { return _mGameBase; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GameConnectionObject GameConnection
            {
            get { return _mGameConnection; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GroundPlaneObject GroundPlane
            {
            get { return _mGroundPlane; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiAutoScrollCtrlObject GuiAutoScrollCtrl
            {
            get { return _mGuiAutoScrollCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiBitmapButtonCtrlObject GuiBitmapButtonCtrl
            {
            get { return _mGuiBitmapButtonCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiBitmapCtrlObject GuiBitmapCtrl
            {
            get { return _mGuiBitmapCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiButtonBaseCtrlObject GuiButtonBaseCtrl
            {
            get { return _mGuiButtonBaseCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiCanvasObject GuiCanvas
            {
            get { return _mGuiCanvas; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiCheckBoxCtrlObject GuiCheckBoxCtrl
            {
            get { return _mGuiCheckBoxCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiColorPickerCtrlObject GuiColorPickerCtrl
            {
            get { return _mGuiColorPickerCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiControlObject GuiControl
            {
            get { return _mGuiControl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiControlProfileObject GuiControlProfile
            {
            get { return _mGuiControlProfile; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiDirectoryFileListCtrlObject GuiDirectoryFileListCtrl
            {
            get { return _mGuiDirectoryFileListCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiDragAndDropControlObject GuiDragAndDropControl
            {
            get { return _mGuiDragAndDropControl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiDynamicCtrlArrayControlObject GuiDynamicCtrlArrayControl
            {
            get { return _mGuiDynamicCtrlArrayControl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiEditCtrlObject GuiEditCtrl
            {
            get { return _mGuiEditCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiFileTreeCtrlObject GuiFileTreeCtrl
            {
            get { return _mGuiFileTreeCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiFilterCtrlObject GuiFilterCtrl
            {
            get { return _mGuiFilterCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiFormCtrlObject GuiFormCtrl
            {
            get { return _mGuiFormCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiFrameSetCtrlObject GuiFrameSetCtrl
            {
            get { return _mGuiFrameSetCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiGameListMenuCtrlObject GuiGameListMenuCtrl
            {
            get { return _mGuiGameListMenuCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiGameListOptionsCtrlObject GuiGameListOptionsCtrl
            {
            get { return _mGuiGameListOptionsCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiGradientCtrlObject GuiGradientCtrl
            {
            get { return _mGuiGradientCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiGraphCtrlObject GuiGraphCtrl
            {
            get { return _mGuiGraphCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiIconButtonCtrlObject GuiIconButtonCtrl
            {
            get { return _mGuiIconButtonCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiImageListObject GuiImageList
            {
            get { return _mGuiImageList; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiInspectorObject GuiInspector
            {
            get { return _mGuiInspector; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiInspectorDynamicFieldObject GuiInspectorDynamicField
            {
            get { return _mGuiInspectorDynamicField; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiInspectorDynamicGroupObject GuiInspectorDynamicGroup
            {
            get { return _mGuiInspectorDynamicGroup; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiInspectorFieldObject GuiInspectorField
            {
            get { return _mGuiInspectorField; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiInspectorTypeBitMask32Object GuiInspectorTypeBitMask32
            {
            get { return _mGuiInspectorTypeBitMask32; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiInspectorTypeFileNameObject GuiInspectorTypeFileName
            {
            get { return _mGuiInspectorTypeFileName; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiListBoxCtrlObject GuiListBoxCtrl
            {
            get { return _mGuiListBoxCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiMaterialCtrlObject GuiMaterialCtrl
            {
            get { return _mGuiMaterialCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiMaterialPreviewObject GuiMaterialPreview
            {
            get { return _mGuiMaterialPreview; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiMenuBarObject GuiMenuBar
            {
            get { return _mGuiMenuBar; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiMessageVectorCtrlObject GuiMessageVectorCtrl
            {
            get { return _mGuiMessageVectorCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiMissionAreaCtrlObject GuiMissionAreaCtrl
            {
            get { return _mGuiMissionAreaCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiMLTextCtrlObject GuiMLTextCtrl
            {
            get { return _mGuiMLTextCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiObjectViewObject GuiObjectView
            {
            get { return _mGuiObjectView; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiPaneControlObject GuiPaneControl
            {
            get { return _mGuiPaneControl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiParticleGraphCtrlObject GuiParticleGraphCtrl
            {
            get { return _mGuiParticleGraphCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiPopUpMenuCtrlObject GuiPopUpMenuCtrl
            {
            get { return _mGuiPopUpMenuCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiPopUpMenuCtrlExObject GuiPopUpMenuCtrlEx
            {
            get { return _mGuiPopUpMenuCtrlEx; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiProgressBitmapCtrlObject GuiProgressBitmapCtrl
            {
            get { return _mGuiProgressBitmapCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiRoadEditorCtrlObject GuiRoadEditorCtrl
            {
            get { return _mGuiRoadEditorCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiRolloutCtrlObject GuiRolloutCtrl
            {
            get { return _mGuiRolloutCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiScrollCtrlObject GuiScrollCtrl
            {
            get { return _mGuiScrollCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiShapeEdPreviewObject GuiShapeEdPreview
            {
            get { return _mGuiShapeEdPreview; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiSliderCtrlObject GuiSliderCtrl
            {
            get { return _mGuiSliderCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiStackControlObject GuiStackControl
            {
            get { return _mGuiStackControl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiSwatchButtonCtrlObject GuiSwatchButtonCtrl
            {
            get { return _mGuiSwatchButtonCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTabBookCtrlObject GuiTabBookCtrl
            {
            get { return _mGuiTabBookCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTabPageCtrlObject GuiTabPageCtrl
            {
            get { return _mGuiTabPageCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTextCtrlObject GuiTextCtrl
            {
            get { return _mGuiTextCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTextEditCtrlObject GuiTextEditCtrl
            {
            get { return _mGuiTextEditCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTextListCtrlObject GuiTextListCtrl
            {
            get { return _mGuiTextListCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTheoraCtrlObject GuiTheoraCtrl
            {
            get { return _mGuiTheoraCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTickCtrlObject GuiTickCtrl
            {
            get { return _mGuiTickCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiToolboxButtonCtrlObject GuiToolboxButtonCtrl
            {
            get { return _mGuiToolboxButtonCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTreeViewCtrlObject GuiTreeViewCtrl
            {
            get { return _mGuiTreeViewCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiTSCtrlObject GuiTSCtrl
            {
            get { return _mGuiTSCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiVariableInspectorObject GuiVariableInspector
            {
            get { return _mGuiVariableInspector; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal GuiWindowCtrlObject GuiWindowCtrl
            {
            get { return _mGuiWindowCtrl; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal HTTPObjectObject HTTPObject
            {
            get { return _mHTTPObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal InteriorInstanceObject InteriorInstance
            {
            get { return _mInteriorInstance; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ItemObject Item
            {
            get { return _mItem; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal LangTableObject LangTable
            {
            get { return _mLangTable; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal LightBaseObject LightBase
            {
            get { return _mLightBase; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal LightDescriptionObject LightDescription
            {
            get { return _mLightDescription; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal LightFlareDataObject LightFlareData
            {
            get { return _mLightFlareData; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal LightningObject Lightning
            {
            get { return _mLightning; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal MaterialObject Material
            {
            get { return _mMaterial; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal MECreateUndoActionObject MECreateUndoAction
            {
            get { return _mMECreateUndoAction; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal MEDeleteUndoActionObject MEDeleteUndoAction
            {
            get { return _mMEDeleteUndoAction; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal MenuBarObject MenuBar
            {
            get { return _mMenuBar; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal MeshRoadObject MeshRoad
            {
            get { return _mMeshRoad; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal MessageObject Message
            {
            get { return _mMessage; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal MessageVectorObject MessageVector
            {
            get { return _mMessageVector; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal MissionAreaObject MissionArea
            {
            get { return _mMissionArea; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal NetConnectionObject NetConnection
            {
            get { return _mNetConnection; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal NetObjectObject NetObject
            {
            get { return _mNetObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ParticleDataObject ParticleData
            {
            get { return _mParticleData; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ParticleEmitterDataObject ParticleEmitterData
            {
            get { return _mParticleEmitterData; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ParticleEmitterNodeObject ParticleEmitterNode
            {
            get { return _mParticleEmitterNode; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PathCameraObject PathCamera
            {
            get { return _mPathCamera; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PathedInteriorObject PathedInterior
            {
            get { return _mPathedInterior; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PersistenceManagerObject PersistenceManager
            {
            get { return _mPersistenceManager; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PhysicalZoneObject PhysicalZone
            {
            get { return _mPhysicalZone; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PhysicsDebrisDataObject PhysicsDebrisData
            {
            get { return _mPhysicsDebrisData; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PhysicsForceObject PhysicsForce
            {
            get { return _mPhysicsForce; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PhysicsShapeObject PhysicsShape
            {
            get { return _mPhysicsShape; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PlayerObject Player
            {
            get { return _mPlayer; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PopupMenuObject PopupMenu
            {
            get { return _mPopupMenu; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PortalObject Portal
            {
            get { return _mPortal; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PostEffectObject PostEffect
            {
            get { return _mPostEffect; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal PrecipitationObject Precipitation
            {
            get { return _mPrecipitation; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ProjectileObject Projectile
            {
            get { return _mProjectile; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ProximityMineObject ProximityMine
            {
            get { return _mProximityMine; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal RenderBinManagerObject RenderBinManager
            {
            get { return _mRenderBinManager; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal RenderMeshExampleObject RenderMeshExample
            {
            get { return _mRenderMeshExample; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal RenderPassManagerObject RenderPassManager
            {
            get { return _mRenderPassManager; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal RenderPassStateTokenObject RenderPassStateToken
            {
            get { return _mRenderPassStateToken; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal RigidShapeObject RigidShape
            {
            get { return _mRigidShape; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal RiverObject River
            {
            get { return _mRiver; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ScatterSkyObject ScatterSky
            {
            get { return _mScatterSky; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SceneObjectObject SceneObject
            {
            get { return _mSceneObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SettingsObject Settings
            {
            get { return _mSettings; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SFXControllerObject SFXController
            {
            get { return _mSFXController; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SFXEmitterObject SFXEmitter
            {
            get { return _mSFXEmitter; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SFXParameterObject SFXParameter
            {
            get { return _mSFXParameter; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SFXProfileObject SFXProfile
            {
            get { return _mSFXProfile; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SFXSoundObject SFXSound
            {
            get { return _mSFXSound; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SFXSourceObject SFXSource
            {
            get { return _mSFXSource; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SFXStateObject SFXState
            {
            get { return _mSFXState; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ShaderDataObject ShaderData
            {
            get { return _mShaderData; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ShapeBaseObject ShapeBase
            {
            get { return _mShapeBase; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ShapeBaseDataObject ShapeBaseData
            {
            get { return _mShapeBaseData; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SimComponentObject SimComponent
            {
            get { return _mSimComponent; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SimPersistSetObject SimPersistSet
            {
            get { return _mSimPersistSet; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SimResponseCurveObject SimResponseCurve
            {
            get { return _mSimResponseCurve; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SimSetObject SimSet
            {
            get { return _mSimSet; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SimXMLDocumentObject SimXMLDocument
            {
            get { return _mSimXMLDocument; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SkyBoxObject SkyBox
            {
            get { return _mSkyBox; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SpawnSphereObject SpawnSphere
            {
            get { return _mSpawnSphere; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal StaticShapeObject StaticShape
            {
            get { return _mStaticShape; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal StreamObjectObject StreamObject
            {
            get { return _mStreamObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal SunObject Sun
            {
            get { return _mSun; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal TCPObjectObject TCPObject
            {
            get { return _mTCPObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal TerrainBlockObject TerrainBlock
            {
            get { return _mTerrainBlock; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal TimeOfDayObject TimeOfDay
            {
            get { return _mTimeOfDay; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal TriggerObject Trigger
            {
            get { return _mTrigger; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal TSStaticObject TSStatic
            {
            get { return _mTSStatic; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal TurretShapeObject TurretShape
            {
            get { return _mTurretShape; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal UndoActionObject UndoAction
            {
            get { return _mUndoAction; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal UndoManagerObject UndoManager
            {
            get { return _mUndoManager; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal WheeledVehicleObject WheeledVehicle
            {
            get { return _mWheeledVehicle; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal WorldEditorObject WorldEditor
            {
            get { return _mWorldEditor; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ZipObjectObject ZipObject
            {
            get { return _mZipObject; }
            }

        /// <summary>
        /// 
        /// </summary>
        internal ZoneObject Zone
            {
            get { return _mZone; }
            }

        #region

        /// <summary>
        /// A list of all the Connection Object ID's active in Torque at the moment of request.
        /// </summary>
        public List<UInt32> ClientGroup
            {
            get
                {
                List<uint> temp = new List<uint>();
                for (uint i = 0; i < ClientGroup__GetCount(); i++)
                    {
                    temp.Add(ClientGroup__GetItem(i));
                    }
                return temp;
                }
            }

        /// <summary>
        /// The count of connection ID's
        /// </summary>
        /// <returns></returns>
        public UInt32 ClientGroup__GetCount()
            {
            return m_ts.ClientGroupGetCount();
            }

        /// <summary>
        /// Gets the object id at the index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public uint ClientGroup__GetItem(UInt32 index)
            {
            return m_ts.ClientGroupGetObject(index);
            }

        /// <summary>
        /// Removes the tagged string from Torque.
        /// </summary>
        /// <param name="tag"></param>
        public void removeTaggedString(string tag)
            {
            m_ts._removeTaggedString(tag);
            }

        #region Nested type: ConsoleObject

        /// <summary>
        /// Custom console commands.
        /// </summary>
        public class ConsoleObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// Constructor.
            /// </summary>
            /// <param name="ts"></param>
            public ConsoleObject(ref dnTorque ts)
                {
                m_ts = ts;
                }


            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public IntPtr torque_gethwnd()
                {
                return m_ts._torque_gethwnd();
                }

            /// <summary>
            /// Determines if the method is defined in the namespace.
            /// </summary>
            /// <param name="NameSpace"></param>
            /// <param name="method"></param>
            /// <returns></returns>
            public bool isMethodInNamespace(string NameSpace, string method)
                {
                //if they pass us an id, lets convert it to a name
                //before checking it.
                if (NameSpace.IsNumeric())
                    NameSpace = getName(NameSpace);
                return m_ts.NameSpaceIsMethod(NameSpace, method);
                }

            /// <summary>
            /// Removes the tagged string from Torque.
            /// </summary>
            /// <param name="tag"></param>
            public void removeTaggedString(string tag)
                {
                m_ts._removeTaggedString(tag);
                }

            /// <summary>
            /// 
            /// Executes the function on the simobject but a previous version of it.
            /// For example in TorqueScript you have:
            /// 
            /// function AIPlayer::Somefunction(%this)
            /// {
            /// Parent::SomeFunction(%this);
            /// }
            /// 
            /// Would translate to:
            /// 
            /// ParentExecute(thisobj,"SomeFunction",1,new string[]{thisobj});
            /// 
            /// </summary>
            /// <param name="simobject">This can be a simple type like "Player", or a complex type like "Client.Player"</param>
            /// <param name="function">Function to call</param>
            /// <param name="namespacedepth">how many generations up to go from the LAST generation.</param>
            /// <param name="parameters">Parameters to pass</param>
            /// <param name="DoNotPassDepth">By default, this will append a parameter to the end, telling the called function what depth it is currently at, setting this will turn that off.</param>
            /// <returns></returns>
            public string ParentExecute(string simobject, string function, int namespacedepth, string[] parameters, bool DoNotPassDepth = false)
                {
                return m_ts.ConsoleCallParent(simobject, function, namespacedepth, parameters, DoNotPassDepth);
                }

            /// <summary>
            /// Executes the global function  but a previous version of it.
            /// For example in TorqueScript you have:
            /// 
            /// function Somefunction(%Version1)
            /// {
            /// }
            /// 
            /// function Somefunction(%this)
            /// {
            /// Parent::SomeFunction(%this);
            /// }
            /// 
            /// Would translate to:
            /// 
            /// ParentExecute("SomeFunction",1,new string[]{thisobj});
            /// 
            /// </summary>
            /// <param name="function">Function to call</param>
            /// <param name="namespacedepth">how many generations up to go from the LAST generation.</param>
            /// <param name="parameters">Parameters to pass</param>
            /// <param name="DoNotPassDepth">By default, this will append a parameter to the end, telling the called function what depth it is currently at, setting this will turn that off.</param>
            /// <returns></returns>
            public string ParentExecute(string function, int namespacedepth, string[] parameters, bool DoNotPassDepth = false)
                {
                return m_ts.ConsoleCallParent(function, namespacedepth, parameters, DoNotPassDepth);
                }

            /// <summary>
            /// Executes the global function  but a previous version of it.
            /// For example in TorqueScript you have:
            /// 
            /// function Somefunction(%Version1)
            /// {
            /// }
            /// 
            /// function Somefunction(%this)
            /// {
            /// Parent::SomeFunction(%this);
            /// }
            /// 
            /// Would translate to:
            /// 
            /// ParentExecute("SomeFunction",1,new string[]{thisobj});
            /// 
            /// </summary>
            /// <param name="simobject">This can be a simple type like "Player", or a complex type like "Client.Player"</param>
            /// <param name="function"></param>
            /// <param name="namespacedepth">how many generations up to go from the LAST generation.</param>
            /// <param name="parameters">Parameters to pass</param>
            public string ParentExecute(string simobject, string function, int namespacedepth, string[] parameters)
                {
                return m_ts.ConsoleCallParent(simobject, function, namespacedepth, parameters);
                }


            /// <summary>
            /// The name is a slight misnormer, the classname can be:
            /// -A Simobject
            /// -A Class
            /// -A Package
            ///  </summary>
            /// <param name="classname">Simobject,Class or Package</param>
            /// <param name="function">Function to call</param>
            /// <returns></returns>
            public string Call_Classname(string classname, string function)
                {
                return m_ts.ConsoleCallCn(classname, function, new string[] {});
                }

            /// <summary>
            /// The name is a slight misnormer, the classname can be:
            /// -A Simobject
            /// -A Class
            /// -A Package
            ///  </summary>
            /// <param name="classname">Simobject,Class or Package</param>
            /// <param name="function">Function to call</param>
            /// <param name="parameters">Parameters to pass.</param>
            /// <returns></returns>
            public string Call_Classname(string classname, string function, string[] parameters)
                {
                return m_ts.ConsoleCallCn(classname, function, parameters);
                }

            /// <summary>
            /// Calls the function inside the Torque Dll.
            /// </summary>
            /// <param name="function">Global function to call</param>
            /// <param name="parameters">Parameters to pass.</param>
            /// <returns></returns>
            public string Call(string function, string[] parameters)
                {
                return m_ts.Execute(function, parameters);
                }

            /// <summary>
            /// Calls a function with no parameters.
            /// </summary>
            /// <param name="function"></param>
            /// <returns></returns>
            public string Call(string function)
                {
                return m_ts.Execute(function, new string[] {});
                }

            /// <summary>
            /// Calls the member function on the object with parameters.
            /// </summary>
            /// <param name="simobject">Torque object, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="function"></param>
            /// <param name="parameters"></param>
            /// <returns></returns>
            public string Call(string simobject, string function, string[] parameters)
                {
                return m_ts.SimObjectCall(simobject, function, parameters);
                }

            /// <summary>
            /// Calls the member function on the object without parameters.
            /// </summary>
            /// <param name="simobject">Torque object, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="function"></param>
            /// <returns></returns>
            public string Call(string simobject, string function)
                {
                return m_ts.SimObjectCall(simobject, function, new string[] {});
                }


            /// <summary>
            /// Returns the string for the passed tag.
            /// </summary>
            /// <param name="tag"></param>
            /// <returns></returns>
            public string getTaggedString(string tag)
                {
                return m_ts.GetTaggedString(tag);
                }

            /// <summary>
            /// Returns the current sim time.
            /// </summary>
            /// <returns></returns>
            public int getSimTime()
                {
                return m_ts.ConsoleGetSimTime();
                }

            /// <summary>
            /// Deprecated: Should probally use the Util class version
            /// Spawns a object in the world.
            /// </summary>
            /// <param name="spawnClass"></param>
            /// <param name="spawnDataBlock"></param>
            /// <param name="spawnName"></param>
            /// <param name="spawnProperties"></param>
            /// <param name="spawnScript"></param>
            /// <returns></returns>
            public UInt32 SpawnObject(string spawnClass, string spawnDataBlock, string spawnName, string spawnProperties, string spawnScript)
                {
                return m_ts.SpawnObject(spawnClass, spawnDataBlock, spawnName, spawnProperties, spawnScript);
                }

            /// <summary>
            /// Determines if function is in the namespace Hierarchy.
            /// </summary>
            /// <param name="simobject_id"></param>
            /// <param name="name"></param>
            /// <returns></returns>
            public bool isInNamespaceHierarchy(string simobject_id, string name)
                {
                return m_ts.NameSpaceIsInNamespaceHierarchy(simobject_id, name);
                }

            /// <summary>
            /// Returns the mask type for the passed simobject name or id.
            /// </summary>
            /// <param name="SceneObject"></param>
            /// <returns></returns>
            public UInt32 getTypeMask(string SceneObject)
                {
                return m_ts.SceneObjectGetTypeMask(SceneObject);
                }

            /// <summary>
            /// Returns a dictionary of the objects around the a point with their id and distance.
            /// </summary>
            /// <param name="pos"></param>
            /// <param name="raidus"></param>
            /// <param name="mask"></param>
            /// <param name="useclientcontainer"></param>
            /// <returns></returns>
            public Dictionary<uint, float> initContainerRadiusSearch(Point3F pos, float raidus, UInt32 mask, bool useclientcontainer)
                {
                return m_ts.SceneObjectInitContainerRadiusSearch(pos, raidus, mask, useclientcontainer);
                }

            /// <summary>
            /// Returns a dictionary of the objects around the a point with their id and distance.
            /// </summary>
            /// <param name="pos"></param>
            /// <param name="raidus"></param>
            /// <param name="mask"></param>
            public Dictionary<uint, float> initContainerRadiusSearch(Point3F pos, float raidus, UInt32 mask)
                {
                return m_ts.SceneObjectInitContainerRadiusSearch(pos, raidus, mask, false);
                }


            /// <summary>
            /// This function will take a normal string with torque color
            /// encoding commands and convert it to the correct format for color encoding
            /// inside of torque.
            /// </summary>
            /// <param name="mystring"></param>
            /// <returns></returns>
            public string ColorEncode(string mystring)
                {
                StringBuilder newstring = new StringBuilder();
                for (int i = 0; i < mystring.Length; i++)
                    {
                    if (mystring[i] == '\\')
                        {
                        if ((mystring[i + 1] == 't'))
                            {
                            newstring.Append("\t");
                            }
                        else if ((mystring[i + 1] == 'n'))
                            {
                            newstring.Append("\n");
                            }
                        else if ((mystring[i + 1] == 'r'))
                            {
                            newstring.Append("\r");
                            }

                        else if ((mystring[i + 1] == 'c') || (mystring[i + 1] == 'C'))
                            {
                            switch (mystring[i + 2].ToString(CultureInfo.InvariantCulture).ToLower())
                                {
                                    case "0":
                                        newstring.Append((char) 2);
                                        newstring.Append((char) 1);
                                        i = i + 2;
                                        break;
                                    case "1":
                                        newstring.Append((char) 2);
                                        i = i + 2;
                                        break;
                                    case "2":
                                        newstring.Append((char) 3);
                                        i = i + 2;
                                        break;
                                    case "3":
                                        newstring.Append((char) 4);
                                        i = i + 2;
                                        break;
                                    case "4":
                                        newstring.Append((char) 5);
                                        i = i + 2;
                                        break;
                                    case "5":
                                        newstring.Append((char) 6);
                                        i = i + 2;
                                        break;
                                    case "6":
                                        newstring.Append((char) 7);
                                        i = i + 2;
                                        break;
                                    case "7":
                                        newstring.Append((char) 11);
                                        i = i + 2;
                                        break;
                                    case "8":
                                        newstring.Append((char) 12);
                                        i = i + 2;
                                        break;
                                    case "9":
                                        newstring.Append((char) 14);
                                        i = i + 2;
                                        break;
                                    case "r":
                                        newstring.Append((char) 15);
                                        i = i + 2;
                                        break;
                                    case "p":
                                        newstring.Append((char) 16);
                                        i = i + 2;
                                        break;
                                    case "o":
                                        newstring.Append((char) 17);
                                        i = i + 2;
                                        break;

                                    default:
                                        newstring.Append(mystring[i]);
                                        break;
                                }
                            }
                        else
                            {
                            newstring.Append(mystring[i]);
                            }
                        }
                    else
                        {
                        newstring.Append(mystring[i]);
                        }
                    }
                return newstring.ToString();
                }

            /// <summary>
            /// Send a command to the client to execute the function
            /// </summary>
            /// <param name="client">Client connection ID, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="function">Function to execute.</param>
            public void commandToClient(string client, string function)
                {
                commandToClient(client, function, new string[] {});
                }

            /// <summary>
            /// Send a command to the client to execute the function
            /// </summary>
            /// <param name="client">Client connection ID, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="function">Function to execute.</param>
            /// <param name="parameters">Parameters to pass</param>
            public void commandToClient(string client, string function, string[] parameters)
                {
                m_ts.CommandToClient(client, function, parameters);
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, float value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, double value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(UInt32 variable, string value)
                {
                m_ts.SetVar(variable.AsString(), value);
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(UInt32 variable, Int16 value)
                {
                m_ts.SetVar(variable.AsString(), value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(UInt32 variable, Int32 value)
                {
                m_ts.SetVar(variable.AsString(), value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(UInt32 variable, Int64 value)
                {
                m_ts.SetVar(variable.AsString(), value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(UInt32 variable, UInt16 value)
                {
                m_ts.SetVar(variable.AsString(), value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(UInt32 variable, UInt32 value)
                {
                m_ts.SetVar(variable.AsString(), value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(UInt32 variable, UInt64 value)
                {
                m_ts.SetVar(variable.AsString(), value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(UInt32 variable, bool value)
                {
                m_ts.SetVar(variable.AsString(), value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, string value)
                {
                m_ts.SetVar(variable, value);
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, Int16 value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, Int32 value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, Int64 value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, UInt16 value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, UInt32 value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, UInt64 value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sets the passed torque variable to the value
            /// </summary>
            /// <param name="variable">Torque Variable to change, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="value"></param>
            public void SetVar(string variable, bool value)
                {
                m_ts.SetVar(variable, value.AsString());
                }

            /// <summary>
            /// Sends a command to the server to call the function
            /// </summary>
            /// <param name="function"></param>
            public void commandToServer(string function)
                {
                commandToServer(function, new string[] {});
                }

            /// <summary>
            /// Sends a command to the server to call the function with passed parameters.
            /// </summary>
            /// <param name="function"></param>
            /// <param name="parameters"></param>
            public void commandToServer(string function, string[] parameters)
                {
                m_ts.CommandToServer(function, parameters);
                }

            /// <summary>
            /// Gets the passed variable from torque
            /// Can be object.property.
            /// </summary>
            /// <param name="variable">Torque Variable to retrieve, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <returns></returns>
            public string GetVarString(string variable)
                {
                return m_ts.GetVar(variable);
                }

            /// <summary>
            /// Gets the passed variable from torque
            /// Can be object.property.
            /// </summary>
            /// <param name="variable">Torque Variable to retrieve, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <returns></returns>
            public bool GetVarBool(string variable)
                {
                int t = 0;
                string result = m_ts.GetVar(variable);
                if (result.Trim().ToLower() == "true")
                    return true;
                if (result.Trim().ToLower() == "false")
                    return false;
                if (result.Trim().ToLower() == "1")
                    return true;
                if (result.Trim().ToLower() == "0")
                    return false;
                if (int.TryParse(result, out t))
                    {
                    return t > 0;
                    }
                return false;
                }

            /// <summary>
            /// Gets the passed variable from torque
            /// Can be object.property.
            /// </summary>
            /// <param name="variable">Torque Variable to retrieve, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <returns></returns>
            public int GetVarInt(string variable)
                {
                string result = m_ts.GetVar(variable);
                if (result.Trim().ToLower() == "true")
                    return 1;
                if (result.Trim().ToLower() == "false")
                    return 0;
                return result.AsInt();
                }

            /// <summary>
            /// Gets the passed variable from torque
            /// Can be object.property.
            /// </summary>
            /// <param name="variable">Torque Variable to retrieve, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <returns></returns>
            public float GetVarFloat(string variable)
                {
                return m_ts.GetVar(variable).AsFloat();
                }

            /// <summary>
            /// Gets the passed variable from torque
            /// Can be object.property.
            /// </summary>
            /// <param name="variable">Torque Variable to retrieve, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <returns></returns>
            public uint GetVarUint(string variable)
                {
                return m_ts.GetVar(variable).AsUint();
                }

            /// <summary>
            /// Gets the passed variable from torque
            /// Can be object.property.
            /// </summary>
            /// <param name="variable">Torque Variable to retrieve, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <returns></returns>
            public long GetVarLong(string variable)
                {
                return m_ts.GetVar(variable).AsLong();
                }

            /// <summary>
            /// Gets the passed variable from torque
            /// Can be object.property.
            /// </summary>
            /// <param name="variable">Torque Variable to retrieve, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <returns></returns>
            public double GetVarDouble(string variable)
                {
                return m_ts.GetVar(variable).AsDouble();
                }

            /// <summary>
            /// Posts a warning inside of Torque.
            /// </summary>
            /// <param name="msg"></param>
            public void warn(string msg)
                {
                m_ts.Warn(msg);
                }

            /// <summary>
            /// Posts a debug message inside of Torque.
            /// </summary>
            /// <param name="msg"></param>
            public void debug(string msg)
                {
                if (m_ts.Debugging)
                    m_ts.Warn(msg);
                }

            /// <summary>
            /// Posts a Print message inside of Torque.
            /// </summary>
            /// <param name="msg"></param>
            public void print(string msg)
                {
                m_ts.Print(msg);
                }

            /// <summary>
            /// Posts an Error  message inside of Torque.
            /// </summary>
            /// <param name="msg"></param>
            public void error(string msg)
                {
                m_ts.Error(msg);
                }

            /// <summary>
            /// Determines if the number or string is a object.
            /// </summary>
            /// <param name="simobject">Torque Variable to check, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <returns></returns>
            public bool isObject(string simobject)
                {
                return m_ts.IsObject(simobject);
                }

            /// <summary>
            /// Calls clearServerPaths on the console.
            /// </summary>
            public void clearServerPaths()
                {
                m_ts.ClearServerPaths();
                }

            /// <summary>
            /// Deletes the variable inside of torque.
            /// </summary>
            /// <param name="var_name"></param>
            public void deleteVariables(string var_name)
                {
                m_ts.DeleteVariables(var_name);
                }

            /// <summary>
            /// Determines if the class is a member of the superclass.
            /// </summary>
            /// <param name="classname"></param>
            /// <param name="superclassname"></param>
            /// <returns></returns>
            public bool isMemberOfClass(string classname, string superclassname)
                {
                return m_ts.IsMemberOfClass(classname, superclassname);
                }

            /// <summary>
            /// Determines if the object has the passed method.
            /// </summary>
            /// <param name="simobject">Torque Variable to check, can be a simple or complex type.  i.e. "Client" or "Player.client"</param>
            /// <param name="method"></param>
            /// <returns></returns>
            public bool objectHasMethod(string simobject, string method)
                {
                return m_ts.ObjectHasMethod(simobject, method);
                }

            /// <summary>
            /// Adds a tagged string into the dictionary and returns it's tag id.
            /// </summary>
            /// <param name="mystring"></param>
            /// <returns></returns>
            public string addTaggedString(string mystring)
                {
                return m_ts.AddTaggedString(mystring);
                }

            /// <summary>
            /// Returns the classname for the simobject.
            /// </summary>
            /// <param name="simobject"></param>
            /// <returns></returns>
            public string GetClassName(string simobject)
                {
                return m_ts.GetClassName(simobject);
                }

            /// <summary>
            /// Returns the simobjectid for the simobject name.
            /// </summary>
            /// <param name="simobj_id"></param>
            /// <returns></returns>
            public UInt32 GetObjectID(string simobj_id)
                {
                return m_ts.GetObjectID(simobj_id);
                }

            /// <summary>
            /// Returns the name of the object (passed by id)
            /// </summary>
            /// <param name="name"></param>
            /// <returns></returns>
            public Int32 nameToID(string name)
                {
                return m_ts.NameToId(name);
                }

            /// <summary>
            /// Gets the name of the id.
            /// </summary>
            /// <param name="simobject"></param>
            /// <returns></returns>
            public string getName(string simobject)
                {
                return m_ts.GetName(simobject);
                }

            /// <summary>
            /// Evaluates the passed script and returns the resultant.
            /// </summary>
            /// <param name="script"></param>
            /// <param name="retval"></param>
            /// <returns></returns>
            public string Eval(string script, bool retval)
                {
                return m_ts.Evaluate(script, retval);
                }

            /// <summary>
            /// Executes the passed script.
            /// </summary>
            /// <param name="script"></param>
            public void Eval(string script)
                {
                m_ts.Evaluate(script, false);
                }


            /// <summary>
            /// Determines if the function is in the global name space.
            /// </summary>
            /// <param name="function_name"></param>
            /// <returns></returns>
            public bool isFunction(string function_name)
                {
                return m_ts.IsFunction(function_name);
                }

            /// <summary>
            /// Returns the Euler Rotation to the object.
            /// </summary>
            /// <param name="simobject"></param>
            /// <returns></returns>
            public TransformF getEulerRotation(string simobject)
                {
                return m_ts.GetEulerRotation(simobject);
                }

            /// <summary>
            /// Returns a list of simobject id's in the radius of the search.
            /// </summary>
            /// <param name="p"></param>
            /// <param name="searchradius"></param>
            /// <param name="searchmask"></param>
            /// <param name="useclientcontainer"></param>
            /// <returns></returns>
            public List<UInt32> ContainerRadiusSearch(Point3F p, double searchradius, UInt32 searchmask, bool useclientcontainer)
                {
                return m_ts.ContainerRadiusSearch(p, searchradius, searchmask, useclientcontainer);
                }

            /// <summary>
            /// Calls pathOnMissionLoadDone inside of Torque.
            /// </summary>
            public void pathOnMissionLoadDone()
                {
                m_ts.PathOnMissionLoadDone();
                }

            /// <summary>
            /// Returns the datablock associated with the simobject.
            /// </summary>
            /// <param name="simobject"></param>
            /// <returns></returns>
            public UInt32 getDatablock(string simobject)
                {
                return m_ts.GetDatablock(simobject);
                }

            /// <summary>
            /// Determines if the field is a member of the object.
            /// </summary>
            /// <param name="simobject_id"></param>
            /// <param name="fieldname"></param>
            /// <returns></returns>
            public bool isField(string simobject_id, string fieldname)
                {
                return m_ts.SimObjectIsField(simobject_id, fieldname);
                }
            }

        #endregion

        #region Nested type: tMath

        /// <summary>
        /// 
        /// </summary>
        public class tMath
            {
            /// <summary>
            /// 
            /// </summary>
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param>
            public tMath(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// 
            /// </summary>
            public static double M_2PI_F
                {
                get { return 3.1415926535897932384626433f*2.0f; }
                }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="transform"></param>
            /// <param name="vector"></param>
            /// <returns></returns>
            public TransformF MatrixMulVector(TransformF transform, Point3F vector)
                {
                return m_ts.MathMatrixMulVector(transform, vector);
                }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="d"></param>
            /// <returns></returns>
            public static double mDegToRad(double d)
                {
                return ((d*Math.PI)/180.0);
                }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="r"></param>
            /// <returns></returns>
            public static double mRadToDeg(double r)
                {
                return ((r*180.0)/Math.PI);
                }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="transform"></param>
            /// <returns></returns>
            public TransformF MatrixCreateFromEuler(TransformF transform)
                {
                return m_ts.MathMatrixCreateFromEuler(transform);
                }
            }

        #endregion

        #endregion

        #region Nested type: AIClientObject

        /// <summary>
        /// 
        /// </summary>
        public class AIClientObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public AIClientObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( AIClient, getAimLocation, const char *, 2, 2, ai.getAimLocation(); ) 
            /// </summary>
            public string getAimLocation(string aiclient = "")
                {
                return m_ts.fnAIClient_getAimLocation(aiclient);
                }

            /// <summary>
            /// ( AIClient, getLocation, const char *, 2, 2, ai.getLocation(); ) 
            /// </summary>
            public string getLocation(string aiclient = "")
                {
                return m_ts.fnAIClient_getLocation(aiclient);
                }

            /// <summary>
            /// ( AIClient, getMoveDestination, const char *, 2, 2, ai.getMoveDestination(); ) 
            /// </summary>
            public string getMoveDestination(string aiclient = "")
                {
                return m_ts.fnAIClient_getMoveDestination(aiclient);
                }

            /// <summary>
            /// ( AIClient, getTargetObject, S32, 2, 2, ai.getTargetObject(); ) 
            /// </summary>
            public int getTargetObject(string aiclient = "")
                {
                return m_ts.fnAIClient_getTargetObject(aiclient);
                }

            /// <summary>
            /// ( AIClient, missionCycleCleanup, void, 2, 2, ai.missionCycleCleanup(); ) 
            /// </summary>
            public void missionCycleCleanup(string aiclient = "")
                {
                m_ts.fnAIClient_missionCycleCleanup(aiclient);
                }

            /// <summary>
            /// ( AIClient, move, void, 2, 2, ai.move(); ) 
            /// </summary>
            public void move(string aiclient = "")
                {
                m_ts.fnAIClient_move(aiclient);
                }

            /// <summary>
            /// ( AIClient, moveForward, void, 2, 2, ai.moveForward(); ) 
            /// </summary>
            public void moveForward(string aiclient = "")
                {
                m_ts.fnAIClient_moveForward(aiclient);
                }

            /// <summary>
            /// ( AIClient, setAimLocation, void, 3, 3, ai.setAimLocation( x y z ); ) 
            /// </summary>
            public void setAimLocation(string aiclient, string a2 = "")
                {
                m_ts.fnAIClient_setAimLocation(aiclient, a2);
                }

            /// <summary>
            /// ( AIClient, setMoveDestination, void, 3, 3, ai.setMoveDestination( x y z ); ) 
            /// </summary>
            public void setMoveDestination(string aiclient, string a2 = "")
                {
                m_ts.fnAIClient_setMoveDestination(aiclient, a2);
                }

            /// <summary>
            /// ( AIClient, setMoveSpeed, void, 3, 3, ai.setMoveSpeed( float ); ) 
            /// </summary>
            public void setMoveSpeed(string aiclient, string a2 = "")
                {
                m_ts.fnAIClient_setMoveSpeed(aiclient, a2);
                }

            /// <summary>
            /// ( AIClient, setTargetObject, void, 3, 3, ai.setTargetObject( obj ); ) 
            /// </summary>
            public void setTargetObject(string aiclient, string a2 = "")
                {
                m_ts.fnAIClient_setTargetObject(aiclient, a2);
                }

            /// <summary>
            /// ( AIClient, stop, void, 2, 2, ai.stop(); ) 
            /// </summary>
            public void stop(string aiclient = "")
                {
                m_ts.fnAIClient_stop(aiclient);
                }
            }

        #endregion

        #region Nested type: AIConnectionObject

        /// <summary>
        /// 
        /// </summary>
        public class AIConnectionObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public AIConnectionObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (AIConnection,getAddress,const char*,2, 2,)
            /// 
            /// </summary>
            public string getAddress(string aiconnection = "")
                {
                return m_ts.fnAIConnection_getAddress(aiconnection);
                }

            /// <summary>
            /// (AIConnection,getFreeLook,bool,2, 2,getFreeLook()
            ///               Is freelook on for the current move?)
            /// 
            /// </summary>
            public bool getFreeLook(string aiconnection = "")
                {
                return m_ts.fnAIConnection_getFreeLook(aiconnection);
                }

            /// <summary>
            /// (AIConnection,getMove,F32,3, 3,(string field)
            ///               Get the given field of a move.
            ///               @param field One of {'x','y','z','yaw','pitch','roll'}
            ///               @returns The requested field on the current move.)
            /// 
            /// </summary>
            public float getMove(string aiconnection, string a2 = "")
                {
                return m_ts.fnAIConnection_getMove(aiconnection, a2);
                }

            /// <summary>
            /// (AIConnection,getTrigger,bool,4, 4,(int trigger)
            ///               Is the given trigger set?)
            /// 
            /// </summary>
            public bool getTrigger(string aiconnection, string a2, string a3 = "")
                {
                return m_ts.fnAIConnection_getTrigger(aiconnection, a2, a3);
                }

            /// <summary>
            /// (AIConnection,setFreeLook,void,3, 3,(bool isFreeLook)
            ///               Enable/disable freelook on the current move.)
            /// 
            /// </summary>
            public void setFreeLook(string aiconnection, string a2 = "")
                {
                m_ts.fnAIConnection_setFreeLook(aiconnection, a2);
                }

            /// <summary>
            /// (AIConnection,setMove,void,4, 4,(string field, float value)
            ///               Set a field on the current move.
            ///               @param   field One of {'x','y','z','yaw','pitch','roll'}
            ///               @param   value Value to set field to.)
            /// 
            /// </summary>
            public void setMove(string aiconnection, string a2, string a3 = "")
                {
                m_ts.fnAIConnection_setMove(aiconnection, a2, a3);
                }

            /// <summary>
            /// (AIConnection,setTrigger,void,4, 4,(int trigger, bool set)
            ///               Set a trigger.)
            /// 
            /// </summary>
            public void setTrigger(string aiconnection, string a2, string a3 = "")
                {
                m_ts.fnAIConnection_setTrigger(aiconnection, a2, a3);
                }
            }

        #endregion

        #region Nested type: AIPlayerObject

        /// <summary>
        /// 
        /// </summary>
        public class AIPlayerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public AIPlayerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Use this to stop aiming at an object or a point.
            ///    
            ///    @see setAimLocation()
            ///    @see setAimObject())
            /// 
            /// </summary>
            public void clearAim(string aiplayer)
                {
                m_ts.fnAIPlayer_clearAim(aiplayer);
                }

            /// <summary>
            /// @brief Returns the point the AIPlayer is aiming at.
            /// 
            ///    This will reflect the position set by setAimLocation(), 
            ///    or the position of the object that the bot is now aiming at.  
            ///    If the bot is not aiming at anything, this value will 
            ///    change to whatever point the bot's current line-of-sight intercepts.
            /// 
            ///    @return World space coordinates of the object AI is aiming at. Formatted as \"X Y Z\".
            ///    
            ///    @see setAimLocation()
            ///    @see setAimObject())
            /// 
            /// </summary>
            public Point3F getAimLocation(string aiplayer)
                {
                return new Point3F(m_ts.fnAIPlayer_getAimLocation(aiplayer));
                }

            /// <summary>
            /// @brief Gets the object the AIPlayer is targeting.
            /// 
            ///    @return Returns -1 if no object is being aimed at, 
            ///    or the SimObjectID of the object the AIPlayer is aiming at.
            ///    
            ///    @see setAimObject())
            /// 
            /// </summary>
            public int getAimObject(string aiplayer)
                {
                return m_ts.fnAIPlayer_getAimObject(aiplayer);
                }

            /// <summary>
            /// @brief Get the AIPlayer's current destination.
            /// 
            ///    @return Returns a point containing the \"x y z\" position 
            ///    of the AIPlayer's current move destination. If no move destination 
            ///    has yet been set, this returns \"0 0 0\".
            ///    
            ///    @see setMoveDestination())
            /// 
            /// </summary>
            public Point3F getMoveDestination(string aiplayer)
                {
                return new Point3F(m_ts.fnAIPlayer_getMoveDestination(aiplayer));
                }

            /// <summary>
            /// @brief Gets the move speed of an AI object.
            /// 
            ///    @return A speed multiplier between 0.0 and 1.0.
            /// 
            ///    @see setMoveSpeed())
            /// 
            /// </summary>
            public float getMoveSpeed(string aiplayer)
                {
                return m_ts.fnAIPlayer_getMoveSpeed(aiplayer);
                }

            /// <summary>
            /// @brief Tells the AIPlayer to aim at the location provided.
            /// 
            ///    @param target An \"x y z\" position in the game world to target.
            ///    
            ///    @see getAimLocation())
            /// 
            /// </summary>
            public void setAimLocation(string aiplayer, Point3F target)
                {
                m_ts.fnAIPlayer_setAimLocation(aiplayer, target.AsString());
                }

            /// <summary>
            /// ( AIPlayer, setAimObject, void, 3, 4, ( GameBase obj, [Point3F offset] )
            ///               Sets the bot's target object. Optionally set an offset from target location.
            /// 			  @hide)
            /// 
            /// </summary>
            public void setAimObject(string aiplayer, string a2 = "", string a3 = "")
                {
                m_ts.fnAIPlayer_setAimObject(aiplayer, a2, a3);
                }

            /// <summary>
            /// @brief Tells the AI to move to the location provided
            /// 
            ///    @param goal Coordinates in world space representing location to move to.
            ///    @param slowDown A boolean value. If set to true, the bot will slow down 
            ///    when it gets within 5-meters of its move destination. If false, the bot 
            ///    will stop abruptly when it reaches the move destination. By default, this is true.
            /// 
            ///    @note Upon reaching a move destination, the bot will clear its move destination and 
            ///    calls to getMoveDestination will return \"0 0 0\".
            ///    
            ///    @see getMoveDestination())
            /// 
            /// </summary>
            public void setMoveDestination(string aiplayer, Point3F goal, bool slowDown)
                {
                m_ts.fnAIPlayer_setMoveDestination(aiplayer, goal.AsString(), slowDown);
                }

            /// <summary>
            /// @brief Sets the move speed for an AI object.
            /// 
            ///    @param speed A speed multiplier between 0.0 and 1.0.  
            ///    This is multiplied by the AIPlayer's base movement rates (as defined in 
            ///    its PlayerData datablock)
            ///    
            ///    @see getMoveDestination())
            /// 
            /// </summary>
            public void setMoveSpeed(string aiplayer, float speed)
                {
                m_ts.fnAIPlayer_setMoveSpeed(aiplayer, speed);
                }

            /// <summary>
            /// @brief Tells the AIPlayer to stop moving.)
            /// 
            /// </summary>
            public void stop(string aiplayer)
                {
                m_ts.fnAIPlayer_stop(aiplayer);
                }
            }

        #endregion

        #region Nested type: AITurretShapeObject

        /// <summary>
        /// 
        /// </summary>
        public class AITurretShapeObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public AITurretShapeObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Activate a turret from a deactive state.)
            /// 
            /// </summary>
            public void activateTurret(string aiturretshape)
                {
                m_ts.fnAITurretShape_activateTurret(aiturretshape);
                }

            /// <summary>
            /// @brief Adds object to the turret's ignore list.
            ///    All objects in this list will be ignored by the turret's targeting.
            ///    @param obj The ShapeBase object to ignore.)
            /// 
            /// </summary>
            public void addToIgnoreList(string aiturretshape, string obj)
                {
                m_ts.fnAITurretShape_addToIgnoreList(aiturretshape, obj);
                }

            /// <summary>
            /// @brief Deactivate a turret from an active state.)
            /// 
            /// </summary>
            public void deactivateTurret(string aiturretshape)
                {
                m_ts.fnAITurretShape_deactivateTurret(aiturretshape);
                }

            /// <summary>
            /// @brief Get the turret's current target.
            ///    @returns The object that is the target's current target, or 0 if no target.)
            /// 
            /// </summary>
            public string getTarget(string aiturretshape)
                {
                return m_ts.fnAITurretShape_getTarget(aiturretshape);
                }

            /// <summary>
            /// @brief Get the turret's defined projectile velocity that helps with target leading.
            ///    @returns The defined weapon projectile speed, or 0 if leading is disabled.)
            /// 
            /// </summary>
            public float getWeaponLeadVelocity(string aiturretshape)
                {
                return m_ts.fnAITurretShape_getWeaponLeadVelocity(aiturretshape);
                }

            /// <summary>
            /// @brief Indicates if the turret has a target.
            ///    @returns True if the turret has a target.)
            /// 
            /// </summary>
            public bool hasTarget(string aiturretshape)
                {
                return m_ts.fnAITurretShape_hasTarget(aiturretshape);
                }

            /// <summary>
            /// @brief Recenter the turret's weapon.)
            /// 
            /// </summary>
            public void recenterTurret(string aiturretshape)
                {
                m_ts.fnAITurretShape_recenterTurret(aiturretshape);
                }

            /// <summary>
            /// @brief Removes object from the turret's ignore list.
            ///    All objects in this list will be ignored by the turret's targeting.
            ///    @param obj The ShapeBase object to once again allow for targeting.)
            /// 
            /// </summary>
            public void removeFromIgnoreList(string aiturretshape, string obj)
                {
                m_ts.fnAITurretShape_removeFromIgnoreList(aiturretshape, obj);
                }

            /// <summary>
            /// @brief Resets the turret's target tracking.
            ///    Only resets the internal target tracking.  Does not modify the turret's facing.)
            /// 
            /// </summary>
            public void resetTarget(string aiturretshape)
                {
                m_ts.fnAITurretShape_resetTarget(aiturretshape);
                }

            /// <summary>
            /// @brief Set the firing state of the turret's guns.
            ///    @param fire Set to true to activate all guns.  False to deactivate them.)
            /// 
            /// </summary>
            public void setAllGunsFiring(string aiturretshape, bool fire)
                {
                m_ts.fnAITurretShape_setAllGunsFiring(aiturretshape, fire);
                }

            /// <summary>
            /// @brief Set the firing state of the given gun slot.
            ///    @param slot The gun to modify.  Valid range is 0-3 that corresponds to the weapon mount point.
            ///    @param fire Set to true to activate the gun.  False to deactivate it.)
            /// 
            /// </summary>
            public void setGunSlotFiring(string aiturretshape, int slot, bool fire)
                {
                m_ts.fnAITurretShape_setGunSlotFiring(aiturretshape, slot, fire);
                }

            /// <summary>
            /// @brief Set the turret's current state.
            ///    Normally the turret's state comes from updating the state machine but this method 
            ///    allows you to override this and jump to the requested state immediately.
            ///    @param newState The name of the new state.
            ///    @param force Is true then force the full processing of the new state even if it is the 
            ///    same as the current state.  If false then only the time out value is reset and the state's 
            ///    script method is called, if any.)
            /// 
            /// </summary>
            public void setTurretState(string aiturretshape, string newState, bool force)
                {
                m_ts.fnAITurretShape_setTurretState(aiturretshape, newState, force);
                }

            /// <summary>
            /// @brief Set the turret's projectile velocity to help lead the target.
            ///    This value normally comes from AITurretShapeData::weaponLeadVelocity but this method 
            ///    allows you to override the datablock value.  This can be useful if the turret changes 
            ///    ammunition, uses a different weapon than the default, is damaged, etc.
            ///    @note Setting this to 0 will disable target leading.)
            /// 
            /// </summary>
            public void setWeaponLeadVelocity(string aiturretshape, float velocity)
                {
                m_ts.fnAITurretShape_setWeaponLeadVelocity(aiturretshape, velocity);
                }

            /// <summary>
            /// @brief Begin scanning for a target.)
            /// 
            /// </summary>
            public void startScanForTargets(string aiturretshape)
                {
                m_ts.fnAITurretShape_startScanForTargets(aiturretshape);
                }

            /// <summary>
            /// @brief Have the turret track the current target.)
            /// 
            /// </summary>
            public void startTrackingTarget(string aiturretshape)
                {
                m_ts.fnAITurretShape_startTrackingTarget(aiturretshape);
                }

            /// <summary>
            /// @brief Stop scanning for targets.
            ///    @note Only impacts the scanning for new targets.  Does not effect a turret's current 
            ///    target lock.)
            /// 
            /// </summary>
            public void stopScanForTargets(string aiturretshape)
                {
                m_ts.fnAITurretShape_stopScanForTargets(aiturretshape);
                }

            /// <summary>
            /// @brief Stop the turret from tracking the current target.)
            /// 
            /// </summary>
            public void stopTrackingTarget(string aiturretshape)
                {
                m_ts.fnAITurretShape_stopTrackingTarget(aiturretshape);
                }
            }

        #endregion

        #region Nested type: ActionMapObject

        /// <summary>
        /// 
        /// </summary>
        public class ActionMapObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ActionMapObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( ActionMap, bind, bool, 5, 10, actionMap.bind( device, action, [modifier spec, mod...], command ) 
            /// 			  @hide)
            /// 
            /// </summary>
            public bool bind(string actionmap, string a2, string a3, string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "")
                {
                return m_ts.fnActionMap_bind(actionmap, a2, a3, a4, a5, a6, a7, a8, a9);
                }

            /// <summary>
            ///  ),
            ///     @brief Associates a make command and optional break command to a specified input device action.
            ///     Must include parenthesis and semicolon in the make and break command strings.
            ///     @param device The device to bind to. Can be a keyboard, mouse, joystick or gamepad.
            ///     @param action The device action to bind to. The action is dependant upon the device. Specify a key for keyboards.
            ///     @param makeCmd The command to execute when the device/action is made.
            ///     @param breakCmd [optional] The command to execute when the device or action is unmade.
            ///     @return True the bind was successful, false if the device was unknown or description failed.
            /// 	@tsexample
            /// 	// Print to the console when the spacebar is pressed
            /// 	function onSpaceDown()
            /// 	{
            /// 	   echo(\"Space bar down!\");
            /// 	}
            /// 	// Print to the console when the spacebar is released
            /// 	function onSpaceUp()
            /// 	{
            /// 	   echo(\"Space bar up!\");
            /// 	}
            ///    // Bind the commands onSpaceDown() and onSpaceUp() to spacebar events
            /// 	moveMap.bindCmd(keyboard, \"space\", \"onSpaceDown();\", \"onSpaceUp();\");
            /// 	@endtsexample)
            /// 
            /// </summary>
            public bool bindCmd(string actionmap, string device, string action, string makeCmd, string breakCmd)
                {
                return m_ts.fnActionMap_bindCmd(actionmap, device, action, makeCmd, breakCmd);
                }

            /// <summary>
            /// ( ActionMap, bindObj, bool, 6, 11, (device, action, [modifier spec, mod...], command, object)
            /// 			  @hide)
            /// 
            /// </summary>
            public bool bindObj(string actionmap, string a2, string a3, string a4, string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "")
                {
                return m_ts.fnActionMap_bindObj(actionmap, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                }

            /// <summary>
            /// @brief Gets the ActionMap binding for the specified command.
            ///    Use getField() on the return value to get the device and action of the binding.
            ///    @param command The function to search bindings for.
            ///    @return The binding against the specified command. Returns an empty string(\"\") 
            ///    if a binding wasn't found.
            /// 	@tsexample
            /// 	// Find what the function \"jump()\" is bound to in moveMap
            /// 	%bind = moveMap.getBinding( \"jump\" );
            /// 	if ( %bind !$= \"\" )
            /// 	{
            /// 	// Find out what device is used in the binding
            /// 		%device = getField( %bind, 0 );
            /// 	// Find out what action (such as a key) is used in the binding
            /// 		%action = getField( %bind, 1 );
            /// 	}
            /// 	@endtsexample
            ///    @see getField)
            /// 
            /// </summary>
            public string getBinding(string actionmap, string command)
                {
                return m_ts.fnActionMap_getBinding(actionmap, command);
                }

            /// <summary>
            /// @brief Gets ActionMap command for the device and action.
            ///    @param device The device that was bound. Can be a keyboard, mouse, joystick or a gamepad.
            ///    @param action The device action that was bound.  The action is dependant upon the device. Specify a key for keyboards.
            ///    @return The command against the specified device and action.
            /// 	@tsexample
            /// 	// Find what function is bound to a device\'s action
            /// 	// In this example, \"jump()\" was assigned to the space key in another script
            /// 	%command = moveMap.getCommand(\"keyboard\", \"space\");
            /// 	// Should print \"jump\" in the console
            /// 	echo(%command)
            /// 	@endtsexample)
            /// 
            /// </summary>
            public string getCommand(string actionmap, string device, string action)
                {
                return m_ts.fnActionMap_getCommand(actionmap, device, action);
                }

            /// <summary>
            /// @brief Gets the Dead zone for the specified device and action.
            ///    @param device The device that was bound.  Can be a keyboard, mouse, joystick or a gamepad.
            ///    @param action The device action that was bound. The action is dependant upon the device. Specify a key for keyboards.
            ///    @return The dead zone for the specified device and action. Returns \"0 0\" if there is no dead zone  
            ///    or an empty string(\"\") if the mapping was not found.
            /// 	@tsexample
            /// 	%deadZone = moveMap.getDeadZone( \"gamepad\", \"thumbrx\");
            /// 	@endtsexample)
            /// 
            /// </summary>
            public string getDeadZone(string actionmap, string device, string action)
                {
                return m_ts.fnActionMap_getDeadZone(actionmap, device, action);
                }

            /// <summary>
            /// @brief Get any scaling on the specified device and action.
            ///    @param device The device that was bound. Can be keyboard, mouse, joystick or gamepad.
            ///    @param action The device action that was bound. The action is dependant upon the device. Specify a key for keyboards.
            ///    @return Any scaling applied to the specified device and action.
            /// 	@tsexample
            /// 	%scale = %moveMap.getScale( \"gamepad\", \"thumbrx\");
            /// 	@endtsexample)
            /// 
            /// </summary>
            public float getScale(string actionmap, string device, string action)
                {
                return m_ts.fnActionMap_getScale(actionmap, device, action);
                }

            /// <summary>
            /// @brief Determines if the specified device and action is inverted.
            ///    Should only be used for scrolling devices or gamepad/joystick axes.
            ///    @param device The device that was bound. Can be a keyboard, mouse, joystick or a gamepad.
            ///    @param action The device action that was bound.  The action is dependant upon the device. Specify a key for keyboards.
            ///    @return True if the specified device and action is inverted.
            /// 	@tsexample
            ///    %if ( moveMap.isInverted( \"mouse\", \"xaxis\"))
            ///       echo(\"Mouse's xAxis is inverted\");
            /// 	@endtsexample)
            /// 
            /// </summary>
            public bool isInverted(string actionmap, string device, string action)
                {
                return m_ts.fnActionMap_isInverted(actionmap, device, action);
                }

            /// <summary>
            /// @brief Pop the ActionMap off the %ActionMap stack.
            ///    Deactivates an %ActionMap and removes it from the @ActionMap stack.
            /// 	@tsexample
            /// 	// Deactivate moveMap
            /// 	moveMap.pop();
            /// 	@endtsexample
            ///    @see ActionMap)
            /// 
            /// </summary>
            public void pop(string actionmap)
                {
                m_ts.fnActionMap_pop(actionmap);
                }

            /// <summary>
            /// @brief Push the ActionMap onto the %ActionMap stack.
            ///    Activates an ActionMap and placees it at the top of the ActionMap stack.
            /// 	@tsexample
            /// 	// Make moveMap the active action map
            /// 	moveMap.push();
            /// 	@endtsexample
            ///    @see ActionMap)
            /// 
            /// </summary>
            public void push(string actionmap)
                {
                m_ts.fnActionMap_push(actionmap);
                }

            /// <summary>
            /// @brief Saves the ActionMap to a file or dumps it to the console.
            ///    @param fileName The file path to save the ActionMap to. If a filename is not specified 
            ///     the ActionMap will be dumped to the console.
            ///    @param append Whether to write the ActionMap at the end of the file or overwrite it.
            /// 	@tsexample
            /// 	// Write out the actionmap into the config.cs file
            ///    moveMap.save( \"scripts/client/config.cs\" );
            /// 	@endtsexample)
            /// 
            /// </summary>
            public void save(string actionmap, string fileName, bool append)
                {
                m_ts.fnActionMap_save(actionmap, fileName, append);
                }

            /// <summary>
            /// @brief Removes the binding on an input device and action.
            ///    @param device The device to unbind from. Can be a keyboard, mouse, joystick or a gamepad.
            ///    @param action The device action to unbind from. The action is dependant upon the device. Specify a key for keyboards.
            ///    @return True if the unbind was successful, false if the device was unknown or description failed.
            /// 	@tsexample
            /// 	moveMap.unbind(\"keyboard\", \"space\");
            /// 	@endtsexample)
            /// 
            /// </summary>
            public bool unbind(string actionmap, string device, string action)
                {
                return m_ts.fnActionMap_unbind(actionmap, device, action);
                }

            /// <summary>
            /// @brief Remove any object-binding on an input device and action.
            ///    @param device The device to bind to.  Can be keyboard, mouse, joystick or gamepad.
            ///    @param action The device action to unbind from. The action is dependant upon the device. Specify a key for keyboards.
            ///    @param obj The object to perform unbind against.
            ///    @return True if the unbind was successful, false if the device was unknown or description failed.
            /// 	@tsexample
            ///    moveMap.unbindObj(\"keyboard\", \"numpad1\", \"rangeChange\", %player);
            ///    @endtsexample)
            /// 
            /// </summary>
            public bool unbindObj(string actionmap, string device, string action, string obj)
                {
                return m_ts.fnActionMap_unbindObj(actionmap, device, action, obj);
                }
            }

        #endregion

        #region Nested type: ArrayObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class ArrayObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ArrayObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            ///  ),
            ///    Adds a new element to the end of an array (same as push_back()).
            ///    @param key Key for the new element
            ///    @param value Value for the new element )
            /// 
            /// </summary>
            public void add(string arrayobject, string key, string value)
                {
                m_ts.fnArrayObject_add(arrayobject, key, value);
                }

            /// <summary>
            /// Appends the target array to the array object.
            ///    @param target ArrayObject to append to the end of this array )
            /// 
            /// </summary>
            public bool append(string arrayobject, string target)
                {
                return m_ts.fnArrayObject_append(arrayobject, target);
                }

            /// <summary>
            /// Get the number of elements in the array. )
            /// 
            /// </summary>
            public int count(string arrayobject)
                {
                return m_ts.fnArrayObject_count(arrayobject);
                }

            /// <summary>
            /// Get the number of times a particular key is found in the array.
            ///    @param key Key value to count )
            /// 
            /// </summary>
            public int countKey(string arrayobject, string key)
                {
                return m_ts.fnArrayObject_countKey(arrayobject, key);
                }

            /// <summary>
            /// Get the number of times a particular value is found in the array.
            ///    @param value Array element value to count )
            /// 
            /// </summary>
            public int countValue(string arrayobject, string value)
                {
                return m_ts.fnArrayObject_countValue(arrayobject, value);
                }

            /// <summary>
            /// Removes elements with matching keys from array.
            ///    @param target ArrayObject containing keys to remove from this array )
            /// 
            /// </summary>
            public bool crop(string arrayobject, string target)
                {
                return m_ts.fnArrayObject_crop(arrayobject, target);
                }

            /// <summary>
            /// Alters array into an exact duplicate of the target array.
            ///    @param target ArrayObject to duplicate )
            /// 
            /// </summary>
            public bool duplicate(string arrayobject, string target)
                {
                return m_ts.fnArrayObject_duplicate(arrayobject, target);
                }

            /// <summary>
            /// Echos the array contents to the console )
            /// 
            /// </summary>
            public void echo(string arrayobject)
                {
                m_ts.fnArrayObject_echo(arrayobject);
                }

            /// <summary>
            /// Emptys all elements from an array )
            /// 
            /// </summary>
            public void empty(string arrayobject)
                {
                m_ts.fnArrayObject_empty(arrayobject);
                }

            /// <summary>
            /// Removes an element at a specific position from the array.
            ///    @param index 0-based index of the element to remove )
            /// 
            /// </summary>
            public void erase(string arrayobject, int index)
                {
                m_ts.fnArrayObject_erase(arrayobject, index);
                }

            /// <summary>
            /// Gets the current pointer index )
            /// 
            /// </summary>
            public int getCurrent(string arrayobject)
                {
                return m_ts.fnArrayObject_getCurrent(arrayobject);
                }

            /// <summary>
            /// Search the array from the current position for the key 
            ///    @param value Array key to search for
            ///    @return Index of the first element found, or -1 if none )
            /// 
            /// </summary>
            public int getIndexFromKey(string arrayobject, string key)
                {
                return m_ts.fnArrayObject_getIndexFromKey(arrayobject, key);
                }

            /// <summary>
            /// Search the array from the current position for the element 
            ///    @param value Array value to search for
            ///    @return Index of the first element found, or -1 if none )
            /// 
            /// </summary>
            public int getIndexFromValue(string arrayobject, string value)
                {
                return m_ts.fnArrayObject_getIndexFromValue(arrayobject, value);
                }

            /// <summary>
            /// Get the key of the array element at the submitted index.
            ///    @param index 0-based index of the array element to get
            ///    @return The key associated with the array element at the 
            ///    specified index, or \"\" if the index is out of range )
            /// 
            /// </summary>
            public string getKey(string arrayobject, int index)
                {
                return m_ts.fnArrayObject_getKey(arrayobject, index);
                }

            /// <summary>
            /// Get the value of the array element at the submitted index.
            ///    @param index 0-based index of the array element to get
            ///    @return The value of the array element at the specified index, 
            ///    or \"\" if the index is out of range )
            /// 
            /// </summary>
            public string getValue(string arrayobject, int index)
                {
                return m_ts.fnArrayObject_getValue(arrayobject, index);
                }

            /// <summary>
            /// Adds a new element to a specified position in the array.
            ///    - @a index = 0 will insert an element at the start of the array (same as push_front())
            ///    - @a index = %array.count() will insert an element at the end of the array (same as push_back())
            ///    @param key Key for the new element
            ///    @param value Value for the new element
            ///    @param index 0-based index at which to insert the new element )
            /// 
            /// </summary>
            public void insert(string arrayobject, string key, string value, int index)
                {
                m_ts.fnArrayObject_insert(arrayobject, key, value, index);
                }

            /// <summary>
            /// Moves array pointer to start of array
            ///    @return Returns the new array pointer )
            /// 
            /// </summary>
            public int moveFirst(string arrayobject)
                {
                return m_ts.fnArrayObject_moveFirst(arrayobject);
                }

            /// <summary>
            /// Moves array pointer to end of array
            ///    @return Returns the new array pointer )
            /// 
            /// </summary>
            public int moveLast(string arrayobject)
                {
                return m_ts.fnArrayObject_moveLast(arrayobject);
                }

            /// <summary>
            /// Moves array pointer to next position
            ///    @return Returns the new array pointer, or -1 if already at the end )
            /// 
            /// </summary>
            public int moveNext(string arrayobject)
                {
                return m_ts.fnArrayObject_moveNext(arrayobject);
                }

            /// <summary>
            /// Moves array pointer to prev position
            ///    @return Returns the new array pointer, or -1 if already at the start )
            /// 
            /// </summary>
            public int movePrev(string arrayobject)
                {
                return m_ts.fnArrayObject_movePrev(arrayobject);
                }

            /// <summary>
            /// Removes the last element from the array )
            /// 
            /// </summary>
            public void pop_back(string arrayobject)
                {
                m_ts.fnArrayObject_pop_back(arrayobject);
                }

            /// <summary>
            /// Removes the first element from the array )
            /// 
            /// </summary>
            public void pop_front(string arrayobject)
                {
                m_ts.fnArrayObject_pop_front(arrayobject);
                }

            /// <summary>
            ///  ),
            ///    Adds a new element to the end of an array.
            ///    @param key Key for the new element
            ///    @param value Value for the new element )
            /// 
            /// </summary>
            public void push_back(string arrayobject, string key, string value)
                {
                m_ts.fnArrayObject_push_back(arrayobject, key, value);
                }

            /// <summary>
            ///  ),
            ///    Adds a new element to the front of an array )
            /// 
            /// </summary>
            public void push_front(string arrayobject, string key, string value)
                {
                m_ts.fnArrayObject_push_front(arrayobject, key, value);
                }

            /// <summary>
            /// Sets the current pointer index.
            ///    @param index New 0-based pointer index )
            /// 
            /// </summary>
            public void setCurrent(string arrayobject, int index)
                {
                m_ts.fnArrayObject_setCurrent(arrayobject, index);
                }

            /// <summary>
            /// Set the key at the given index.
            ///    @param key New key value
            ///    @param index 0-based index of the array element to update )
            /// 
            /// </summary>
            public void setKey(string arrayobject, string key, int index)
                {
                m_ts.fnArrayObject_setKey(arrayobject, key, index);
                }

            /// <summary>
            /// Set the value at the given index.
            ///    @param value New array element value
            ///    @param index 0-based index of the array element to update )
            /// 
            /// </summary>
            public void setValue(string arrayobject, string value, int index)
                {
                m_ts.fnArrayObject_setValue(arrayobject, value, index);
                }

            /// <summary>
            /// Alpha sorts the array by value
            ///    @param ascending [optional] True for ascending sort, false for descending sort )
            /// 
            /// </summary>
            public void sort(string arrayobject, bool ascending)
                {
                m_ts.fnArrayObject_sort(arrayobject, ascending);
                }

            /// <summary>
            /// Alpha sorts the array by value in ascending order )
            /// 
            /// </summary>
            public void sorta(string arrayobject)
                {
                m_ts.fnArrayObject_sorta(arrayobject);
                }

            /// <summary>
            /// Alpha sorts the array by value in descending order )
            /// 
            /// </summary>
            public void sortd(string arrayobject)
                {
                m_ts.fnArrayObject_sortd(arrayobject);
                }

            /// <summary>
            /// Sorts the array by value in ascending order using the given callback function.
            ///    @param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.
            ///    @tsexample
            ///    function mySortCallback(%a, %b)
            ///    {
            ///       return strcmp( %a.name, %b.name );
            ///    }
            ///    %array.sortf( \"mySortCallback\" );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void sortf(string arrayobject, string functionName)
                {
                m_ts.fnArrayObject_sortf(arrayobject, functionName);
                }

            /// <summary>
            /// Sorts the array by value in descending order using the given callback function.
            ///    @param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.
            ///    @see sortf )
            /// 
            /// </summary>
            public void sortfd(string arrayobject, string functionName)
                {
                m_ts.fnArrayObject_sortfd(arrayobject, functionName);
                }

            /// <summary>
            /// Sorts the array by key in ascending order using the given callback function.
            ///    @param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.
            ///    @see sortf )
            /// 
            /// </summary>
            public void sortfk(string arrayobject, string functionName)
                {
                m_ts.fnArrayObject_sortfk(arrayobject, functionName);
                }

            /// <summary>
            /// Sorts the array by key in descending order using the given callback function.
            ///    @param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.
            ///    @see sortf )
            /// 
            /// </summary>
            public void sortfkd(string arrayobject, string functionName)
                {
                m_ts.fnArrayObject_sortfkd(arrayobject, functionName);
                }

            /// <summary>
            /// Alpha sorts the array by key
            ///    @param ascending [optional] True for ascending sort, false for descending sort )
            /// 
            /// </summary>
            public void sortk(string arrayobject, bool ascending)
                {
                m_ts.fnArrayObject_sortk(arrayobject, ascending);
                }

            /// <summary>
            /// Alpha sorts the array by key in ascending order )
            /// 
            /// </summary>
            public void sortka(string arrayobject)
                {
                m_ts.fnArrayObject_sortka(arrayobject);
                }

            /// <summary>
            /// Alpha sorts the array by key in descending order )
            /// 
            /// </summary>
            public void sortkd(string arrayobject)
                {
                m_ts.fnArrayObject_sortkd(arrayobject);
                }

            /// <summary>
            /// Numerically sorts the array by value
            ///    @param ascending [optional] True for ascending sort, false for descending sort )
            /// 
            /// </summary>
            public void sortn(string arrayobject, bool ascending)
                {
                m_ts.fnArrayObject_sortn(arrayobject, ascending);
                }

            /// <summary>
            /// Numerically sorts the array by value in ascending order ) 
            /// 
            /// </summary>
            public void sortna(string arrayobject)
                {
                m_ts.fnArrayObject_sortna(arrayobject);
                }

            /// <summary>
            /// Numerically sorts the array by value in descending order )
            /// 
            /// </summary>
            public void sortnd(string arrayobject)
                {
                m_ts.fnArrayObject_sortnd(arrayobject);
                }

            /// <summary>
            /// Numerically sorts the array by key
            ///    @param ascending [optional] True for ascending sort, false for descending sort )
            /// 
            /// </summary>
            public void sortnk(string arrayobject, bool ascending)
                {
                m_ts.fnArrayObject_sortnk(arrayobject, ascending);
                }

            /// <summary>
            /// Numerical sorts the array by key in ascending order )
            /// 
            /// </summary>
            public void sortnka(string arrayobject)
                {
                m_ts.fnArrayObject_sortnka(arrayobject);
                }

            /// <summary>
            /// Numerical sorts the array by key in descending order )
            /// 
            /// </summary>
            public void sortnkd(string arrayobject)
                {
                m_ts.fnArrayObject_sortnkd(arrayobject);
                }

            /// <summary>
            /// Removes any elements that have duplicated keys (leaving the first instance) )
            /// 
            /// </summary>
            public void uniqueKey(string arrayobject)
                {
                m_ts.fnArrayObject_uniqueKey(arrayobject);
                }

            /// <summary>
            /// Removes any elements that have duplicated values (leaving the first instance) )
            /// 
            /// </summary>
            public void uniqueValue(string arrayobject)
                {
                m_ts.fnArrayObject_uniqueValue(arrayobject);
                }
            }

        #endregion

        #region Nested type: CameraObject

        /// <summary>
        /// 
        /// </summary>
        public class CameraObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public CameraObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Move the camera to fully view the given radius.
            ///                    @note For this operation to take affect a valid edit orbit point must first be specified.  See Camera::setEditOrbitPoint().
            ///                    @param radius The radius to view.)
            /// 
            /// </summary>
            public void autoFitRadius(string camera, float radius)
                {
                m_ts.fnCamera_autoFitRadius(camera, radius);
                }

            /// <summary>
            /// Get the angular velocity for a Newton mode camera.
            ///                    @returns The angular velocity in the form of \"x y z\".
            ///                    @note Only returns useful results when Camera::newtonRotation is set to true.)
            /// 
            /// </summary>
            public Point3F getAngularVelocity(string camera)
                {
                return new Point3F(m_ts.fnCamera_getAngularVelocity(camera));
                }

            /// <summary>
            /// Returns the current camera control mode.
            ///                    @see CameraMotionMode)
            /// 
            /// </summary>
            public Camera__CameraMotionMode getMode(string camera)
                {
                return (Camera__CameraMotionMode) (m_ts.fnCamera_getMode(camera));
                }

            /// <summary>
            /// Get the camera's offset from its orbit or tracking point.
            ///                    The offset is added to the camera's position when set to CameraMode::OrbitObject.
            ///                    @returns The offset in the form of \"x y z\".)
            /// 
            /// </summary>
            public Point3F getOffset(string camera)
                {
                return new Point3F(m_ts.fnCamera_getOffset(camera));
                }

            /// <summary>
            /// Get the camera's position in the world.
            ///                    @returns The position in the form of \"x y z\".)
            /// 
            /// </summary>
            public Point3F getPosition(string camera)
                {
                return new Point3F(m_ts.fnCamera_getPosition(camera));
                }

            /// <summary>
            /// Get the camera's Euler rotation in radians.
            ///                    @returns The rotation in radians in the form of \"x y z\".)
            /// 
            /// </summary>
            public Point3F getRotation(string camera)
                {
                return new Point3F(m_ts.fnCamera_getRotation(camera));
                }

            /// <summary>
            /// Get the velocity for the camera.
            ///                    @returns The camera's velocity in the form of \"x y z\".
            ///                    @note Only useful when the Camera is in Newton mode.)
            /// 
            /// </summary>
            public Point3F getVelocity(string camera)
                {
                return new Point3F(m_ts.fnCamera_getVelocity(camera));
                }

            /// <summary>
            /// Is the camera in edit orbit mode?
            ///                    @returns true if the camera is in edit orbit mode.)
            /// 
            /// </summary>
            public bool isEditOrbitMode(string camera)
                {
                return m_ts.fnCamera_isEditOrbitMode(camera);
                }

            /// <summary>
            /// Is this a Newton Fly mode camera with damped rotation?
            ///                     @returns true if the camera uses a damped rotation.  i.e. Camera::newtonRotation is set to true.)
            /// 
            /// </summary>
            public bool isRotationDamped(string camera)
                {
                return m_ts.fnCamera_isRotationDamped(camera);
                }

            /// <summary>
            /// Point the camera at the specified position.  Does not work in Orbit or Track modes.
            ///                    @param point The position to point the camera at.)
            /// 
            /// </summary>
            public void lookAt(string camera, Point3F point)
                {
                m_ts.fnCamera_lookAt(camera, point.AsString());
                }

            /// <summary>
            /// Set the angular drag for a Newton mode camera.
            ///                    @param drag The angular drag applied while the camera is rotating.
            ///                    @note Only takes affect when Camera::newtonRotation is set to true.)
            /// 
            /// </summary>
            public void setAngularDrag(string camera, float drag)
                {
                m_ts.fnCamera_setAngularDrag(camera, drag);
                }

            /// <summary>
            /// Set the angular force for a Newton mode camera.
            ///                    @param force The angular force applied when attempting to rotate the camera.
            ///                    @note Only takes affect when Camera::newtonRotation is set to true.)
            /// 
            /// </summary>
            public void setAngularForce(string camera, float force)
                {
                m_ts.fnCamera_setAngularForce(camera, force);
                }

            /// <summary>
            /// Set the angular velocity for a Newton mode camera.
            ///                    @param velocity The angular velocity infor form of \"x y z\".
            ///                    @note Only takes affect when Camera::newtonRotation is set to true.)
            /// 
            /// </summary>
            public void setAngularVelocity(string camera, Point3F velocity)
                {
                m_ts.fnCamera_setAngularVelocity(camera, velocity.AsString());
                }

            /// <summary>
            /// Set the Newton mode camera brake multiplier when trigger[1] is active.
            ///                    @param multiplier The brake multiplier to apply.
            ///                    @note Only used when Camera is in Newton mode.)
            /// 
            /// </summary>
            public void setBrakeMultiplier(string camera, float multiplier)
                {
                m_ts.fnCamera_setBrakeMultiplier(camera, multiplier);
                }

            /// <summary>
            /// Set the drag for a Newton mode camera.
            ///                    @param drag The drag applied to the camera while moving.
            ///                    @note Only used when Camera is in Newton mode.)
            /// 
            /// </summary>
            public void setDrag(string camera, float drag)
                {
                m_ts.fnCamera_setDrag(camera, drag);
                }

            /// <summary>
            /// Set the editor camera to orbit around a point set with Camera::setEditOrbitPoint().
            ///                     @note This method is generally used only within the World Editor and other tools.  To 
            ///                     orbit about an object or point within a game, see Camera::setOrbitMode() and its helper methods.)
            /// 
            /// </summary>
            public void setEditOrbitMode(string camera)
                {
                m_ts.fnCamera_setEditOrbitMode(camera);
                }

            /// <summary>
            /// Set the editor camera's orbit point.
            ///                    @param point The point the camera will orbit in the form of \"x y z\".)
            /// 
            /// </summary>
            public void setEditOrbitPoint(string camera, Point3F point)
                {
                m_ts.fnCamera_setEditOrbitPoint(camera, point.AsString());
                }

            /// <summary>
            /// Set the force applied to a Newton mode camera while moving.
            ///                    @param force The force applied to the camera while attempting to move.
            ///                    @note Only used when Camera is in Newton mode.)
            /// 
            /// </summary>
            public void setFlyForce(string camera, float force)
                {
                m_ts.fnCamera_setFlyForce(camera, force);
                }

            /// <summary>
            /// Set the camera to fly freely.
            ///                    Allows the camera to have 6 degrees of freedom.  Provides for instantaneous motion 
            ///                    and rotation unless one of the Newton fields has been set to true.  See Camera::newtonMode 
            ///                    and Camera::newtonRotation.)
            /// 
            /// </summary>
            public void setFlyMode(string camera)
                {
                m_ts.fnCamera_setFlyMode(camera);
                }

            /// <summary>
            /// Set the mass for a Newton mode camera.
            ///                    @param mass The mass used during ease-in and ease-out calculations.
            ///                    @note Only used when Camera is in Newton mode.)
            /// 
            /// </summary>
            public void setMass(string camera, float mass)
                {
                m_ts.fnCamera_setMass(camera, mass);
                }

            /// <summary>
            /// Set the camera to fly freely, but with ease-in and ease-out.
            ///                     This method allows for the same 6 degrees of freedom as Camera::setFlyMode() but 
            ///                     activates the ease-in and ease-out on the camera's movement.  To also activate 
            ///                     Newton mode for the camera's rotation, set Camera::newtonRotation to true.)
            /// 
            /// </summary>
            public void setNewtonFlyMode(string camera)
                {
                m_ts.fnCamera_setNewtonFlyMode(camera);
                }

            /// <summary>
            /// Set the camera's offset.
            ///                    The offset is added to the camera's position when set to CameraMode::OrbitObject.
            ///                    @param offset The distance to offset the camera by in the form of \"x y z\".)
            /// 
            /// </summary>
            public void setOffset(string camera, Point3F offset)
                {
                m_ts.fnCamera_setOffset(camera, offset.AsString());
                }

            /// <summary>
            /// Set the camera to orbit around the given object, or if none is given, around the given point.
            ///                     @param orbitObject The object to orbit around.  If no object is given (0 or blank string is passed in) use the orbitPoint instead
            ///                     @param orbitPoint The point to orbit around when no object is given.  In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform().
            ///                     @param minDistance The minimum distance allowed to the orbit object or point.
            ///                     @param maxDistance The maximum distance allowed from the orbit object or point.
            ///                     @param initDistance The initial distance from the orbit object or point.
            ///                     @param ownClientObj [optional] Are we orbiting an object that is owned by us?  Default is false.
            ///                     @param offset [optional] An offset added to the camera's position.  Default is no offset.
            ///                     @param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
            ///                     @see Camera::setOrbitObject()
            ///                     @see Camera::setOrbitPoint())
            /// 
            /// </summary>
            public void setOrbitMode(string camera, string orbitObject, TransformF orbitPoint, float minDistance, float maxDistance, float initDistance, bool ownClientObj, Point3F offset, bool xlocked)
                {
                m_ts.fnCamera_setOrbitMode(camera, orbitObject, orbitPoint.AsString(), minDistance, maxDistance, initDistance, ownClientObj, offset.AsString(), xlocked);
                }

            /// <summary>
            /// Set the camera to orbit around a given object.
            ///                     @param orbitObject The object to orbit around.
            ///                     @param rotation The initial camera rotation about the object in radians in the form of \"x y z\".
            ///                     @param minDistance The minimum distance allowed to the orbit object or point.
            ///                     @param maxDistance The maximum distance allowed from the orbit object or point.
            ///                     @param initDistance The initial distance from the orbit object or point.
            ///                     @param ownClientObject [optional] Are we orbiting an object that is owned by us?  Default is false.
            ///                     @param offset [optional] An offset added to the camera's position.  Default is no offset.
            ///                     @param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
            ///                     @returns false if the given object could not be found.
            ///                     @see Camera::setOrbitMode())
            /// 
            /// </summary>
            public bool setOrbitObject(string camera, string orbitObject, Point3F rotation, float minDistance, float maxDistance, float initDistance, bool ownClientObject, Point3F offset, bool xlocked)
                {
                return m_ts.fnCamera_setOrbitObject(camera, orbitObject, rotation.AsString(), minDistance, maxDistance, initDistance, ownClientObject, offset.AsString(), xlocked);
                }

            /// <summary>
            /// Set the camera to orbit around a given point.
            ///                     @param orbitPoint The point to orbit around.  In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform().
            ///                     @param minDistance The minimum distance allowed to the orbit object or point.
            ///                     @param maxDistance The maximum distance allowed from the orbit object or point.
            ///                     @param initDistance The initial distance from the orbit object or point.
            ///                     @param offset [optional] An offset added to the camera's position.  Default is no offset.
            ///                     @param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
            ///                     @see Camera::setOrbitMode())
            /// 
            /// </summary>
            public void setOrbitPoint(string camera, TransformF orbitPoint, float minDistance, float maxDistance, float initDistance, Point3F offset, bool xlocked)
                {
                m_ts.fnCamera_setOrbitPoint(camera, orbitPoint.AsString(), minDistance, maxDistance, initDistance, offset.AsString(), xlocked);
                }

            /// <summary>
            /// Set the camera's Euler rotation in radians.
            ///                    @param rot The rotation in radians in the form of \"x y z\".
            ///                    @note Rotation around the Y axis is ignored )
            /// 
            /// </summary>
            public void setRotation(string camera, Point3F rot)
                {
                m_ts.fnCamera_setRotation(camera, rot.AsString());
                }

            /// <summary>
            /// Set the Newton mode camera speed multiplier when trigger[0] is active.
            ///                    @param multiplier The speed multiplier to apply.
            ///                    @note Only used when Camera is in Newton mode.)
            /// 
            /// </summary>
            public void setSpeedMultiplier(string camera, float multiplier)
                {
                m_ts.fnCamera_setSpeedMultiplier(camera, multiplier);
                }

            /// <summary>
            /// Set the camera to track a given object.
            ///                     @param trackObject The object to track.
            ///                     @param offset [optional] An offset added to the camera's position.  Default is no offset.
            ///                     @returns false if the given object could not be found.)
            /// 
            /// </summary>
            public bool setTrackObject(string camera, string trackObject, Point3F offset)
                {
                return m_ts.fnCamera_setTrackObject(camera, trackObject, offset.AsString());
                }

            /// <summary>
            /// Set if there is a valid editor camera orbit point.
            ///                    When validPoint is set to false the Camera operates as if it is 
            ///                    in Fly mode rather than an Orbit mode.
            ///                    @param validPoint Indicates the validity of the orbit point.
            ///                    @note Only used when Camera is in Edit Orbit Mode.)
            /// 
            /// </summary>
            public void setValidEditOrbitPoint(string camera, bool validPoint)
                {
                m_ts.fnCamera_setValidEditOrbitPoint(camera, validPoint);
                }

            /// <summary>
            /// Set the velocity for the camera.
            ///                    @param velocity The camera's velocity in the form of \"x y z\".
            ///                    @note Only affects the Camera when in Newton mode.)
            /// 
            /// </summary>
            public void setVelocity(string camera, Point3F velocity)
                {
                m_ts.fnCamera_setVelocity(camera, velocity.AsString());
                }
            }

        #endregion

        #region Nested type: CompoundUndoActionObject

        /// <summary>
        /// 
        /// </summary>
        public class CompoundUndoActionObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public CompoundUndoActionObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( CompoundUndoAction, addAction, void, 3, 3, addAction( UndoAction ) )
            /// 
            /// </summary>
            public void addAction(string compoundundoaction, string a2 = "")
                {
                m_ts.fnCompoundUndoAction_addAction(compoundundoaction, a2);
                }
            }

        #endregion

        #region Nested type: ConsoleLoggerObject

        /// <summary>
        /// 
        /// </summary>
        public class ConsoleLoggerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ConsoleLoggerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( ConsoleLogger, attach, bool, 2, 2, () Attaches the logger to the console and begins writing to file
            /// 			  @tsexample
            /// 			  // Create the logger
            /// 			  // Will automatically start writing to testLogging.txt with normal priority
            /// 			  new ConsoleLogger(logger, \"testLogging.txt\", false);
            /// 			  // Send something to the console, with the logger consumes and writes to file
            /// 			  echo(\"This is logged to the file\");
            /// 			  // Stop logging, but do not delete the logger
            /// 			  logger.detach();
            /// 			  echo(\"This is not logged to the file\");
            /// 			  // Attach the logger to the console again
            /// 			  logger.attach();
            /// 			  // Logging has resumed
            /// 			  echo(\"Logging has resumed\");
            /// 			  @endtsexample)
            /// 
            /// </summary>
            public bool attach(string consolelogger = "")
                {
                return m_ts.fnConsoleLogger_attach(consolelogger);
                }

            /// <summary>
            /// ( ConsoleLogger, detach, bool, 2, 2, () Detaches the logger from the console and stops writing to file
            /// 			  @tsexample
            /// 			  // Create the logger
            /// 			  // Will automatically start writing to testLogging.txt with normal priority
            /// 			  new ConsoleLogger(logger, \"testLogging.txt\", false);
            /// 			  // Send something to the console, with the logger consumes and writes to file
            /// 			  echo(\"This is logged to the file\");
            /// 			  // Stop logging, but do not delete the logger
            /// 			  logger.detach();
            /// 			  echo(\"This is not logged to the file\");
            /// 			  // Attach the logger to the console again
            /// 			  logger.attach();
            /// 			  // Logging has resumed
            /// 			  echo(\"Logging has resumed\");
            /// 			  @endtsexample)
            /// 
            /// </summary>
            public bool detach(string consolelogger = "")
                {
                return m_ts.fnConsoleLogger_detach(consolelogger);
                }
            }

        #endregion

        #region Nested type: CubemapDataObject

        /// <summary>
        /// 
        /// </summary>
        public class CubemapDataObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public CubemapDataObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Returns the script filename of where the CubemapData object was 
            ///    defined.  This is used by the material editor. )
            /// 
            /// </summary>
            public string getFilename(string cubemapdata)
                {
                return m_ts.fnCubemapData_getFilename(cubemapdata);
                }

            /// <summary>
            /// Update the assigned cubemaps faces. )
            /// 
            /// </summary>
            public void updateFaces(string cubemapdata)
                {
                m_ts.fnCubemapData_updateFaces(cubemapdata);
                }
            }

        #endregion

        #region Nested type: DbgFileViewObject

        /// <summary>
        /// 
        /// </summary>
        public class DbgFileViewObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public DbgFileViewObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (DbgFileView, clearBreakPositions, void, 2, 2, ()
            ///               Clear all break points in the current file.)
            /// 
            /// </summary>
            public void clearBreakPositions(string dbgfileview = "")
                {
                m_ts.fnDbgFileView_clearBreakPositions(dbgfileview);
                }

            /// <summary>
            /// (DbgFileView, findString, bool, 3, 3, (string findThis)
            ///               Find the specified string in the currently viewed file and 
            ///               scroll it into view.)
            /// 
            /// </summary>
            public bool findString(string dbgfileview, string a2 = "")
                {
                return m_ts.fnDbgFileView_findString(dbgfileview, a2);
                }

            /// <summary>
            /// (DbgFileView, getCurrentLine, const char *, 2, 2, ()
            ///               Get the currently executing file and line, if any.
            ///               @returns A string containing the file, a tab, and then the line number.
            ///                Use getField() with this.)
            /// 
            /// </summary>
            public string getCurrentLine(string dbgfileview = "")
                {
                return m_ts.fnDbgFileView_getCurrentLine(dbgfileview);
                }

            /// <summary>
            /// (DbgFileView, open, bool, 3, 3, (string filename)
            ///               Open a file for viewing.
            ///               @note This loads the file from the local system.)
            /// 
            /// </summary>
            public bool open(string dbgfileview, string a2 = "")
                {
                return m_ts.fnDbgFileView_open(dbgfileview, a2);
                }

            /// <summary>
            /// (DbgFileView, removeBreak, void, 3, 3, (int line)
            ///               Remove a breakpoint from the specified line.)
            /// 
            /// </summary>
            public void removeBreak(string dbgfileview, string a2 = "")
                {
                m_ts.fnDbgFileView_removeBreak(dbgfileview, a2);
                }

            /// <summary>
            /// (DbgFileView, setBreak, void, 3, 3, (int line)
            ///               Set a breakpoint at the specified line.)
            /// 
            /// </summary>
            public void setBreak(string dbgfileview, string a2 = "")
                {
                m_ts.fnDbgFileView_setBreak(dbgfileview, a2);
                }

            /// <summary>
            /// (DbgFileView, setBreakPosition, void, 3, 3, (int line)
            ///               Set a breakpoint at the specified line.)
            /// 
            /// </summary>
            public void setBreakPosition(string dbgfileview, string a2 = "")
                {
                m_ts.fnDbgFileView_setBreakPosition(dbgfileview, a2);
                }

            /// <summary>
            /// (DbgFileView, setCurrentLine, void, 4, 4, (int line, bool selected)
            ///               Set the current highlighted line.)
            /// 
            /// </summary>
            public void setCurrentLine(string dbgfileview, string a2, string a3 = "")
                {
                m_ts.fnDbgFileView_setCurrentLine(dbgfileview, a2, a3);
                }
            }

        #endregion

        #region Nested type: DebrisObject

        /// <summary>
        /// 
        /// </summary>
        public class DebrisObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public DebrisObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// 1.0 1.0 1.0, 1.0 0.0 0.0), 
            ///    @brief Manually set this piece of debris at the given position with the given velocity.
            /// 
            ///    Usually you do not manually create Debris objects as they are generated through other means, 
            ///    such as an Explosion.  This method exists when you do manually create a Debris object and 
            ///    want to have it start moving.
            /// 
            ///    @param inputPosition Position to place the debris.
            ///    @param inputVelocity Velocity to move the debris after it has been placed.
            ///    @return Always returns true.
            /// 
            ///    @tsexample
            ///       // Define the position
            ///       %position = \"1.0 1.0 1.0\";
            ///       // Define the velocity
            ///       %velocity = \"1.0 0.0 0.0\";
            ///       // Inform the debris object of its new position and velocity
            ///       %debris.init(%position,%velocity);
            ///    @endtsexample)
            /// 
            /// </summary>
            public bool init(string debris, string inputPosition, string inputVelocity)
                {
                return m_ts.fnDebris_init(debris, inputPosition, inputVelocity);
                }
            }

        #endregion

        #region Nested type: DebugDrawerObject

        /// <summary>
        /// 
        /// </summary>
        public class DebugDrawerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public DebugDrawerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Draws an axis aligned box primitive within the two 3d points. )
            /// 
            /// </summary>
            public void drawBox(string debugdrawer, Point3F a, Point3F b, ColorF color)
                {
                m_ts.fnDebugDrawer_drawBox(debugdrawer, a.AsString(), b.AsString(), color.AsString());
                }

            /// <summary>
            /// Draws a line primitive between two 3d points. )
            /// 
            /// </summary>
            public void drawLine(string debugdrawer, Point3F a, Point3F b, ColorF color)
                {
                m_ts.fnDebugDrawer_drawLine(debugdrawer, a.AsString(), b.AsString(), color.AsString());
                }

            /// <summary>
            /// Sets the \"time to live\" (TTL) for the last rendered primitive. )
            /// 
            /// </summary>
            public void setLastTTL(string debugdrawer, uint ms)
                {
                m_ts.fnDebugDrawer_setLastTTL(debugdrawer, ms);
                }

            /// <summary>
            /// Sets the z buffer reading state for the last rendered primitive. )
            /// 
            /// </summary>
            public void setLastZTest(string debugdrawer, bool enabled)
                {
                m_ts.fnDebugDrawer_setLastZTest(debugdrawer, enabled);
                }

            /// <summary>
            /// Toggles the rendering of DebugDrawer primitives. )
            /// 
            /// </summary>
            public void toggleDrawing(string debugdrawer)
                {
                m_ts.fnDebugDrawer_toggleDrawing(debugdrawer);
                }

            /// <summary>
            /// Toggles freeze mode which keeps the currently rendered primitives from expiring. )
            /// 
            /// </summary>
            public void toggleFreeze(string debugdrawer)
                {
                m_ts.fnDebugDrawer_toggleFreeze(debugdrawer);
                }
            }

        #endregion

        #region Nested type: DecalDataObject

        /// <summary>
        /// 
        /// </summary>
        public class DecalDataObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public DecalDataObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Recompute the imagemap sub-texture rectangles for this DecalData.
            ///    @tsexample
            ///    // Inform the decal object to reload its imagemap and frame data.
            ///    %decalData.texRows = 4;
            ///    %decalData.postApply();
            ///    @endtsexample)
            /// 
            /// </summary>
            public void postApply(string decaldata)
                {
                m_ts.fnDecalData_postApply(decaldata);
                }
            }

        #endregion

        #region Nested type: DecalRoadObject

        /// <summary>
        /// 
        /// </summary>
        public class DecalRoadObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public DecalRoadObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Force trigger an inspectPostApply. This will transmit 
            ///                    the material and other fields ( not including nodes ) 
            ///                    to client objects.
            ///                   )
            /// 
            /// </summary>
            public void postApply(string decalroad)
                {
                m_ts.fnDecalRoad_postApply(decalroad);
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Force DecalRoad to update it's spline and reclip geometry.
            ///                   )
            /// 
            /// </summary>
            public void regenerate(string decalroad)
                {
                m_ts.fnDecalRoad_regenerate(decalroad);
                }
            }

        #endregion

        #region Nested type: DynamicConsoleMethodComponentObject

        /// <summary>
        /// 
        /// </summary>
        public class DynamicConsoleMethodComponentObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public DynamicConsoleMethodComponentObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( DynamicConsoleMethodComponent, callMethod, void, 3, 64 , (methodName, argi) Calls script defined method
            /// 			  @param methodName The method's name as a string
            /// 			  @param argi Any arguments to pass to the method
            /// 			  @return No return value
            /// 			  @note %obj.callMethod( %methodName, %arg1, %arg2, ... );)
            /// 
            /// 
            /// </summary>
            public void callMethod(string dynamicconsolemethodcomponent, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "", string a20 = "", string a21 = "", string a22 = "", string a23 = "", string a24 = "", string a25 = "", string a26 = "", string a27 = "", string a28 = "", string a29 = "", string a30 = "", string a31 = "", string a32 = "", string a33 = "", string a34 = "", string a35 = "", string a36 = "", string a37 = "", string a38 = "", string a39 = "", string a40 = "", string a41 = "", string a42 = "", string a43 = "", string a44 = "", string a45 = "", string a46 = "", string a47 = "", string a48 = "", string a49 = "", string a50 = "", string a51 = "", string a52 = "", string a53 = "", string a54 = "", string a55 = "", string a56 = "", string a57 = "", string a58 = "", string a59 = "", string a60 = "", string a61 = "", string a62 = "", string a63 = "")
                {
                m_ts.fnDynamicConsoleMethodComponent_callMethod(dynamicconsolemethodcomponent, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63);
                }
            }

        #endregion

        #region Nested type: EditTSCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class EditTSCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public EditTSCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public int getDisplayType(string edittsctrl)
                {
                return m_ts.fnEditTSCtrl_getDisplayType(edittsctrl);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public int getGizmo(string edittsctrl)
                {
                return m_ts.fnEditTSCtrl_getGizmo(edittsctrl);
                }

            /// <summary>
            /// Return the FOV for orthographic views. )
            /// 
            /// </summary>
            public float getOrthoFOV(string edittsctrl)
                {
                return m_ts.fnEditTSCtrl_getOrthoFOV(edittsctrl);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public bool isMiddleMouseDown(string edittsctrl)
                {
                return m_ts.fnEditTSCtrl_isMiddleMouseDown(edittsctrl);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void renderBox(string edittsctrl, Point3F pos, Point3F size)
                {
                m_ts.fnEditTSCtrl_renderBox(edittsctrl, pos.AsString(), size.AsString());
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void renderCircle(string edittsctrl, Point3F pos, Point3F normal, float radius, int segments)
                {
                m_ts.fnEditTSCtrl_renderCircle(edittsctrl, pos.AsString(), normal.AsString(), radius, segments);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void renderLine(string edittsctrl, Point3F start, Point3F end, float lineWidth)
                {
                m_ts.fnEditTSCtrl_renderLine(edittsctrl, start.AsString(), end.AsString(), lineWidth);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void renderSphere(string edittsctrl, Point3F pos, float radius, int sphereLevel)
                {
                m_ts.fnEditTSCtrl_renderSphere(edittsctrl, pos.AsString(), radius, sphereLevel);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void renderTriangle(string edittsctrl, Point3F a, Point3F b, Point3F c)
                {
                m_ts.fnEditTSCtrl_renderTriangle(edittsctrl, a.AsString(), b.AsString(), c.AsString());
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void setDisplayType(string edittsctrl, int displayType)
                {
                m_ts.fnEditTSCtrl_setDisplayType(edittsctrl, displayType);
                }

            /// <summary>
            /// Set the FOV for to use for orthographic views. )
            /// 
            /// </summary>
            public void setOrthoFOV(string edittsctrl, float fov)
                {
                m_ts.fnEditTSCtrl_setOrthoFOV(edittsctrl, fov);
                }
            }

        #endregion

        #region Nested type: EventManagerObject

        /// <summary>
        /// 
        /// </summary>
        public class EventManagerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public EventManagerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( EventManager, dumpEvents, void, 2, 2, ()
            ///               Print all registered events to the console. )
            /// 
            /// </summary>
            public void dumpEvents(string eventmanager = "")
                {
                m_ts.fnEventManager_dumpEvents(eventmanager);
                }

            /// <summary>
            /// ( EventManager, dumpSubscribers, void, 2, 3, ( String event )
            ///               Print all subscribers to an event to the console.
            ///               @param event The event whose subscribers are to be printed. If this parameter isn't specified, all events will be dumped. )
            /// 
            /// </summary>
            public void dumpSubscribers(string eventmanager = "", string a2 = "")
                {
                m_ts.fnEventManager_dumpSubscribers(eventmanager, a2);
                }

            /// <summary>
            /// ( EventManager, isRegisteredEvent, bool, 3, 3, ( String event )
            ///               Check if an event is registered or not.
            ///               @param event The event to check.
            ///               @return Whether or not the event exists. )
            /// 
            /// </summary>
            public bool isRegisteredEvent(string eventmanager, string a2 = "")
                {
                return m_ts.fnEventManager_isRegisteredEvent(eventmanager, a2);
                }

            /// <summary>
            /// ( EventManager, postEvent, bool, 3, 4, ( String event, String data )
            ///               ~Trigger an event.
            ///               @param event The event to trigger.
            ///               @param data The data associated with the event.
            ///               @return Whether or not the event was dispatched successfully. )
            /// 
            /// </summary>
            public bool postEvent(string eventmanager, string a2 = "", string a3 = "")
                {
                return m_ts.fnEventManager_postEvent(eventmanager, a2, a3);
                }

            /// <summary>
            /// ( EventManager, registerEvent, bool, 3, 3, ( String event )
            ///               Register an event with the event manager.
            ///               @param event The event to register.
            ///               @return Whether or not the event was registered successfully. )
            /// 
            /// </summary>
            public bool registerEvent(string eventmanager, string a2 = "")
                {
                return m_ts.fnEventManager_registerEvent(eventmanager, a2);
                }

            /// <summary>
            /// ( EventManager, remove, void, 4, 4, ( SimObject listener, String event )
            ///               Remove a listener from an event.
            ///               @param listener The listener to remove.
            ///               @param event The event to be removed from.)
            /// 
            /// </summary>
            public void remove(string eventmanager, string a2, string a3 = "")
                {
                m_ts.fnEventManager_remove(eventmanager, a2, a3);
                }

            /// <summary>
            /// ( EventManager, removeAll, void, 3, 3, ( SimObject listener )
            ///               Remove a listener from all events.
            ///               @param listener The listener to remove.)
            /// 
            /// </summary>
            public void removeAll(string eventmanager, string a2 = "")
                {
                m_ts.fnEventManager_removeAll(eventmanager, a2);
                }

            /// <summary>
            /// ( EventManager, subscribe, bool, 4, 5, ( SimObject listener, String event, String callback )
            ///               Subscribe a listener to an event.
            ///               @param listener The listener to subscribe.
            ///               @param event The event to subscribe to.
            ///               @param callback Optional method name to receive the event notification. If this is not specified, \"on[event]\" will be used.
            ///               @return Whether or not the subscription was successful. )
            /// 
            /// </summary>
            public bool subscribe(string eventmanager, string a2, string a3 = "", string a4 = "")
                {
                return m_ts.fnEventManager_subscribe(eventmanager, a2, a3, a4);
                }

            /// <summary>
            /// ( EventManager, unregisterEvent, void, 3, 3, ( String event )
            ///               Remove an event from the EventManager.
            ///               @param event The event to remove. )
            /// 
            /// </summary>
            public void unregisterEvent(string eventmanager, string a2 = "")
                {
                m_ts.fnEventManager_unregisterEvent(eventmanager, a2);
                }
            }

        #endregion

        #region Nested type: FieldBrushObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class FieldBrushObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public FieldBrushObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (FieldBrushObject, copyFields, void, 3, 4, (simObject, [fieldList]) Copy selected static-fields for selected object./
            ///                                                         @param simObject Object to copy static-fields from.
            ///                                                         @param fieldList fields to filter static-fields against.
            /// 			                                            @return No return value.)
            /// 
            /// </summary>
            public void copyFields(string fieldbrushobject, string a2 = "", string a3 = "")
                {
                m_ts.fnFieldBrushObject_copyFields(fieldbrushobject, a2, a3);
                }

            /// <summary>
            /// (FieldBrushObject, pasteFields, void, 3, 3, (simObject) Paste copied static-fields to selected object./
            ///                                                         @param simObject Object to paste static-fields to.
            /// 			                                            @return No return value.)
            /// 
            /// </summary>
            public void pasteFields(string fieldbrushobject, string a2 = "")
                {
                m_ts.fnFieldBrushObject_pasteFields(fieldbrushobject, a2);
                }

            /// <summary>
            /// (FieldBrushObject, queryFields, const char*, 3, 4, (simObject, [groupList]) Query available static-fields for selected object./
            ///                                                                 @param simObject Object to query static-fields on.
            ///                                                                 @param groupList groups to filter static-fields against.
            /// 			                                                    @return Space-seperated static-field list.)
            /// 
            /// </summary>
            public string queryFields(string fieldbrushobject, string a2 = "", string a3 = "")
                {
                return m_ts.fnFieldBrushObject_queryFields(fieldbrushobject, a2, a3);
                }

            /// <summary>
            /// (FieldBrushObject, queryGroups, const char*, 3, 3, (simObject) Query available static-field groups for selected object./
            ///                                                                 @param simObject Object to query static-field groups on.
            /// 			                                                    @return Space-seperated static-field group list.)
            /// 
            /// </summary>
            public string queryGroups(string fieldbrushobject, string a2 = "")
                {
                return m_ts.fnFieldBrushObject_queryGroups(fieldbrushobject, a2);
                }
            }

        #endregion

        #region Nested type: FileDialogObject

        /// <summary>
        /// 
        /// </summary>
        public class FileDialogObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public FileDialogObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Launches the OS file browser
            /// 
            ///    After an Execute() call, the chosen file name and path is available in one of two areas.  
            ///    If only a single file selection is permitted, the results will be stored in the @a fileName 
            ///    attribute.
            /// 
            ///    If multiple file selection is permitted, the results will be stored in the 
            ///    @a files array.  The total number of files in the array will be stored in the 
            ///    @a fileCount attribute.
            /// 
            ///    @tsexample
            ///    // NOTE: This is not he preferred class to use, but this still works
            ///    // Create the file dialog
            ///    %baseFileDialog = new FileDialog()
            ///    {
            ///       // Allow browsing of all file types
            ///       filters = \"*.*\";
            ///       // No default file
            ///       defaultFile = ;
            ///       // Set default path relative to project
            ///       defaultPath = \"./\";
            ///       // Set the title
            ///       title = \"Durpa\";
            ///       // Allow changing of path you are browsing
            ///       changePath = true;
            ///    };
            ///     // Launch the file dialog
            ///     %baseFileDialog.Execute();
            ///     
            ///     // Don't forget to cleanup
            ///     %baseFileDialog.delete();
            /// 
            ///     // A better alternative is to use the 
            ///     // derived classes which are specific to file open and save
            ///     // Create a dialog dedicated to opening files
            ///     %openFileDlg = new OpenFileDialog()
            ///     {
            ///        // Look for jpg image files
            ///        // First part is the descriptor|second part is the extension
            ///        Filters = \"Jepg Files|*.jpg\";
            ///        // Allow browsing through other folders
            ///        ChangePath = true;
            ///        // Only allow opening of one file at a time
            ///        MultipleFiles = false;
            ///     };
            ///     // Launch the open file dialog
            ///     %result = %openFileDlg.Execute();
            ///     // Obtain the chosen file name and path
            ///     if ( %result )
            ///     {
            ///        %seletedFile = %openFileDlg.file;
            ///     }
            ///     else
            ///     {
            ///        %selectedFile = \"\";
            ///     }
            ///     // Cleanup
            ///     %openFileDlg.delete();
            /// 
            ///     // Create a dialog dedicated to saving a file
            ///     %saveFileDlg = new SaveFileDialog()
            ///     {
            ///        // Only allow for saving of COLLADA files
            ///        Filters = \"COLLADA Files (*.dae)|*.dae|\";
            ///        // Default save path to where the WorldEditor last saved
            ///        DefaultPath = $pref::WorldEditor::LastPath;
            ///        // No default file specified
            ///        DefaultFile = \"\";
            ///        // Do not allow the user to change to a new directory
            ///        ChangePath = false;
            ///        // Prompt the user if they are going to overwrite an existing file
            ///        OverwritePrompt = true;
            ///     };
            ///     // Launch the save file dialog
            ///     %result = %saveFileDlg.Execute();
            ///     // Obtain the file name
            ///     %selectedFile = \"\";
            ///     if ( %result )
            ///        %selectedFile = %saveFileDlg.file;
            ///     // Cleanup
            ///     %saveFileDlg.delete();
            ///    @endtsexample
            /// 
            ///    @return True if the file was selected was successfully found (opened) or declared (saved).)
            /// 
            /// </summary>
            public bool Execute(string filedialog)
                {
                return m_ts.fnFileDialog_Execute(filedialog);
                }
            }

        #endregion

        #region Nested type: FileObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class FileObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public FileObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Close the file.
            ///    
            ///    It is EXTREMELY important that you call this function when you are finished reading or writing to a file. 
            ///    Failing to do so is not only a bad programming practice, but could result in bad data or corrupt files. 
            ///    Remember: Open, Read/Write, Close, Delete...in that order!
            ///    
            ///    @tsexample
            ///    // Create a file object for reading
            ///    %fileRead = new FileObject();
            ///    // Open a text file, if it exists
            ///    %fileRead.OpenForRead(\"./test.txt\");
            ///    // Peek the first line
            ///    %line = %fileRead.peekLine();
            ///    // Print the line we just peeked
            ///    echo(%line);
            ///    // If we peek again...
            ///    %line = %fileRead.peekLine();
            ///    // We will get the same output as the first time
            ///    // since the stream did not move forward
            ///    echo(%line);
            ///    // Close the file when finished
            ///    %fileWrite.close();
            ///    // Cleanup the file object
            ///    %fileWrite.delete();
            ///    @endtsexample)
            /// 
            /// </summary>
            public void close(string fileobject)
                {
                m_ts.fnFileObject_close(fileobject);
                }

            /// <summary>
            /// @brief Determines if the parser for this FileObject has reached the end of the file
            ///    
            ///    @tsexample
            ///    // Create a file object for reading
            ///    %fileRead = new FileObject();
            ///    // Open a text file, if it exists
            ///    %fileRead.OpenForRead(\"./test.txt\");
            ///    // Keep reading until we reach the end of the file
            ///    while( !%fileRead.isEOF() )
            ///    {
            ///       %line = %fileRead.readline();
            ///       echo(%line);
            ///    }
            ///    // Made it to the end
            ///    echo(\"Finished reading file\");
            ///    @endtsexample
            /// 
            ///    @return True if the parser has reached the end of the file, false otherwise)
            /// 
            /// </summary>
            public bool isEOF(string fileobject)
                {
                return m_ts.fnFileObject_isEOF(fileobject);
                }

            /// <summary>
            /// @brief Open a specified file for writing, adding data to the end of the file
            ///    
            ///    There is no limit as to what kind of file you can write. Any format and data is allowable, not just text. Unlike openForWrite(), 
            ///    which will erase an existing file if it is opened, openForAppend() preserves data in an existing file and adds to it.
            /// 
            ///    @param filename Path, name, and extension of file to append to
            ///    
            ///    @tsexample
            ///    // Create a file object for writing
            ///    %fileWrite = new FileObject();
            ///    // Open a file to write to, if it does not exist it will be created
            ///    // If it does exist, whatever we write will be added to the end
            ///    %result = %fileWrite.OpenForAppend(\"./test.txt\");
            ///    @endtsexample
            /// 
            ///    @return True if file was successfully opened, false otherwise)
            /// 
            /// </summary>
            public bool openForAppend(string fileobject, string filename)
                {
                return m_ts.fnFileObject_openForAppend(fileobject, filename);
                }

            /// <summary>
            /// @brief Open a specified file for reading
            ///    
            ///    There is no limit as to what kind of file you can read. Any format and data contained within is accessible, not just text
            /// 
            ///    @param filename Path, name, and extension of file to be read
            ///    
            ///    @tsexample
            ///    // Create a file object for reading
            ///    %fileRead = new FileObject();
            ///    // Open a text file, if it exists
            ///    %result = %fileRead.OpenForRead(\"./test.txt\");
            ///    @endtsexample
            /// 
            ///    @return True if file was successfully opened, false otherwise)
            /// 
            /// </summary>
            public bool openForRead(string fileobject, string filename)
                {
                return m_ts.fnFileObject_openForRead(fileobject, filename);
                }

            /// <summary>
            /// @brief Open a specified file for writing
            ///    
            ///    There is no limit as to what kind of file you can write. Any format and data is allowable, not just text
            /// 
            ///    @param filename Path, name, and extension of file to write to
            ///    
            ///    @tsexample
            ///    // Create a file object for writing
            ///    %fileWrite = new FileObject();
            ///    // Open a file to write to, if it does not exist it will be created
            ///    %result = %fileWrite.OpenForWrite(\"./test.txt\");
            ///    @endtsexample
            /// 
            ///    @return True if file was successfully opened, false otherwise)
            /// 
            /// </summary>
            public bool openForWrite(string fileobject, string filename)
                {
                return m_ts.fnFileObject_openForWrite(fileobject, filename);
                }

            /// <summary>
            /// @brief Read a line from the file without moving the stream position.
            ///    
            ///    Emphasis on *line*, as in you cannot parse individual characters or chunks of data.  
            ///    There is no limitation as to what kind of data you can read. Unlike readLine, the parser does not move forward after reading.
            /// 
            ///    @param filename Path, name, and extension of file to be read
            ///    
            ///    @tsexample
            ///    // Create a file object for reading
            ///    %fileRead = new FileObject();
            ///    // Open a text file, if it exists
            ///    %fileRead.OpenForRead(\"./test.txt\");
            ///    // Peek the first line
            ///    %line = %fileRead.peekLine();
            ///    // Print the line we just peeked
            ///    echo(%line);
            ///    // If we peek again...
            ///    %line = %fileRead.peekLine();
            ///    // We will get the same output as the first time
            ///    // since the stream did not move forward
            ///    echo(%line);
            ///    @endtsexample
            /// 
            ///    @return String containing the line of data that was just peeked)
            /// 
            /// </summary>
            public string peekLine(string fileobject)
                {
                return m_ts.fnFileObject_peekLine(fileobject);
                }

            /// <summary>
            /// @brief Read a line from file.
            ///    
            ///    Emphasis on *line*, as in you cannot parse individual characters or chunks of data.  
            ///    There is no limitation as to what kind of data you can read.
            ///    
            ///    @tsexample
            ///    // Create a file object for reading
            ///    %fileRead = new FileObject();
            ///    // Open a text file, if it exists
            ///    %fileRead.OpenForRead(\"./test.txt\");
            ///    // Read in the first line
            ///    %line = %fileRead.readline();
            ///    // Print the line we just read
            ///    echo(%line);
            ///    @endtsexample
            /// 
            ///    @return String containing the line of data that was just read)
            /// 
            /// </summary>
            public string readLine(string fileobject)
                {
                return m_ts.fnFileObject_readLine(fileobject);
                }

            /// <summary>
            /// @brief Write a line to the file, if it was opened for writing.
            ///    
            ///    There is no limit as to what kind of text you can write. Any format and data is allowable, not just text. 
            ///    Be careful of what you write, as whitespace, current values, and literals will be preserved.
            /// 
            ///    @param text The data we are writing out to file.
            ///    
            ///    @tsexample
            ///    // Create a file object for writing
            ///    %fileWrite = new FileObject();
            ///    // Open a file to write to, if it does not exist it will be created
            ///    %fileWrite.OpenForWrite(\"./test.txt\");
            ///    // Write a line to the text files
            ///    %fileWrite.writeLine(\"READ. READ CODE. CODE\");
            ///    @endtsexample
            /// 
            ///    @return True if file was successfully opened, false otherwise)
            /// 
            /// </summary>
            public void writeLine(string fileobject, string text)
                {
                m_ts.fnFileObject_writeLine(fileobject, text);
                }

            /// <summary>
            /// ( FileObject, writeObject, void, 3, 4, FileObject.writeObject(SimObject, object prepend) 
            /// 			  @hide)
            /// 
            /// </summary>
            public void writeObject(string fileobject, string a2 = "", string a3 = "")
                {
                m_ts.fnFileObject_writeObject(fileobject, a2, a3);
                }
            }

        #endregion

        #region Nested type: FileStreamObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class FileStreamObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public FileStreamObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Close the file. You can no longer read or write to it unless you open it again.
            ///    
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    %fsObject = new FileStreamObject();
            ///    // Open a file for reading
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            ///    
            ///    @see open())
            /// 
            /// </summary>
            public void close(string filestreamobject)
                {
                m_ts.fnFileStreamObject_close(filestreamobject);
                }

            /// <summary>
            /// @brief Open a file for reading, writing, reading and writing, or appending
            ///    
            ///    Using \"Read\" for the open mode allows you to parse the contents of file, but not making modifications. \"Write\" will create a new 
            ///    file if it does not exist, or erase the contents of an existing file when opened. Write also allows you to modify the contents of the file.
            /// 
            ///    \"ReadWrite\" will provide the ability to parse data (read it in) and manipulate data (write it out) interchangeably. Keep in mind the stream can 
            ///    move during each operation. Finally, \"WriteAppend\" will open a file if it exists, but will not clear the contents. You can write new data starting 
            ///     at the end of the files existing contents.
            /// 
            ///    @param filename Name of file to open
            ///    @param openMode One of \"Read\", \"Write\", \"ReadWrite\" or \"WriteAppend\"
            /// 
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    %fsObject = new FileStreamObject();
            ///    // Open a file for reading
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Get the status and print it
            ///    %status = %fsObject.getStatus();
            ///    echo(%status);
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            /// 
            ///    @return True if the file was successfully opened, false if something went wrong
            ///    
            ///    @see close())
            /// 
            /// </summary>
            public bool open(string filestreamobject, string filename, string openMode)
                {
                return m_ts.fnFileStreamObject_open(filestreamobject, filename, openMode);
                }
            }

        #endregion

        #region Nested type: FlyingVehicleObject

        /// <summary>
        /// 
        /// </summary>
        public class FlyingVehicleObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public FlyingVehicleObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Set whether the vehicle should temporarily use the createHoverHeight 
            ///    specified in the datablock.This can help avoid problems with spawning.
            ///    @param enabled true to use the datablock createHoverHeight, false otherwise )
            /// 
            /// </summary>
            public void useCreateHeight(string flyingvehicle, bool enabled)
                {
                m_ts.fnFlyingVehicle_useCreateHeight(flyingvehicle, enabled);
                }
            }

        #endregion

        #region Nested type: ForestBrushObject

        /// <summary>
        /// 
        /// </summary>
        public class ForestBrushObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ForestBrushObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( ForestBrush, containsItemData, bool, 3, 3, ( ForestItemData obj ) )
            /// 
            /// </summary>
            public bool containsItemData(string forestbrush, string a2 = "")
                {
                return m_ts.fnForestBrush_containsItemData(forestbrush, a2);
                }
            }

        #endregion

        #region Nested type: ForestBrushToolObject

        /// <summary>
        /// 
        /// </summary>
        public class ForestBrushToolObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ForestBrushToolObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( ForestBrushTool, collectElements, void, 2, 2,  )
            /// 
            /// </summary>
            public void collectElements(string forestbrushtool = "")
                {
                m_ts.fnForestBrushTool_collectElements(forestbrushtool);
                }
            }

        #endregion

        #region Nested type: ForestEditorCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class ForestEditorCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ForestEditorCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( ForestEditorCtrl, deleteMeshSafe, void, 3, 3, ( ForestItemData obj ) )
            /// 
            /// </summary>
            public void deleteMeshSafe(string foresteditorctrl, string a2 = "")
                {
                m_ts.fnForestEditorCtrl_deleteMeshSafe(foresteditorctrl, a2);
                }

            /// <summary>
            /// ( ForestEditorCtrl, getActiveTool, S32, 2, 2, () )
            /// 
            /// </summary>
            public int getActiveTool(string foresteditorctrl = "")
                {
                return m_ts.fnForestEditorCtrl_getActiveTool(foresteditorctrl);
                }

            /// <summary>
            /// ( ForestEditorCtrl, isDirty, bool, 2, 2,  )
            /// 
            /// </summary>
            public bool isDirty(string foresteditorctrl = "")
                {
                return m_ts.fnForestEditorCtrl_isDirty(foresteditorctrl);
                }

            /// <summary>
            /// ( ForestEditorCtrl, setActiveTool, void, 3, 3, ( ForestTool tool ) )
            /// 
            /// </summary>
            public void setActiveTool(string foresteditorctrl, string a2 = "")
                {
                m_ts.fnForestEditorCtrl_setActiveTool(foresteditorctrl, a2);
                }

            /// <summary>
            /// ( ForestEditorCtrl, updateActiveForest, void, 2, 2, () )
            /// 
            /// </summary>
            public void updateActiveForest(string foresteditorctrl = "")
                {
                m_ts.fnForestEditorCtrl_updateActiveForest(foresteditorctrl);
                }
            }

        #endregion

        #region Nested type: ForestObject

        /// <summary>
        /// 
        /// </summary>
        public class ForestObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ForestObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (Forest, clear, void, 2, 2, () )
            /// 
            /// </summary>
            public void clear(string forest = "")
                {
                m_ts.fnForest_clear(forest);
                }

            /// <summary>
            /// (Forest, isDirty, bool, 2, 2, ())
            /// 
            /// </summary>
            public bool isDirty(string forest = "")
                {
                return m_ts.fnForest_isDirty(forest);
                }

            /// <summary>
            /// (Forest, regenCells, void, 2, 2, ())
            /// 
            /// </summary>
            public void regenCells(string forest = "")
                {
                m_ts.fnForest_regenCells(forest);
                }

            /// <summary>
            /// ( Forest, saveDataFile, bool, 2, 3, saveDataFile( [path] ) )
            /// 
            /// </summary>
            public bool saveDataFile(string forest = "", string a2 = "")
                {
                return m_ts.fnForest_saveDataFile(forest, a2);
                }
            }

        #endregion

        #region Nested type: ForestSelectionToolObject

        /// <summary>
        /// 
        /// </summary>
        public class ForestSelectionToolObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ForestSelectionToolObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( ForestSelectionTool, clearSelection, void, 2, 2,  )
            /// 
            /// </summary>
            public void clearSelection(string forestselectiontool = "")
                {
                m_ts.fnForestSelectionTool_clearSelection(forestselectiontool);
                }

            /// <summary>
            /// ( ForestSelectionTool, copySelection, void, 2, 2,  )
            /// 
            /// </summary>
            public void copySelection(string forestselectiontool = "")
                {
                m_ts.fnForestSelectionTool_copySelection(forestselectiontool);
                }

            /// <summary>
            /// ( ForestSelectionTool, cutSelection, void, 2, 2,  )
            /// 
            /// </summary>
            public void cutSelection(string forestselectiontool = "")
                {
                m_ts.fnForestSelectionTool_cutSelection(forestselectiontool);
                }

            /// <summary>
            /// ( ForestSelectionTool, deleteSelection, void, 2, 2,  )
            /// 
            /// </summary>
            public void deleteSelection(string forestselectiontool = "")
                {
                m_ts.fnForestSelectionTool_deleteSelection(forestselectiontool);
                }

            /// <summary>
            /// ( ForestSelectionTool, getSelectionCount, S32, 2, 2,  )
            /// 
            /// </summary>
            public int getSelectionCount(string forestselectiontool = "")
                {
                return m_ts.fnForestSelectionTool_getSelectionCount(forestselectiontool);
                }

            /// <summary>
            /// ( ForestSelectionTool, pasteSelection, void, 2, 2,  )
            /// 
            /// </summary>
            public void pasteSelection(string forestselectiontool = "")
                {
                m_ts.fnForestSelectionTool_pasteSelection(forestselectiontool);
                }
            }

        #endregion

        #region Nested type: ForestWindEmitterObject

        /// <summary>
        /// 
        /// </summary>
        public class ForestWindEmitterObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ForestWindEmitterObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Mounts the wind emitter to another scene object
            /// 
            ///    @param objectID Unique ID of the object wind emitter should attach to
            ///    
            ///    @tsexample
            ///    // Wind emitter previously created and named %windEmitter
            ///    // Going to attach it to the player, making him a walking wind storm
            ///    %windEmitter.attachToObject(%player);
            ///    @endtsexample)
            /// 
            /// </summary>
            public void attachToObject(string forestwindemitter, uint objectID)
                {
                m_ts.fnForestWindEmitter_attachToObject(forestwindemitter, objectID);
                }
            }

        #endregion

        #region Nested type: GameBaseObject

        /// <summary>
        /// 
        /// </summary>
        public class GameBaseObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GameBaseObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Apply an impulse to this object as defined by a world position and velocity vector.
            /// 
            ///    @param pos impulse world position
            ///    @param vel impulse velocity (impulse force F = m * v)
            ///    @return Always true
            /// 
            ///    @note Not all objects that derrive from GameBase have this defined.)
            /// 
            /// </summary>
            public bool applyImpulse(string gamebase, Point3F pos, Point3F vel)
                {
                return m_ts.fnGameBase_applyImpulse(gamebase, pos.AsString(), vel.AsString());
                }

            /// <summary>
            /// @brief Applies a radial impulse to the object using the given origin and force.
            /// 
            ///    @param origin World point of origin of the radial impulse.
            ///    @param radius The radius of the impulse area.
            ///    @param magnitude The strength of the impulse.
            ///    
            ///    @note Not all objects that derrive from GameBase have this defined.)
            /// 
            /// </summary>
            public void applyRadialImpulse(string gamebase, Point3F origin, float radius, float magnitude)
                {
                m_ts.fnGameBase_applyRadialImpulse(gamebase, origin.AsString(), radius, magnitude);
                }

            /// <summary>
            /// @brief Get the datablock used by this object.
            ///    @return the datablock this GameBase is using.
            ///    @see setDataBlock())
            /// 
            /// </summary>
            public int getDataBlock(string gamebase)
                {
                return m_ts.fnGameBase_getDataBlock(gamebase);
                }

            /// <summary>
            /// @brief Assign this GameBase to use the specified datablock.
            ///    @param data new datablock to use
            ///    @return true if successful, false if failed.
            ///    @see getDataBlock())
            /// 
            /// </summary>
            public bool setDataBlock(string gamebase, string data)
                {
                return m_ts.fnGameBase_setDataBlock(gamebase, data);
                }
            }

        #endregion

        #region Nested type: GameConnectionObject

        /// <summary>
        /// 
        /// </summary>
        public class GameConnectionObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GameConnectionObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Called by the server during phase 2 of the mission download to start sending ghosts to the client.
            ///    
            ///    Ghosts represent objects on the server that are in scope for the client.  These need 
            ///    to be synchronized with the client in order for the client to see and interact with them.  
            ///    This is typically done during the standard mission start phase 2 when following Torque's 
            ///    example mission startup sequence.
            /// 
            ///    @tsexample
            ///    function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
            ///    {
            ///       // Make sure to ignore calls from a previous mission load
            ///       if (%seq != $missionSequence || !$MissionRunning)
            ///          return;
            ///       if (%client.currentPhase != 1.5)
            ///          return;
            ///       %client.currentPhase = 2;
            ///    
            ///       // Set the player datablock choice
            ///       %client.playerDB = %playerDB;
            ///    
            ///       // Update mod paths, this needs to get there before the objects.
            ///       %client.transmitPaths();
            ///    
            ///       // Start ghosting objects to the client
            ///       %client.activateGhosting();
            ///    }
            ///    @endtsexample
            /// 
            ///    @see @ref ghosting_scoping for a description of the ghosting system.)
            /// 
            /// </summary>
            public void activateGhosting(string gameconnection)
                {
                m_ts.fnGameConnection_activateGhosting(gameconnection);
                }

            /// <summary>
            /// @brief Sets the size of the chase camera's matrix queue.
            ///    @note This sets the queue size across all GameConnections.
            ///    @note This is not currently hooked up.)
            /// 
            /// </summary>
            public bool chaseCam(string gameconnection, int size)
                {
                return m_ts.fnGameConnection_chaseCam(gameconnection, size);
                }

            /// <summary>
            /// @brief Clear the connection's camera object reference.
            ///    
            ///    @see GameConnection::setCameraObject() and GameConnection::getCameraObject())
            /// 
            /// </summary>
            public void clearCameraObject(string gameconnection)
                {
                m_ts.fnGameConnection_clearCameraObject(gameconnection);
                }

            /// <summary>
            /// ),
            ///    @brief On the server, disconnect a client and pass along an optional reason why.
            /// 
            ///    This method performs two operations: it disconnects a client connection from the server, 
            ///    and it deletes the connection object.  The optional reason is sent in the disconnect packet 
            ///    and is often displayed to the user so they know why they've been disconnected.
            ///    
            ///    @param reason [optional] The reason why the user has been disconnected from the server.
            ///    
            ///    @tsexample
            ///    function kick(%client)
            ///    {
            ///       messageAll( 'MsgAdminForce', '\\c2The Admin has kicked %1.', %client.playerName);
            ///    
            ///       if (!%client.isAIControlled())
            ///          BanList::add(%client.guid, %client.getAddress(), $Pref::Server::KickBanTime);
            ///       %client.delete(\"You have been kicked from this server\");
            ///    }
            ///    @endtsexample)
            /// 
            /// </summary>
            public void delete(string gameconnection, string reason)
                {
                m_ts.fnGameConnection_delete(gameconnection, reason);
                }

            /// <summary>
            /// @brief Returns the connection's camera object used when not viewing through the control object.
            ///    
            ///    @see GameConnection::setCameraObject() and GameConnection::clearCameraObject())
            /// 
            /// </summary>
            public string getCameraObject(string gameconnection)
                {
                return m_ts.fnGameConnection_getCameraObject(gameconnection);
                }

            /// <summary>
            /// @brief Returns the default field of view as used by the control object's camera.)
            /// 
            /// </summary>
            public float getControlCameraDefaultFov(string gameconnection)
                {
                return m_ts.fnGameConnection_getControlCameraDefaultFov(gameconnection);
                }

            /// <summary>
            /// @brief Returns the field of view as used by the control object's camera.)
            /// 
            /// </summary>
            public float getControlCameraFov(string gameconnection)
                {
                return m_ts.fnGameConnection_getControlCameraFov(gameconnection);
                }

            /// <summary>
            /// @brief On the server, returns the object that the client is controlling.
            ///    By default the control object is an instance of the Player class, but can also be an instance 
            ///    of Camera (when editing the mission, for example), or any other ShapeBase derived class as 
            ///    appropriate for the game.
            ///    @see GameConnection::setControlObject())
            /// 
            /// </summary>
            public string getControlObject(string gameconnection)
                {
                return m_ts.fnGameConnection_getControlObject(gameconnection);
                }

            /// <summary>
            /// @brief On the client, get the control object's damage flash level.
            ///    @return flash level)
            /// 
            /// </summary>
            public float getDamageFlash(string gameconnection)
                {
                return m_ts.fnGameConnection_getDamageFlash(gameconnection);
                }

            /// <summary>
            /// @brief On the client, get the control object's white-out level.
            ///    @return white-out level)
            /// 
            /// </summary>
            public float getWhiteOut(string gameconnection)
                {
                return m_ts.fnGameConnection_getWhiteOut(gameconnection);
                }

            /// <summary>
            /// @brief Returns true if this connection is AI controlled.
            ///    @see AIConnection)
            /// 
            /// </summary>
            public bool isAIControlled(string gameconnection)
                {
                return m_ts.fnGameConnection_isAIControlled(gameconnection);
                }

            /// <summary>
            /// @brief Returns true if the object being controlled by the client is making use 
            ///    of a rotation damped camera.
            ///    @see Camera)
            /// 
            /// </summary>
            public bool isControlObjectRotDampedCamera(string gameconnection)
                {
                return m_ts.fnGameConnection_isControlObjectRotDampedCamera(gameconnection);
                }

            /// <summary>
            /// @brief Returns true if a previously recorded demo file is now playing.
            ///    
            ///    @see GameConnection::playDemo())
            /// 
            /// </summary>
            public bool isDemoPlaying(string gameconnection)
                {
                return m_ts.fnGameConnection_isDemoPlaying(gameconnection);
                }

            /// <summary>
            /// @brief Returns true if a demo file is now being recorded.
            ///    
            ///    @see GameConnection::startRecording(), GameConnection::stopRecording())
            /// 
            /// </summary>
            public bool isDemoRecording(string gameconnection)
                {
                return m_ts.fnGameConnection_isDemoRecording(gameconnection);
                }

            /// <summary>
            /// @brief Returns true if this connection is in first person mode.
            /// 
            ///    @note Transition to first person occurs over time via mCameraPos, so this 
            ///    won't immediately return true after a set.)
            /// 
            /// </summary>
            public bool isFirstPerson(string gameconnection)
                {
                return m_ts.fnGameConnection_isFirstPerson(gameconnection);
                }

            /// <summary>
            /// @brief List all of the classes that this connection knows about, and what their IDs are. Useful for debugging network problems.
            ///    @note The list is sent to the console.)
            /// 
            /// </summary>
            public void listClassIDs(string gameconnection)
                {
                m_ts.fnGameConnection_listClassIDs(gameconnection);
                }

            /// <summary>
            /// @brief Used on the server to play a 2D sound that is not attached to any object.
            /// 
            ///    @param profile The SFXProfile that defines the sound to play.
            /// 
            ///    @tsexample
            ///    function ServerPlay2D(%profile)
            ///    {
            ///       // Play the given sound profile on every client.
            ///       // The sounds will be transmitted as an event, not attached to any object.
            ///       for(%idx = 0; %idx  ClientGroup.getCount(); %idx++)
            ///          ClientGroup.getObject(%idx).play2D(%profile);
            ///    }
            ///    @endtsexample)
            /// 
            /// </summary>
            public bool play2D(string gameconnection, string profile)
                {
                return m_ts.fnGameConnection_play2D(gameconnection, profile);
                }

            /// <summary>
            /// @brief Used on the server to play a 3D sound that is not attached to any object.
            ///    
            ///    @param profile The SFXProfile that defines the sound to play.
            ///    @param location The position and orientation of the 3D sound given in the form of \"x y z ax ay az aa\".
            /// 
            ///    @tsexample
            ///    function ServerPlay3D(%profile,%transform)
            ///    {
            ///       // Play the given sound profile at the given position on every client
            ///       // The sound will be transmitted as an event, not attached to any object.
            ///       for(%idx = 0; %idx  ClientGroup.getCount(); %idx++)
            ///          ClientGroup.getObject(%idx).play3D(%profile,%transform);
            ///    }
            ///    @endtsexample)
            /// 
            /// </summary>
            public bool play3D(string gameconnection, string profile, TransformF location)
                {
                return m_ts.fnGameConnection_play3D(gameconnection, profile, location.AsString());
                }

            /// <summary>
            /// @brief On the client, play back a previously recorded game session.
            ///    
            ///    It is often useful to play back a game session.  This could be for producing a 
            ///    demo of the game that will be shown at a later time, or for debugging a game.  
            ///    By recording the entire network stream it is possible to later play game the game 
            ///    exactly as it unfolded during the actual play session.  This is because all user 
            ///    control and server results pass through the connection.
            /// 
            ///    @returns True if the playback was successful.  False if there was an issue, such as 
            ///    not being able to open the demo file for playback.
            ///    
            ///    @see GameConnection::startRecording(), GameConnection::stopRecording())
            /// 
            /// </summary>
            public bool playDemo(string gameconnection, string demoFileName)
                {
                return m_ts.fnGameConnection_playDemo(gameconnection, demoFileName);
                }

            /// <summary>
            /// @brief On the server, resets the connection to indicate that ghosting has been disabled.
            /// 
            ///    Typically when a mission has ended on the server, all connected clients are informed of this change 
            ///    and their connections are reset back to a starting state.  This method resets a connection on the 
            ///    server to indicate that ghosts are no longer being transmitted.  On the client end, all ghost 
            ///    information will be deleted.
            /// 
            ///    @tsexample
            ///       // Inform the clients
            ///       for (%clientIndex = 0; %clientIndex  ClientGroup.getCount(); %clientIndex++)
            ///       {
            ///          // clear ghosts and paths from all clients
            ///          %cl = ClientGroup.getObject(%clientIndex);
            ///          %cl.endMission();
            ///          %cl.resetGhosting();
            ///          %cl.clearPaths();
            ///       }
            ///    @endtsexample
            /// 
            ///    @see @ref ghosting_scoping for a description of the ghosting system.)
            /// 
            /// </summary>
            public void resetGhosting(string gameconnection)
                {
                m_ts.fnGameConnection_resetGhosting(gameconnection);
                }

            /// <summary>
            /// @brief On the server, sets the client's 3D display to fade to black.
            ///    @param doFade Set to true to fade to black, and false to fade from black.
            ///    @param timeMS Time it takes to perform the fade as measured in ms.
            ///    @note Not currently hooked up, and is not synchronized over the network.)
            /// 
            /// </summary>
            public void setBlackOut(string gameconnection, bool doFade, int timeMS)
                {
                m_ts.fnGameConnection_setBlackOut(gameconnection, doFade, timeMS);
                }

            /// <summary>
            /// @brief On the server, set the connection's camera object used when not viewing 
            ///    through the control object.
            ///    
            ///    @see GameConnection::getCameraObject() and GameConnection::clearCameraObject())
            /// 
            /// </summary>
            public bool setCameraObject(string gameconnection, string camera)
                {
                return m_ts.fnGameConnection_setCameraObject(gameconnection, camera);
                }

            /// <summary>
            /// (GameConnection, setConnectArgs, void, 3, 17,
            ///    (const char* args) @brief On the client, pass along a variable set of parameters to the server.
            ///    
            ///    Once the connection is established with the server, the server calls its onConnect() method 
            ///    with the client's passed in parameters as aruments.
            ///    
            ///    @see GameConnection::onConnect())
            /// 
            /// </summary>
            public void setConnectArgs(string gameconnection, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "")
                {
                m_ts.fnGameConnection_setConnectArgs(gameconnection, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
                }

            /// <summary>
            /// @brief On the server, sets the control object's camera's field of view.
            ///    @param newFOV New field of view (in degrees) to force the control object's camera to use.  This value 
            ///    is clamped to be within the range of 1 to 179 degrees.
            ///    @note When transmitted over the network to the client, the resolution is limited to 
            ///    one degree.  Any fraction is dropped.)
            /// 
            /// </summary>
            public void setControlCameraFov(string gameconnection, float newFOV)
                {
                m_ts.fnGameConnection_setControlCameraFov(gameconnection, newFOV);
                }

            /// <summary>
            /// @brief On the server, sets the object that the client will control.
            ///    By default the control object is an instance of the Player class, but can also be an instance 
            ///    of Camera (when editing the mission, for example), or any other ShapeBase derived class as 
            ///    appropriate for the game.
            ///    @param ctrlObj The GameBase object on the server to control.)
            /// 
            /// </summary>
            public bool setControlObject(string gameconnection, string ctrlObj)
                {
                return m_ts.fnGameConnection_setControlObject(gameconnection, ctrlObj);
                }

            /// <summary>
            /// @brief On the server, sets this connection into or out of first person mode.
            ///    
            ///    @param firstPerson Set to true to put the connection into first person mode.)
            /// 
            /// </summary>
            public void setFirstPerson(string gameconnection, bool firstPerson)
                {
                m_ts.fnGameConnection_setFirstPerson(gameconnection, firstPerson);
                }

            /// <summary>
            /// @brief On the client, set the password that will be passed to the server.
            ///               
            ///               On the server, this password is compared with what is stored in $pref::Server::Password.  
            ///               If $pref::Server::Password is empty then the client's sent password is ignored.  Otherwise, 
            ///               if the passed in client password and the server password do not match, the CHR_PASSWORD 
            ///               error string is sent back to the client and the connection is immediately terminated.
            ///               
            ///               This password checking is performed quite early on in the connection request process so as 
            ///               to minimize the impact of multiple failed attempts -- also known as hacking.)
            /// 
            /// </summary>
            public void setJoinPassword(string gameconnection, string password)
                {
                m_ts.fnGameConnection_setJoinPassword(gameconnection, password);
                }

            /// <summary>
            /// @brief On the server, transmits the mission file's CRC value to the client.
            /// 
            ///    Typically, during the standard mission start phase 1, the mission file's CRC value 
            ///    on the server is send to the client.  This allows the client to determine if the mission 
            ///    has changed since the last time it downloaded this mission and act appropriately, such as 
            ///    rebuilt cached lightmaps.
            /// 
            ///    @param CRC The mission file's CRC value on the server.
            /// 
            ///    @tsexample
            ///    function serverCmdMissionStartPhase1Ack(%client, %seq)
            ///    {
            ///       // Make sure to ignore calls from a previous mission load
            ///       if (%seq != $missionSequence || !$MissionRunning)
            ///          return;
            ///       if (%client.currentPhase != 0)
            ///          return;
            ///       %client.currentPhase = 1;
            ///    
            ///       // Start with the CRC
            ///       %client.setMissionCRC( $missionCRC );
            ///    
            ///       // Send over the datablocks...
            ///       // OnDataBlocksDone will get called when have confirmation
            ///       // that they've all been received.
            ///       %client.transmitDataBlocks($missionSequence);
            ///    }
            ///    @endtsexample)
            /// 
            /// </summary>
            public void setMissionCRC(string gameconnection, int CRC)
                {
                m_ts.fnGameConnection_setMissionCRC(gameconnection, CRC);
                }

            /// <summary>
            /// @brief On the client, starts recording the network connection's traffic to a demo file.
            ///    
            ///    It is often useful to play back a game session.  This could be for producing a 
            ///    demo of the game that will be shown at a later time, or for debugging a game.  
            ///    By recording the entire network stream it is possible to later play game the game 
            ///    exactly as it unfolded during the actual play session.  This is because all user 
            ///    control and server results pass through the connection.
            ///    
            ///    @param fileName The file name to use for the demo recording.
            ///    
            ///    @see GameConnection::stopRecording(), GameConnection::playDemo())
            /// 
            /// </summary>
            public void startRecording(string gameconnection, string fileName)
                {
                m_ts.fnGameConnection_startRecording(gameconnection, fileName);
                }

            /// <summary>
            /// @brief On the client, stops the recording of a connection's network traffic to a file.
            ///    
            ///    @see GameConnection::startRecording(), GameConnection::playDemo())
            /// 
            /// </summary>
            public void stopRecording(string gameconnection)
                {
                m_ts.fnGameConnection_stopRecording(gameconnection);
                }

            /// <summary>
            /// @brief Sent by the server during phase 1 of the mission download to send the datablocks to the client.
            ///    
            ///    SimDataBlocks, also known as just datablocks, need to be transmitted to the client 
            ///    prior to the client entering the game world.  These represent the static data that 
            ///    most objects in the world reference.  This is typically done during the standard 
            ///    mission start phase 1 when following Torque's example mission startup sequence.
            /// 
            ///    When the datablocks have all been transmitted, onDataBlocksDone() is called to move 
            ///    the mission start process to the next phase.
            /// 
            ///    @param sequence The sequence is common between the server and client and ensures 
            ///    that the client is acting on the most recent mission start process.  If an errant 
            ///    network packet (one that was lost but has now been found) is received by the client 
            ///    with an incorrect sequence, it is just ignored.  This sequence number is updated on 
            ///    the server every time a mission is loaded.
            /// 
            ///    @tsexample
            ///    function serverCmdMissionStartPhase1Ack(%client, %seq)
            ///    {
            ///       // Make sure to ignore calls from a previous mission load
            ///       if (%seq != $missionSequence || !$MissionRunning)
            ///          return;
            ///       if (%client.currentPhase != 0)
            ///          return;
            ///       %client.currentPhase = 1;
            ///    
            ///       // Start with the CRC
            ///       %client.setMissionCRC( $missionCRC );
            ///    
            ///       // Send over the datablocks...
            ///       // OnDataBlocksDone will get called when have confirmation
            ///       // that they've all been received.
            ///       %client.transmitDataBlocks($missionSequence);
            ///    }
            ///    @endtsexample
            ///    
            ///    @see GameConnection::onDataBlocksDone())
            /// 
            /// </summary>
            public void transmitDataBlocks(string gameconnection, int sequence)
                {
                m_ts.fnGameConnection_transmitDataBlocks(gameconnection, sequence);
                }
            }

        #endregion

        #region Nested type: GroundPlaneObject

        /// <summary>
        /// 
        /// </summary>
        public class GroundPlaneObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GroundPlaneObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Force trigger an inspectPostApply. This will transmit 
            ///                    material and other fields to client objects.
            ///                    )
            /// 
            /// </summary>
            public void postApply(string groundplane)
                {
                m_ts.fnGroundPlane_postApply(groundplane);
                }
            }

        #endregion

        #region Nested type: GuiAutoScrollCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiAutoScrollCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiAutoScrollCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Reset scrolling. )
            /// 
            /// </summary>
            public void reset(string guiautoscrollctrl)
                {
                m_ts.fnGuiAutoScrollCtrl_reset(guiautoscrollctrl);
                }
            }

        #endregion

        #region Nested type: GuiBitmapButtonCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiBitmapButtonCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiBitmapButtonCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Set the bitmap to show on the button.
            ///    @param path Path to the texture file in any of the supported formats. )
            /// 
            /// </summary>
            public void setBitmap(string guibitmapbuttonctrl, string path)
                {
                m_ts.fnGuiBitmapButtonCtrl_setBitmap(guibitmapbuttonctrl, path);
                }
            }

        #endregion

        #region Nested type: GuiBitmapCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiBitmapCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiBitmapCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiBitmapCtrl, setBitmap, void, 3, 4,
            ///    ( String filename | String filename, bool resize ) Assign an image to the control.
            ///    @hide )
            /// 
            /// </summary>
            public void setBitmap(string guibitmapctrl, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiBitmapCtrl_setBitmap(guibitmapctrl, a2, a3);
                }

            /// <summary>
            /// Set the offset of the bitmap within the control.
            ///    @param x The x-axis offset of the image.
            ///    @param y The y-axis offset of the image.)
            /// 
            /// </summary>
            public void setValue(string guibitmapctrl, int x, int y)
                {
                m_ts.fnGuiBitmapCtrl_setValue(guibitmapctrl, x, y);
                }
            }

        #endregion

        #region Nested type: GuiButtonBaseCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiButtonBaseCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiButtonBaseCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get the text display on the button's label (if any).
            ///    @return The button's label. )
            /// 
            /// </summary>
            public string getText(string guibuttonbasectrl)
                {
                return m_ts.fnGuiButtonBaseCtrl_getText(guibuttonbasectrl);
                }

            /// <summary>
            /// Simulate a click on the button.
            ///    This method will trigger the button's action just as if the button had been pressed by the 
            ///    user. )
            /// 
            /// </summary>
            public void performClick(string guibuttonbasectrl)
                {
                m_ts.fnGuiButtonBaseCtrl_performClick(guibuttonbasectrl);
                }

            /// <summary>
            /// Reset the mousing state of the button.
            ///    This method should not generally be called. )
            /// 
            /// </summary>
            public void resetState(string guibuttonbasectrl)
                {
                m_ts.fnGuiButtonBaseCtrl_resetState(guibuttonbasectrl);
                }

            /// <summary>
            /// For toggle or radio buttons, set whether the button is currently activated or not.  For radio buttons, 
            ///    toggling a button on will toggle all other radio buttons in its group to off.
            ///    @param isOn If true, the button will be toggled on (if not already); if false, it will be toggled off.
            ///    @note Toggling the state of a button with this method will em>not/em> not trigger the action associated with the 
            ///       button.  To do that, use performClick(). )
            /// 
            /// </summary>
            public void setStateOn(string guibuttonbasectrl, bool isOn)
                {
                m_ts.fnGuiButtonBaseCtrl_setStateOn(guibuttonbasectrl, isOn);
                }

            /// <summary>
            /// Set the text displayed on the button's label.
            ///    @param text The text to display as the button's text label.
            ///    @note Not all buttons render text labels.
            ///    @see getText
            ///    @see setTextID )
            /// 
            /// </summary>
            public void setText(string guibuttonbasectrl, string text)
                {
                m_ts.fnGuiButtonBaseCtrl_setText(guibuttonbasectrl, text);
                }

            /// <summary>
            /// Set the text displayed on the button's label using a string from the string table 
            ///    assigned to the control.
            ///    @param id Name of the variable that contains the integer string ID.  Used to look up 
            ///       string in table.
            ///    @note Not all buttons render text labels.
            ///    @see setText
            ///    @see getText
            ///    @see GuiControl::langTableMod
            ///    @see LangTable
            ///    @ref Gui_i18n )
            /// 
            /// </summary>
            public void setTextID(string guibuttonbasectrl, string id)
                {
                m_ts.fnGuiButtonBaseCtrl_setTextID(guibuttonbasectrl, id);
                }
            }

        #endregion

        #region Nested type: GuiCanvasObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiCanvasObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiCanvasObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Translate a coordinate from canvas window-space to screen-space.
            ///    @param coordinate The coordinate in window-space.
            ///    @return The given coordinate translated to screen-space. )
            /// 
            /// </summary>
            public Point2I clientToScreen(string guicanvas, Point2I coordinate)
                {
                return new Point2I(m_ts.fnGuiCanvas_clientToScreen(guicanvas, coordinate.AsString()));
                }

            /// <summary>
            /// @brief Turns on the mouse off.
            /// 				   @tsexample
            /// 				   Canvas.cursorOff();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void cursorOff(string guicanvas)
                {
                m_ts.fnGuiCanvas_cursorOff(guicanvas);
                }

            /// <summary>
            /// @brief Turns on the mouse cursor.
            /// 				   @tsexample
            /// 				   Canvas.cursorOn();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void cursorOn(string guicanvas)
                {
                m_ts.fnGuiCanvas_cursorOn(guicanvas);
                }

            /// <summary>
            /// @brief Get the GuiControl which is being used as the content.
            /// 
            /// 				   @tsexample
            /// 				   Canvas.getContent();
            /// 				   @endtsexample
            /// 
            /// 				   @return ID of current content control)
            /// 
            /// </summary>
            public int getContent(string guicanvas)
                {
                return m_ts.fnGuiCanvas_getContent(guicanvas);
                }

            /// <summary>
            /// @brief Get the current position of the cursor.
            /// 				   @param param Description
            /// 				   @tsexample
            /// 				   %cursorPos = Canvas.getCursorPos();
            /// 				   @endtsexample
            /// 				   @return Screen coordinates of mouse cursor, in format \"X Y\")
            /// 
            /// </summary>
            public Point2I getCursorPos(string guicanvas)
                {
                return new Point2I(m_ts.fnGuiCanvas_getCursorPos(guicanvas));
                }

            /// <summary>
            /// @brief Returns the dimensions of the canvas
            /// 
            /// 				   @tsexample
            /// 				   %extent = Canvas.getExtent();
            /// 				   @endtsexample
            /// 
            /// 				   @return Width and height of canvas. Formatted as numerical values in a single string \"# #\")
            /// 
            /// </summary>
            public Point2I getExtent(string guicanvas)
                {
                return new Point2I(m_ts.fnGuiCanvas_getExtent(guicanvas));
                }

            /// <summary>
            /// @brief Gets information on the specified mode of this device.
            /// 				   @param modeId Index of the mode to get data from.
            /// 				   @return A video mode string given an adapter and mode index.
            /// 				   @see GuiCanvas::getVideoMode())
            /// 
            /// </summary>
            public string getMode(string guicanvas, int modeId)
                {
                return m_ts.fnGuiCanvas_getMode(guicanvas, modeId);
                }

            /// <summary>
            /// @brief Gets the number of modes available on this device.
            /// 
            /// 				   @param param Description
            /// 
            /// 				   @tsexample
            /// 				   %modeCount = Canvas.getModeCount()
            /// 				   @endtsexample
            /// 
            /// 				   @return The number of video modes supported by the device)
            /// 
            /// </summary>
            public int getModeCount(string guicanvas)
                {
                return m_ts.fnGuiCanvas_getModeCount(guicanvas);
                }

            /// <summary>
            /// @brief Gets the gui control under the mouse.
            /// 				   @tsexample
            /// 				   %underMouse = Canvas.getMouseControl();
            /// 				   @endtsexample
            /// 
            /// 				   @return ID of the gui control, if one was found. NULL otherwise)
            /// 
            /// </summary>
            public int getMouseControl(string guicanvas)
                {
                return m_ts.fnGuiCanvas_getMouseControl(guicanvas);
                }

            /// <summary>
            /// @brief Gets the current screen mode as a string.
            /// 
            /// 				   The return string will contain 5 values (width, height, fullscreen, bitdepth, refreshRate). 
            /// 				   You will need to parse out each one for individual use.
            /// 
            /// 				   @tsexample
            /// 				   %screenWidth = getWord(Canvas.getVideoMode(), 0);
            /// 				   %screenHeight = getWord(Canvas.getVideoMode(), 1);
            /// 				   %isFullscreen = getWord(Canvas.getVideoMode(), 2);
            /// 				   %bitdepth = getWord(Canvas.getVideoMode(), 3);
            /// 				   %refreshRate = getWord(Canvas.getVideoMode(), 4);
            /// 				   @endtsexample
            /// 
            /// 				   @return String formatted with screen width, screen height, screen mode, bit depth, and refresh rate.)
            /// 
            /// </summary>
            public string getVideoMode(string guicanvas)
                {
                return m_ts.fnGuiCanvas_getVideoMode(guicanvas);
                }

            /// <summary>
            /// Get the current position of the platform window associated with the canvas.
            ///    @return The window position of the canvas in screen-space. )
            /// 
            /// </summary>
            public Point2I getWindowPosition(string guicanvas)
                {
                return new Point2I(m_ts.fnGuiCanvas_getWindowPosition(guicanvas));
                }

            /// <summary>
            /// @brief Disable rendering of the cursor.
            /// 
            /// 				   @tsexample
            /// 				   Canvas.hideCursor();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void hideCursor(string guicanvas)
                {
                m_ts.fnGuiCanvas_hideCursor(guicanvas);
                }

            /// <summary>
            /// @brief Determines if mouse cursor is enabled.
            /// 
            /// 				   @tsexample
            /// 				   // Is cursor on?
            /// 				   if(Canvas.isCursorOn())
            /// 				   	echo(\"Canvas cursor is on\");
            /// 				   @endtsexample
            /// 				   @return Returns true if the cursor is on.)
            /// 
            /// </summary>
            public bool isCursorOn(string guicanvas)
                {
                return m_ts.fnGuiCanvas_isCursorOn(guicanvas);
                }

            /// <summary>
            /// @brief Determines if mouse cursor is rendering.
            /// 
            /// 				   @tsexample
            /// 				   // Is cursor rendering?
            /// 				   if(Canvas.isCursorShown())
            /// 				   	echo(\"Canvas cursor is rendering\");
            /// 				   @endtsexample
            /// 				   @return Returns true if the cursor is rendering.)
            /// 
            /// </summary>
            public bool isCursorShown(string guicanvas)
                {
                return m_ts.fnGuiCanvas_isCursorShown(guicanvas);
                }

            /// <summary>
            /// ( GuiCanvas, isFullscreen, bool, 2, 2, () - Is this canvas currently fullscreen? )
            /// 
            /// </summary>
            public bool isFullscreen(string guicanvas = "")
                {
                return m_ts.fnGuiCanvas_isFullscreen(guicanvas);
                }

            /// <summary>
            /// ( GuiCanvas, isMaximized, bool, 2, 2, () )
            /// 
            /// </summary>
            public bool isMaximized(string guicanvas = "")
                {
                return m_ts.fnGuiCanvas_isMaximized(guicanvas);
                }

            /// <summary>
            /// ( GuiCanvas, isMinimized, bool, 2, 2, () )
            /// 
            /// </summary>
            public bool isMinimized(string guicanvas = "")
                {
                return m_ts.fnGuiCanvas_isMinimized(guicanvas);
                }

            /// <summary>
            /// ( GuiCanvas, maximizeWindow, void, 2, 2, () - maximize this canvas' window. )
            /// 
            /// </summary>
            public void maximizeWindow(string guicanvas = "")
                {
                m_ts.fnGuiCanvas_maximizeWindow(guicanvas);
                }

            /// <summary>
            /// ( GuiCanvas, minimizeWindow, void, 2, 2, () - minimize this canvas' window. )
            /// 
            /// </summary>
            public void minimizeWindow(string guicanvas = "")
                {
                m_ts.fnGuiCanvas_minimizeWindow(guicanvas);
                }

            /// <summary>
            /// ( GuiCanvas, popDialog, void, 2, 3, (GuiControl ctrl=NULL)
            /// 			  @hide)
            /// 
            /// </summary>
            public void popDialog(string guicanvas = "", string a2 = "")
                {
                m_ts.fnGuiCanvas_popDialog(guicanvas, a2);
                }

            /// <summary>
            /// ( GuiCanvas, popLayer, void, 2, 3, (int layer) 
            /// 			  @hide)
            /// 
            /// </summary>
            public void popLayer(string guicanvas = "", string a2 = "")
                {
                m_ts.fnGuiCanvas_popLayer(guicanvas, a2);
                }

            /// <summary>
            /// ( GuiCanvas, pushDialog, void, 3, 5, (GuiControl ctrl, int layer=0, bool center=false)
            /// 			  @hide)
            /// 
            /// </summary>
            public void pushDialog(string guicanvas, string a2 = "", string a3 = "", string a4 = "")
                {
                m_ts.fnGuiCanvas_pushDialog(guicanvas, a2, a3, a4);
                }

            /// <summary>
            /// @brief This turns on/off front-buffer rendering.
            /// 
            /// 				   @param enable True if all rendering should be done to the front buffer
            /// 
            /// 				   @tsexample
            /// 				   Canvas.renderFront(false);
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void renderFront(string guicanvas, bool enable)
                {
                m_ts.fnGuiCanvas_renderFront(guicanvas, enable);
                }

            /// <summary>
            /// @brief Force canvas to redraw.
            ///                If the elapsed time is greater than the time since the last paint 
            ///                then the repaint will be skipped.
            ///                @param elapsedMS The optional elapsed time in milliseconds.
            /// 
            /// 				   @tsexample
            /// 				   Canvas.repaint();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void repaint(string guicanvas, int elapsedMS)
                {
                m_ts.fnGuiCanvas_repaint(guicanvas, elapsedMS);
                }

            /// <summary>
            /// @brief Reset the update regions for the canvas.
            /// 
            /// 				   @tsexample
            /// 				   Canvas.reset();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void reset(string guicanvas)
                {
                m_ts.fnGuiCanvas_reset(guicanvas);
                }

            /// <summary>
            /// ( GuiCanvas, restoreWindow, void, 2, 2, () - restore this canvas' window. )
            /// 
            /// </summary>
            public void restoreWindow(string guicanvas = "")
                {
                m_ts.fnGuiCanvas_restoreWindow(guicanvas);
                }

            /// <summary>
            /// Translate a coordinate from screen-space to canvas window-space.
            ///    @param coordinate The coordinate in screen-space.
            ///    @return The given coordinate translated to window-space. )
            /// 
            /// </summary>
            public Point2I screenToClient(string guicanvas, Point2I coordinate)
                {
                return new Point2I(m_ts.fnGuiCanvas_screenToClient(guicanvas, coordinate.AsString()));
                }

            /// <summary>
            /// @brief Set the content of the canvas to a specified control.
            /// 
            /// 				   @param ctrl ID or name of GuiControl to set content to
            /// 
            /// 				   @tsexample
            /// 				   Canvas.setContent(PlayGui);
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void setContent(string guicanvas, string ctrl)
                {
                m_ts.fnGuiCanvas_setContent(guicanvas, ctrl);
                }

            /// <summary>
            /// @brief Sets the cursor for the canvas.
            /// 
            /// 				   @param cursor Name of the GuiCursor to use
            /// 
            /// 				   @tsexample
            /// 				   Canvas.setCursor(\"DefaultCursor\");
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void setCursor(string guicanvas, string cursor)
                {
                m_ts.fnGuiCanvas_setCursor(guicanvas, cursor);
                }

            /// <summary>
            /// ( GuiCanvas, setCursorPos, void, 3, 4, (Point2I pos)
            /// 			  @hide)
            /// 
            /// </summary>
            public void setCursorPos(string guicanvas, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiCanvas_setCursorPos(guicanvas, a2, a3);
                }

            /// <summary>
            /// ( GuiCanvas, setFocus, void, 2,2, () - Claim OS input focus for this canvas' window.)
            /// 
            /// </summary>
            public void setFocus(string guicanvas = "")
                {
                m_ts.fnGuiCanvas_setFocus(guicanvas);
                }

            /// <summary>
            /// ( GuiCanvas, setVideoMode, void, 5, 8,
            ///                (int width, int height, bool fullscreen, [int bitDepth], [int refreshRate], [int antialiasLevel] )
            ///                Change the video mode of this canvas. This method has the side effect of setting the $pref::Video::mode to the new values.
            ///                \\param width The screen width to set.
            ///                \\param height The screen height to set.
            ///                \\param fullscreen Specify true to run fullscreen or false to run in a window
            ///                \\param bitDepth [optional] The desired bit-depth. Defaults to the current setting. This parameter is ignored if you are running in a window.
            ///                \\param refreshRate [optional] The desired refresh rate. Defaults to the current setting. This parameter is ignored if you are running in a window
            /// 					\\param antialiasLevel [optional] The level of anti-aliasing to apply 0 = none )
            /// 
            /// </summary>
            public void setVideoMode(string guicanvas, string a2, string a3, string a4 = "", string a5 = "", string a6 = "", string a7 = "")
                {
                m_ts.fnGuiCanvas_setVideoMode(guicanvas, a2, a3, a4, a5, a6, a7);
                }

            /// <summary>
            /// Set the position of the platform window associated with the canvas.
            ///    @param position The new position of the window in screen-space. )
            /// 
            /// </summary>
            public void setWindowPosition(string guicanvas, Point2I position)
                {
                m_ts.fnGuiCanvas_setWindowPosition(guicanvas, position.AsString());
                }

            /// <summary>
            /// @brief Change the title of the OS window.
            /// 
            /// 				   @param newTitle String containing the new name
            /// 
            /// 				   @tsexample
            /// 				   Canvas.setWindowTitle(\"Documentation Rocks!\");
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void setWindowTitle(string guicanvas, string newTitle)
                {
                m_ts.fnGuiCanvas_setWindowTitle(guicanvas, newTitle);
                }

            /// <summary>
            /// @brief Enable rendering of the cursor.
            /// 
            /// 				   @tsexample
            /// 				   Canvas.showCursor();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void showCursor(string guicanvas)
                {
                m_ts.fnGuiCanvas_showCursor(guicanvas);
                }

            /// <summary>
            /// @brief toggle canvas from fullscreen to windowed mode or back.
            /// 
            /// 				   @tsexample
            /// 				   // If we are in windowed mode, the following will put is in fullscreen
            /// 				   Canvas.toggleFullscreen();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void toggleFullscreen(string guicanvas)
                {
                m_ts.fnGuiCanvas_toggleFullscreen(guicanvas);
                }
            }

        #endregion

        #region Nested type: GuiCheckBoxCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiCheckBoxCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiCheckBoxCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Test whether the checkbox is currently checked.
            ///    @return True if the checkbox is currently ticked, false otherwise. )
            /// 
            /// </summary>
            public bool isStateOn(string guicheckboxctrl)
                {
                return m_ts.fnGuiCheckBoxCtrl_isStateOn(guicheckboxctrl);
                }

            /// <summary>
            /// Set whether the checkbox is ticked or not.
            ///    @param newState If true the box will be checked, if false, it will be unchecked.
            ///    @note This method will @b not trigger the command associated with the control.  To toggle the 
            ///       checkbox state as if the user had clicked the control, use performClick(). )
            /// 
            /// </summary>
            public void setStateOn(string guicheckboxctrl, bool newState)
                {
                m_ts.fnGuiCheckBoxCtrl_setStateOn(guicheckboxctrl, newState);
                }
            }

        #endregion

        #region Nested type: GuiColorPickerCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiColorPickerCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiColorPickerCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (GuiColorPickerCtrl, getSelectorPos, const char*, 2, 2, Gets the current position of the selector)
            /// 
            /// </summary>
            public string getSelectorPos(string guicolorpickerctrl = "")
                {
                return m_ts.fnGuiColorPickerCtrl_getSelectorPos(guicolorpickerctrl);
                }

            /// <summary>
            /// (GuiColorPickerCtrl, setSelectorPos, void, 3, 3, Sets the current position of the selector)
            /// 
            /// </summary>
            public void setSelectorPos(string guicolorpickerctrl, string a2 = "")
                {
                m_ts.fnGuiColorPickerCtrl_setSelectorPos(guicolorpickerctrl, a2);
                }

            /// <summary>
            /// (GuiColorPickerCtrl, updateColor, void, 2, 2, Forces update of pick color)
            /// 
            /// </summary>
            public void updateColor(string guicolorpickerctrl = "")
                {
                m_ts.fnGuiColorPickerCtrl_updateColor(guicolorpickerctrl);
                }
            }

        #endregion

        #region Nested type: GuiControlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiControlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiControlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Add the given control as a child to this control.
            ///    This is synonymous to calling SimGroup::addObject.
            ///    @param control The control to add as a child.
            ///    @note The control will retain its current position and size.
            ///    @see SimGroup::addObject
            ///    @ref GuiControl_Hierarchy )
            /// 
            /// </summary>
            public void addGuiControl(string guicontrol, string control)
                {
                m_ts.fnGuiControl_addGuiControl(guicontrol, control);
                }

            /// <summary>
            /// Clear this control from being the first responder in its hierarchy chain.
            ///    @param ignored Ignored.  Supported for backwards-compatibility. )
            /// 
            /// </summary>
            public void clearFirstResponder(string guicontrol, bool ignored)
                {
                m_ts.fnGuiControl_clearFirstResponder(guicontrol, ignored);
                }

            /// <summary>
            /// Test whether the given control is a direct or indirect child to this control.
            ///    @param control The potential child control.
            ///    @return True if the given control is a direct or indirect child to this control. )
            /// 
            /// </summary>
            public bool controlIsChild(string guicontrol, string control)
                {
                return m_ts.fnGuiControl_controlIsChild(guicontrol, control);
                }

            /// <summary>
            /// Find the topmost child control located at the given coordinates.
            ///    @note Only children that are both visible and have the 'modal' flag set in their profile will be considered in the search.
            ///    @param x The X coordinate in the control's own coordinate space.
            ///    @param y The Y coordinate in the control's own coordinate space.
            ///    @return The topmost child control at the given coordintes or the control on which the method was called if no matching child could be found.
            ///    @see GuiControlProfile::modal
            ///    @see findHitControls )
            /// 
            /// </summary>
            public string findHitControl(string guicontrol, int x, int y)
                {
                return m_ts.fnGuiControl_findHitControl(guicontrol, x, y);
                }

            /// <summary>
            /// Find all visible child controls that intersect with the given rectangle.
            ///    @note Invisible child controls will not be included in the search.
            ///    @param x The X coordinate of the rectangle's upper left corner in the control's own coordinate space.
            ///    @param y The Y coordinate of the rectangle's upper left corner in the control's own coordinate space.
            ///    @param width The width of the search rectangle in pixels.
            ///    @param height The height of the search rectangle in pixels.
            ///    @return A space-separated list of the IDs of all visible control objects intersecting the given rectangle.
            ///    @tsexample
            ///    // Lock all controls in the rectangle at x=10 and y=10 and the extent width=100 and height=100.
            ///    foreach$( %ctrl in %this.findHitControls( 10, 10, 100, 100 ) )
            ///       %ctrl.setLocked( true );
            ///    @endtsexample
            ///    @see findHitControl )
            /// 
            /// </summary>
            public string findHitControls(string guicontrol, int x, int y, int width, int height)
                {
                return m_ts.fnGuiControl_findHitControls(guicontrol, x, y, width, height);
                }

            /// <summary>
            /// Get the aspect ratio of the control's extents.
            ///    @return The width of the control divided by its height.
            ///    @see getExtent )
            /// 
            /// </summary>
            public float getAspect(string guicontrol)
                {
                return m_ts.fnGuiControl_getAspect(guicontrol);
                }

            /// <summary>
            /// Get the coordinate of the control's center point relative to its parent.
            ///    @return The coordinate of the control's center point in parent-relative coordinates. )
            /// 
            /// </summary>
            public Point2I getCenter(string guicontrol)
                {
                return new Point2I(m_ts.fnGuiControl_getCenter(guicontrol));
                }

            /// <summary>
            /// Get the width and height of the control.
            ///    @return A point structure containing the width of the control in x and the height in y. )
            /// 
            /// </summary>
            public Point2I getExtent(string guicontrol)
                {
                return new Point2I(m_ts.fnGuiControl_getExtent(guicontrol));
                }

            /// <summary>
            /// Get the first responder set on this GuiControl tree.
            ///    @return The first responder set on the control's subtree.
            ///    @see isFirstResponder
            ///    @see makeFirstResponder
            ///    @see setFirstResponder
            ///    @ref GuiControl_FirstResponders )
            /// 
            /// </summary>
            public string getFirstResponder(string guicontrol)
                {
                return m_ts.fnGuiControl_getFirstResponder(guicontrol);
                }

            /// <summary>
            /// Get the coordinate of the control's center point in coordinates relative to the root control in its control hierarchy.
            ///    @Return the center coordinate of the control in root-relative coordinates. )
            /// 
            /// </summary>
            public Point2I getGlobalCenter(string guicontrol)
                {
                return new Point2I(m_ts.fnGuiControl_getGlobalCenter(guicontrol));
                }

            /// <summary>
            /// Get the position of the control relative to the root of the GuiControl hierarchy it is contained in.
            ///    @return The control's current position in root-relative coordinates. )
            /// 
            /// </summary>
            public Point2I getGlobalPosition(string guicontrol)
                {
                return new Point2I(m_ts.fnGuiControl_getGlobalPosition(guicontrol));
                }

            /// <summary>
            /// Get the minimum allowed size of the control.
            ///    @return The minimum size to which the control can be shrunk.
            ///    @see minExtent )
            /// 
            /// </summary>
            public Point2I getMinExtent(string guicontrol)
                {
                return new Point2I(m_ts.fnGuiControl_getMinExtent(guicontrol));
                }

            /// <summary>
            /// Get the immediate parent control of the control.
            ///    @return The immediate parent GuiControl or 0 if the control is not parented to a GuiControl. )
            /// 
            /// </summary>
            public string getParent(string guicontrol)
                {
                return m_ts.fnGuiControl_getParent(guicontrol);
                }

            /// <summary>
            /// Get the control's current position relative to its parent.
            ///    @return The coordinate of the control in its parent's coordinate space. )
            /// 
            /// </summary>
            public Point2I getPosition(string guicontrol)
                {
                return new Point2I(m_ts.fnGuiControl_getPosition(guicontrol));
                }

            /// <summary>
            /// Get the canvas on which the control is placed.
            ///    @return The canvas on which the control's hierarchy is currently placed or 0 if the control is not currently placed on a GuiCanvas.
            ///    @see GuiControl_Hierarchy )
            /// 
            /// </summary>
            public string getRoot(string guicontrol)
                {
                return m_ts.fnGuiControl_getRoot(guicontrol);
                }

            /// <summary>
            /// ( GuiControl, getValue, const char*, 2, 2, )
            /// 
            /// </summary>
            public string getValue(string guicontrol = "")
                {
                return m_ts.fnGuiControl_getValue(guicontrol);
                }

            /// <summary>
            /// ( GuiControl, isActive, bool, 2, 2, )
            /// 
            /// </summary>
            public bool isActive(string guicontrol = "")
                {
                return m_ts.fnGuiControl_isActive(guicontrol);
                }

            /// <summary>
            /// Test whether the control is currently awake.
            ///    If a control is awake it means that it is part of the GuiControl hierarchy of a GuiCanvas.
            ///    @return True if the control is awake.
            ///    @ref GuiControl_Waking )
            /// 
            /// </summary>
            public bool isAwake(string guicontrol)
                {
                return m_ts.fnGuiControl_isAwake(guicontrol);
                }

            /// <summary>
            /// Test whether the control is the current first responder.
            ///    @return True if the control is the current first responder.
            ///    @see makeFirstResponder
            ///    @see setFirstResponder
            ///    @ref GuiControl_FirstResponders )
            /// 
            /// </summary>
            public bool isFirstResponder(string guicontrol)
                {
                return m_ts.fnGuiControl_isFirstResponder(guicontrol);
                }

            /// <summary>
            /// Indicates if the mouse is locked in this control.
            ///    @return True if the mouse is currently locked. )
            /// 
            /// </summary>
            public bool isMouseLocked(string guicontrol)
                {
                return m_ts.fnGuiControl_isMouseLocked(guicontrol);
                }

            /// <summary>
            /// Test whether the control is currently set to be visible.
            ///    @return True if the control is currently set to be visible.
            ///    @note This method does not tell anything about whether the control is actually visible to 
            ///       the user at the moment.
            ///    @ref GuiControl_VisibleActive )
            /// 
            /// </summary>
            public bool isVisible(string guicontrol)
                {
                return m_ts.fnGuiControl_isVisible(guicontrol);
                }

            /// <summary>
            /// ( GuiControl, makeFirstResponder, void, 3, 3, (bool isFirst))
            /// 
            /// </summary>
            public void makeFirstResponder(string guicontrol, string a2 = "")
                {
                m_ts.fnGuiControl_makeFirstResponder(guicontrol, a2);
                }

            /// <summary>
            /// Test whether the given point lies within the rectangle of the control.
            ///    @param x X coordinate of the point in parent-relative coordinates.
            ///    @param y Y coordinate of the point in parent-relative coordinates.
            ///    @return True if the point is within the control, false if not.
            ///    @see getExtent
            ///    @see getPosition )
            /// 
            /// </summary>
            public bool pointInControl(string guicontrol, int x, int y)
                {
                return m_ts.fnGuiControl_pointInControl(guicontrol, x, y);
                }

            /// <summary>
            /// Resize and reposition the control using the give coordinates and dimensions.  Child controls 
            ///    will resize according to their layout behaviors.
            ///    @param x The new X coordinate of the control in its parent's coordinate space.
            ///    @param y The new Y coordinate of the control in its parent's coordinate space.
            ///    @param width The new width to which the control should be resized.
            ///    @param height The new height to which the control should be resized. )
            /// 
            /// </summary>
            public void resize(string guicontrol, int x, int y, int width, int height)
                {
                m_ts.fnGuiControl_resize(guicontrol, x, y, width, height);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void setActive(string guicontrol, bool state)
                {
                m_ts.fnGuiControl_setActive(guicontrol, state);
                }

            /// <summary>
            /// Set the control's position by its center point.
            ///    @param x The X coordinate of the new center point of the control relative to the control's parent.
            ///    @param y The Y coordinate of the new center point of the control relative to the control's parent. )
            /// 
            /// </summary>
            public void setCenter(string guicontrol, int x, int y)
                {
                m_ts.fnGuiControl_setCenter(guicontrol, x, y);
                }

            /// <summary>
            /// ( GuiControl, setExtent, void, 3, 4,
            ///    ( Point2I p | int x, int y ) Set the width and height of the control.
            ///    @hide )
            /// 
            /// </summary>
            public void setExtent(string guicontrol, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiControl_setExtent(guicontrol, a2, a3);
                }

            /// <summary>
            /// Make this control the current first responder.
            ///    @note Only controls with a profile that has canKeyFocus enabled are able to become first responders.
            ///    @see GuiControlProfile::canKeyFocus
            ///    @see isFirstResponder
            ///    @ref GuiControl_FirstResponders )
            /// 
            /// </summary>
            public void setFirstResponder(string guicontrol)
                {
                m_ts.fnGuiControl_setFirstResponder(guicontrol);
                }

            /// <summary>
            /// Position the control in the local space of the parent control.
            ///    @param x The new X coordinate of the control relative to its parent's upper left corner.
            ///    @param y The new Y coordinate of the control relative to its parent's upper left corner. )
            /// 
            /// </summary>
            public void setPosition(string guicontrol, int x, int y)
                {
                m_ts.fnGuiControl_setPosition(guicontrol, x, y);
                }

            /// <summary>
            /// Set position of the control relative to the root of the GuiControl hierarchy it is contained in.
            ///    @param x The new X coordinate of the control relative to the root's upper left corner.
            ///    @param y The new Y coordinate of the control relative to the root's upper left corner. )
            /// 
            /// </summary>
            public void setPositionGlobal(string guicontrol, int x, int y)
                {
                m_ts.fnGuiControl_setPositionGlobal(guicontrol, x, y);
                }

            /// <summary>
            /// Set the control profile for the control to use.
            ///    The profile used by a control determines a great part of its behavior and appearance.
            ///    @param profile The new profile the control should use.
            ///    @ref GuiControl_Profiles )
            /// 
            /// </summary>
            public void setProfile(string guicontrol, string profile)
                {
                m_ts.fnGuiControl_setProfile(guicontrol, profile);
                }

            /// <summary>
            /// Set the value associated with the control.
            ///    @param value The new value for the control. )
            /// 
            /// </summary>
            public void setValue(string guicontrol, string value)
                {
                m_ts.fnGuiControl_setValue(guicontrol, value);
                }

            /// <summary>
            /// Set whether the control is visible or not.
            ///    @param state The new visiblity flag state for the control.
            ///    @ref GuiControl_VisibleActive )
            /// 
            /// </summary>
            public void setVisible(string guicontrol, bool state)
                {
                m_ts.fnGuiControl_setVisible(guicontrol, state);
                }
            }

        #endregion

        #region Nested type: GuiControlProfileObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiControlProfileObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiControlProfileObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiControlProfile, getStringWidth, S32, 3, 3, ( pString ) )
            /// 
            /// </summary>
            public int getStringWidth(string guicontrolprofile, string a2 = "")
                {
                return m_ts.fnGuiControlProfile_getStringWidth(guicontrolprofile, a2);
                }
            }

        #endregion

        #region Nested type: GuiDirectoryFileListCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiDirectoryFileListCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiDirectoryFileListCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get the currently selected filename.
            ///    @return The filename of the currently selected file )
            /// 
            /// </summary>
            public string getSelectedFile(string guidirectoryfilelistctrl)
                {
                return m_ts.fnGuiDirectoryFileListCtrl_getSelectedFile(guidirectoryfilelistctrl);
                }

            /// <summary>
            /// Get the list of selected files.
            ///    @return A space separated list of selected files )
            /// 
            /// </summary>
            public string getSelectedFiles(string guidirectoryfilelistctrl)
                {
                return m_ts.fnGuiDirectoryFileListCtrl_getSelectedFiles(guidirectoryfilelistctrl);
                }

            /// <summary>
            /// Update the file list. )
            /// 
            /// </summary>
            public void reload(string guidirectoryfilelistctrl)
                {
                m_ts.fnGuiDirectoryFileListCtrl_reload(guidirectoryfilelistctrl);
                }

            /// <summary>
            /// Set the file filter.
            ///    @param filter Tab-delimited list of file name patterns. Only matched files will be displayed. )
            /// 
            /// </summary>
            public void setFilter(string guidirectoryfilelistctrl, string filter)
                {
                m_ts.fnGuiDirectoryFileListCtrl_setFilter(guidirectoryfilelistctrl, filter);
                }

            /// <summary>
            /// Set the search path and file filter.
            ///    @param path   Path in game directory from which to list files.
            ///    @param filter Tab-delimited list of file name patterns. Only matched files will be displayed. )
            /// 
            /// </summary>
            public bool setPath(string guidirectoryfilelistctrl, string path, string filter)
                {
                return m_ts.fnGuiDirectoryFileListCtrl_setPath(guidirectoryfilelistctrl, path, filter);
                }
            }

        #endregion

        #region Nested type: GuiDragAndDropControlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiDragAndDropControlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiDragAndDropControlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Start the drag operation.
            ///    @param x X coordinate for the mouse pointer offset which the drag control should position itself.
            ///    @param y Y coordinate for the mouse pointer offset which the drag control should position itself.)
            /// 
            /// </summary>
            public void startDragging(string guidraganddropcontrol, int x, int y)
                {
                m_ts.fnGuiDragAndDropControl_startDragging(guidraganddropcontrol, x, y);
                }
            }

        #endregion

        #region Nested type: GuiDynamicCtrlArrayControlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiDynamicCtrlArrayControlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiDynamicCtrlArrayControlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Recalculates the position and size of this control and all its children. )
            /// 
            /// </summary>
            public void refresh(string guidynamicctrlarraycontrol)
                {
                m_ts.fnGuiDynamicCtrlArrayControl_refresh(guidynamicctrlarraycontrol);
                }
            }

        #endregion

        #region Nested type: GuiEditCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiEditCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiEditCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiEditCtrl, addNewCtrl, void, 3, 3, (GuiControl ctrl))
            /// 
            /// </summary>
            public void addNewCtrl(string guieditctrl, string a2 = "")
                {
                m_ts.fnGuiEditCtrl_addNewCtrl(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, addSelection, void, 3, 3, selects a control.)
            /// 
            /// </summary>
            public void addSelection(string guieditctrl, string a2 = "")
                {
                m_ts.fnGuiEditCtrl_addSelection(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, bringToFront, void, 2, 2, )
            /// 
            /// </summary>
            public void bringToFront(string guieditctrl = "")
                {
                m_ts.fnGuiEditCtrl_bringToFront(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, clearGuides, void, 2, 3, ( [ int axis ] ) - Clear all currently set guide lines. )
            /// 
            /// </summary>
            public void clearGuides(string guieditctrl = "", string a2 = "")
                {
                m_ts.fnGuiEditCtrl_clearGuides(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, clearSelection, void, 2, 2, Clear selected controls list.)
            /// 
            /// </summary>
            public void clearSelection(string guieditctrl = "")
                {
                m_ts.fnGuiEditCtrl_clearSelection(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, deleteSelection, void, 2, 2, () - Delete the selected controls.)
            /// 
            /// </summary>
            public void deleteSelection(string guieditctrl = "")
                {
                m_ts.fnGuiEditCtrl_deleteSelection(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, fitIntoParents, void, 2, 4, ( bool width=true, bool height=true ) - Fit selected controls into their parents. )
            /// 
            /// </summary>
            public void fitIntoParents(string guieditctrl = "", string a2 = "", string a3 = "")
                {
                m_ts.fnGuiEditCtrl_fitIntoParents(guieditctrl, a2, a3);
                }

            /// <summary>
            /// ( GuiEditCtrl, getContentControl, S32, 2, 2, () - Return the toplevel control edited inside the GUI editor. )
            /// 
            /// </summary>
            public int getContentControl(string guieditctrl = "")
                {
                return m_ts.fnGuiEditCtrl_getContentControl(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, getCurrentAddSet, S32, 2, 2, Returns the set to which new controls will be added)
            /// 
            /// </summary>
            public int getCurrentAddSet(string guieditctrl = "")
                {
                return m_ts.fnGuiEditCtrl_getCurrentAddSet(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, getMouseMode, const char*, 2, 2, () - Return the current mouse mode. )
            /// 
            /// </summary>
            public string getMouseMode(string guieditctrl = "")
                {
                return m_ts.fnGuiEditCtrl_getMouseMode(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, getNumSelected, S32, 2, 2, () - Return the number of controls currently selected. )
            /// 
            /// </summary>
            public int getNumSelected(string guieditctrl = "")
                {
                return m_ts.fnGuiEditCtrl_getNumSelected(guieditctrl);
                }

            /// <summary>
            /// Gets the set of GUI controls currently selected in the editor. )
            /// 
            /// </summary>
            public string getSelection(string guieditctrl)
                {
                return m_ts.fnGuiEditCtrl_getSelection(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, getSelectionGlobalBounds, const char*, 2, 2, () - Returns global bounds of current selection as vector 'x y width height'. )
            /// 
            /// </summary>
            public string getSelectionGlobalBounds(string guieditctrl = "")
                {
                return m_ts.fnGuiEditCtrl_getSelectionGlobalBounds(guieditctrl);
                }

            /// <summary>
            /// Gets the GUI controls(s) that are currently in the trash.)
            /// 
            /// </summary>
            public string getTrash(string guieditctrl)
                {
                return m_ts.fnGuiEditCtrl_getTrash(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, justify, void, 3, 3, (int mode) )
            /// 
            /// </summary>
            public void justify(string guieditctrl, string a2 = "")
                {
                m_ts.fnGuiEditCtrl_justify(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, loadSelection, void, 2, 3, ( string fileName=null ) - Load selection from file or clipboard.)
            /// 
            /// </summary>
            public void loadSelection(string guieditctrl = "", string a2 = "")
                {
                m_ts.fnGuiEditCtrl_loadSelection(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, moveSelection, void, 4, 4, (int dx, int dy) - Move all controls in the selection by (dx,dy) pixels.)
            /// 
            /// </summary>
            public void moveSelection(string guieditctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiEditCtrl_moveSelection(guieditctrl, a2, a3);
                }

            /// <summary>
            /// ( GuiEditCtrl, pushToBack, void, 2, 2, )
            /// 
            /// </summary>
            public void pushToBack(string guieditctrl = "")
                {
                m_ts.fnGuiEditCtrl_pushToBack(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, readGuides, void, 3, 4, ( GuiControl ctrl [, int axis ] ) - Read the guides from the given control. )
            /// 
            /// </summary>
            public void readGuides(string guieditctrl, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiEditCtrl_readGuides(guieditctrl, a2, a3);
                }

            /// <summary>
            /// ( GuiEditCtrl, removeSelection, void, 3, 3, deselects a control.)
            /// 
            /// </summary>
            public void removeSelection(string guieditctrl, string a2 = "")
                {
                m_ts.fnGuiEditCtrl_removeSelection(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, saveSelection, void, 2, 3, ( string fileName=null ) - Save selection to file or clipboard.)
            /// 
            /// </summary>
            public void saveSelection(string guieditctrl = "", string a2 = "")
                {
                m_ts.fnGuiEditCtrl_saveSelection(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, select, void, 3, 3, (GuiControl ctrl))
            /// 
            /// </summary>
            public void select(string guieditctrl, string a2 = "")
                {
                m_ts.fnGuiEditCtrl_select(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, selectAll, void, 2, 2, ())
            /// 
            /// </summary>
            public void selectAll(string guieditctrl = "")
                {
                m_ts.fnGuiEditCtrl_selectAll(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, selectChildren, void, 2, 3, ( bool addToSelection=false ) - Select children of currently selected controls. )
            /// 
            /// </summary>
            public void selectChildren(string guieditctrl = "", string a2 = "")
                {
                m_ts.fnGuiEditCtrl_selectChildren(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, selectParents, void, 2, 3, ( bool addToSelection=false ) - Select parents of currently selected controls. )
            /// 
            /// </summary>
            public void selectParents(string guieditctrl = "", string a2 = "")
                {
                m_ts.fnGuiEditCtrl_selectParents(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, setContentControl, void, 3, 3, ( GuiControl ctrl ) - Set the toplevel control to edit in the GUI editor. )
            /// 
            /// </summary>
            public void setContentControl(string guieditctrl, string a2 = "")
                {
                m_ts.fnGuiEditCtrl_setContentControl(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, setCurrentAddSet, void, 3, 3, (GuiControl ctrl))
            /// 
            /// </summary>
            public void setCurrentAddSet(string guieditctrl, string a2 = "")
                {
                m_ts.fnGuiEditCtrl_setCurrentAddSet(guieditctrl, a2);
                }

            /// <summary>
            /// (GuiEditCtrl, setSnapToGrid, void, 3, 3, GuiEditCtrl.setSnapToGrid(gridsize))
            /// 
            /// </summary>
            public void setSnapToGrid(string guieditctrl, string a2 = "")
                {
                m_ts.fnGuiEditCtrl_setSnapToGrid(guieditctrl, a2);
                }

            /// <summary>
            /// ( GuiEditCtrl, toggle, void, 2, 2, Toggle activation.)
            /// 
            /// </summary>
            public void toggle(string guieditctrl = "")
                {
                m_ts.fnGuiEditCtrl_toggle(guieditctrl);
                }

            /// <summary>
            /// ( GuiEditCtrl, writeGuides, void, 3, 4, ( GuiControl ctrl [, int axis ] ) - Write the guides to the given control. )
            /// 
            /// </summary>
            public void writeGuides(string guieditctrl, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiEditCtrl_writeGuides(guieditctrl, a2, a3);
                }
            }

        #endregion

        #region Nested type: GuiFileTreeCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiFileTreeCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiFileTreeCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiFileTreeCtrl, getSelectedPath, const char*, 2, 2, getSelectedPath() - returns the currently selected path in the tree)
            /// 
            /// </summary>
            public string getSelectedPath(string guifiletreectrl = "")
                {
                return m_ts.fnGuiFileTreeCtrl_getSelectedPath(guifiletreectrl);
                }

            /// <summary>
            /// ( GuiFileTreeCtrl, reload, void, 2, 2, () - Reread the directory tree hierarchy. )
            /// 
            /// </summary>
            public void reload(string guifiletreectrl = "")
                {
                m_ts.fnGuiFileTreeCtrl_reload(guifiletreectrl);
                }

            /// <summary>
            /// ( GuiFileTreeCtrl, setSelectedPath, bool, 3, 3, setSelectedPath(path) - expands the tree to the specified path)
            /// 
            /// </summary>
            public bool setSelectedPath(string guifiletreectrl, string a2 = "")
                {
                return m_ts.fnGuiFileTreeCtrl_setSelectedPath(guifiletreectrl, a2);
                }
            }

        #endregion

        #region Nested type: GuiFilterCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiFilterCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiFilterCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiFilterCtrl, getValue, const char*, 2, 2, Return a tuple containing all the values in the filter.
            /// 			  @internal)
            /// 
            /// </summary>
            public string getValue(string guifilterctrl = "")
                {
                return m_ts.fnGuiFilterCtrl_getValue(guifilterctrl);
                }

            /// <summary>
            /// ( GuiFilterCtrl, identity, void, 2, 2, Reset the filtering.
            /// 			  @internal)
            /// 
            /// </summary>
            public void identity(string guifilterctrl = "")
                {
                m_ts.fnGuiFilterCtrl_identity(guifilterctrl);
                }

            /// <summary>
            /// ( GuiFilterCtrl, setValue, void, 3, 20, (f1, f2, ...)
            ///               Reset the filter to use the specified points, spread equidistantly across the domain.
            /// 			  @internal)
            /// 
            /// </summary>
            public void setValue(string guifilterctrl, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fnGuiFilterCtrl_setValue(guifilterctrl, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }
            }

        #endregion

        #region Nested type: GuiFormCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiFormCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiFormCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Sets the title of the form.
            ///    @param caption Form caption )
            /// 
            /// </summary>
            public void setCaption(string guiformctrl, string caption)
                {
                m_ts.fnGuiFormCtrl_setCaption(guiformctrl, caption);
                }
            }

        #endregion

        #region Nested type: GuiFrameSetCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiFrameSetCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiFrameSetCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Add a new column. )
            /// 
            /// </summary>
            public void addColumn(string guiframesetctrl)
                {
                m_ts.fnGuiFrameSetCtrl_addColumn(guiframesetctrl);
                }

            /// <summary>
            /// Add a new row. )
            /// 
            /// </summary>
            public void addRow(string guiframesetctrl)
                {
                m_ts.fnGuiFrameSetCtrl_addRow(guiframesetctrl);
                }

            /// <summary>
            /// dynamic ),
            ///    Override the i>borderEnable/i> setting for this frame.
            ///    @param index  Index of the frame to modify
            ///    @param state  New borderEnable state: \"on\", \"off\" or \"dynamic\" )
            /// 
            /// </summary>
            public void frameBorder(string guiframesetctrl, int index, string state)
                {
                m_ts.fnGuiFrameSetCtrl_frameBorder(guiframesetctrl, index, state);
                }

            /// <summary>
            /// Set the minimum width and height for the frame. It will not be possible 
            ///    for the user to resize the frame smaller than this.
            ///    @param index  Index of the frame to modify
            ///    @param width  Minimum width in pixels
            ///    @param height Minimum height in pixels )
            /// 
            /// </summary>
            public void frameMinExtent(string guiframesetctrl, int index, int width, int height)
                {
                m_ts.fnGuiFrameSetCtrl_frameMinExtent(guiframesetctrl, index, width, height);
                }

            /// <summary>
            /// dynamic ),
            ///    Override the i>borderMovable/i> setting for this frame.
            ///    @param index  Index of the frame to modify
            ///    @param state  New borderEnable state: \"on\", \"off\" or \"dynamic\" )
            /// 
            /// </summary>
            public void frameMovable(string guiframesetctrl, int index, string state)
                {
                m_ts.fnGuiFrameSetCtrl_frameMovable(guiframesetctrl, index, state);
                }

            /// <summary>
            /// Set the padding for this frame. Padding introduces blank space on the inside 
            ///    edge of the frame.
            ///    @param index     Index of the frame to modify
            ///    @param padding   Frame top, bottom, left, and right padding )
            /// 
            /// </summary>
            public void framePadding(string guiframesetctrl, int index, RectSpacingI padding)
                {
                m_ts.fnGuiFrameSetCtrl_framePadding(guiframesetctrl, index, padding.AsString());
                }

            /// <summary>
            /// Get the number of columns.
            ///    @return The number of columns )
            /// 
            /// </summary>
            public int getColumnCount(string guiframesetctrl)
                {
                return m_ts.fnGuiFrameSetCtrl_getColumnCount(guiframesetctrl);
                }

            /// <summary>
            /// Get the horizontal offset of a column.
            ///    @param index Index of the column to query
            ///    @return Column offset in pixels )
            /// 
            /// </summary>
            public int getColumnOffset(string guiframesetctrl, int index)
                {
                return m_ts.fnGuiFrameSetCtrl_getColumnOffset(guiframesetctrl, index);
                }

            /// <summary>
            /// Get the padding for this frame.
            ///    @param index     Index of the frame to query )
            /// 
            /// </summary>
            public RectSpacingI getFramePadding(string guiframesetctrl, int index)
                {
                return new RectSpacingI(m_ts.fnGuiFrameSetCtrl_getFramePadding(guiframesetctrl, index));
                }

            /// <summary>
            /// Get the number of rows.
            ///    @return The number of rows )
            /// 
            /// </summary>
            public int getRowCount(string guiframesetctrl)
                {
                return m_ts.fnGuiFrameSetCtrl_getRowCount(guiframesetctrl);
                }

            /// <summary>
            /// Get the vertical offset of a row.
            ///    @param index Index of the row to query
            ///    @return Row offset in pixels )
            /// 
            /// </summary>
            public int getRowOffset(string guiframesetctrl, int index)
                {
                return m_ts.fnGuiFrameSetCtrl_getRowOffset(guiframesetctrl, index);
                }

            /// <summary>
            /// Remove the last (rightmost) column. )
            /// 
            /// </summary>
            public void removeColumn(string guiframesetctrl)
                {
                m_ts.fnGuiFrameSetCtrl_removeColumn(guiframesetctrl);
                }

            /// <summary>
            /// Remove the last (bottom) row. )
            /// 
            /// </summary>
            public void removeRow(string guiframesetctrl)
                {
                m_ts.fnGuiFrameSetCtrl_removeRow(guiframesetctrl);
                }

            /// <summary>
            /// Set the horizontal offset of a column.
            ///    Note that column offsets must always be in increasing order, and therefore 
            ///    this offset must be between the offsets of the colunns either side.
            ///    @param index  Index of the column to modify
            ///    @param offset New column offset )
            /// 
            /// </summary>
            public void setColumnOffset(string guiframesetctrl, int index, int offset)
                {
                m_ts.fnGuiFrameSetCtrl_setColumnOffset(guiframesetctrl, index, offset);
                }

            /// <summary>
            /// Set the vertical offset of a row.
            ///    Note that row offsets must always be in increasing order, and therefore 
            ///    this offset must be between the offsets of the rows either side.
            ///    @param index  Index of the row to modify
            ///    @param offset New row offset )
            /// 
            /// </summary>
            public void setRowOffset(string guiframesetctrl, int index, int offset)
                {
                m_ts.fnGuiFrameSetCtrl_setRowOffset(guiframesetctrl, index, offset);
                }

            /// <summary>
            /// Recalculates child control sizes. )
            /// 
            /// </summary>
            public void updateSizes(string guiframesetctrl)
                {
                m_ts.fnGuiFrameSetCtrl_updateSizes(guiframesetctrl);
                }
            }

        #endregion

        #region Nested type: GuiGameListMenuCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiGameListMenuCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiGameListMenuCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Activates the current row. The script callback of  the current row will be called (if it has one). )
            /// 
            /// </summary>
            public void activateRow(string guigamelistmenuctrl)
                {
                m_ts.fnGuiGameListMenuCtrl_activateRow(guigamelistmenuctrl);
                }

            /// <summary>
            /// Add a row to the list control.
            ///    @param label The text to display on the row as a label.
            ///    @param callback Name of a script function to use as a callback when this row is activated.
            ///    @param icon [optional] Index of the icon to use as a marker.
            ///    @param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
            ///    @param useHighlightIcon [optional] Does this row use the highlight icon?.
            ///    @param enabled [optional] If this row is initially enabled. )
            /// 
            /// </summary>
            public void addRow(string guigamelistmenuctrl, string label, string callback, int icon, int yPad, bool useHighlightIcon, bool enabled)
                {
                m_ts.fnGuiGameListMenuCtrl_addRow(guigamelistmenuctrl, label, callback, icon, yPad, useHighlightIcon, enabled);
                }

            /// <summary>
            /// Gets the number of rows on the control.
            ///    @return (int) The number of rows on the control. )
            /// 
            /// </summary>
            public int getRowCount(string guigamelistmenuctrl)
                {
                return m_ts.fnGuiGameListMenuCtrl_getRowCount(guigamelistmenuctrl);
                }

            /// <summary>
            /// Gets the label displayed on the specified row.
            ///    @param row Index of the row to get the label of.
            ///    @return The label for the row. )
            /// 
            /// </summary>
            public string getRowLabel(string guigamelistmenuctrl, int row)
                {
                return m_ts.fnGuiGameListMenuCtrl_getRowLabel(guigamelistmenuctrl, row);
                }

            /// <summary>
            /// Gets the index of the currently selected row.
            ///    @return Index of the selected row. )
            /// 
            /// </summary>
            public int getSelectedRow(string guigamelistmenuctrl)
                {
                return m_ts.fnGuiGameListMenuCtrl_getSelectedRow(guigamelistmenuctrl);
                }

            /// <summary>
            /// Determines if the specified row is enabled or disabled.
            ///    @param row The row to set the enabled status of.
            ///    @return True if the specified row is enabled. False if the row is not enabled or the given index was not valid. )
            /// 
            /// </summary>
            public bool isRowEnabled(string guigamelistmenuctrl, int row)
                {
                return m_ts.fnGuiGameListMenuCtrl_isRowEnabled(guigamelistmenuctrl, row);
                }

            /// <summary>
            /// Sets a row's enabled status according to the given parameters.
            ///    @param row The index to check for validity.
            ///    @param enabled Indicate true to enable the row or false to disable it. )
            /// 
            /// </summary>
            public void setRowEnabled(string guigamelistmenuctrl, int row, bool enabled)
                {
                m_ts.fnGuiGameListMenuCtrl_setRowEnabled(guigamelistmenuctrl, row, enabled);
                }

            /// <summary>
            /// Sets the label on the given row.
            ///    @param row Index of the row to set the label on.
            ///    @param label Text to set as the label of the row. )
            /// 
            /// </summary>
            public void setRowLabel(string guigamelistmenuctrl, int row, string label)
                {
                m_ts.fnGuiGameListMenuCtrl_setRowLabel(guigamelistmenuctrl, row, label);
                }

            /// <summary>
            /// Sets the selected row. Only rows that are enabled can be selected.
            ///    @param row Index of the row to set as selected. )
            /// 
            /// </summary>
            public void setSelected(string guigamelistmenuctrl, int row)
                {
                m_ts.fnGuiGameListMenuCtrl_setSelected(guigamelistmenuctrl, row);
                }
            }

        #endregion

        #region Nested type: GuiGameListOptionsCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiGameListOptionsCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiGameListOptionsCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Add a row to the list control.
            ///    @param label The text to display on the row as a label.
            ///    @param options A tab separated list of options.
            ///    @param wrapOptions Specify true to allow options to wrap at each end or false to prevent wrapping.
            ///    @param callback Name of a script function to use as a callback when this row is activated.
            ///    @param icon [optional] Index of the icon to use as a marker.
            ///    @param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
            ///    @param enabled [optional] If this row is initially enabled. )
            /// 
            /// </summary>
            public void addRow(string guigamelistoptionsctrl, string label, string options, bool wrapOptions, string callback, int icon, int yPad, bool enabled)
                {
                m_ts.fnGuiGameListOptionsCtrl_addRow(guigamelistoptionsctrl, label, options, wrapOptions, callback, icon, yPad, enabled);
                }

            /// <summary>
            /// Gets the text for the currently selected option of the given row.
            ///    @param row Index of the row to get the option from.
            ///    @return A string representing the text currently displayed as the selected option on the given row. If there is no such displayed text then the empty string is returned. )
            /// 
            /// </summary>
            public string getCurrentOption(string guigamelistoptionsctrl, int row)
                {
                return m_ts.fnGuiGameListOptionsCtrl_getCurrentOption(guigamelistoptionsctrl, row);
                }

            /// <summary>
            /// Set the row's current option to the one specified
            ///    @param row Index of the row to set an option on.
            ///    @param option The option to be made active.
            ///    @return True if the row contained the option and was set, false otherwise. )
            /// 
            /// </summary>
            public bool selectOption(string guigamelistoptionsctrl, int row, string option)
                {
                return m_ts.fnGuiGameListOptionsCtrl_selectOption(guigamelistoptionsctrl, row, option);
                }

            /// <summary>
            /// Sets the list of options on the given row.
            ///    @param row Index of the row to set options on.
            ///    @param optionsList A tab separated list of options for the control. )
            /// 
            /// </summary>
            public void setOptions(string guigamelistoptionsctrl, int row, string optionsList)
                {
                m_ts.fnGuiGameListOptionsCtrl_setOptions(guigamelistoptionsctrl, row, optionsList);
                }
            }

        #endregion

        #region Nested type: GuiGradientCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiGradientCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiGradientCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (GuiGradientCtrl, getColor, const char*, 3, 3, Get color value)
            /// 
            /// </summary>
            public string getColor(string guigradientctrl, string a2 = "")
                {
                return m_ts.fnGuiGradientCtrl_getColor(guigradientctrl, a2);
                }

            /// <summary>
            /// (GuiGradientCtrl, getColorCount, S32, 2, 2, Get color count)
            /// 
            /// </summary>
            public int getColorCount(string guigradientctrl = "")
                {
                return m_ts.fnGuiGradientCtrl_getColorCount(guigradientctrl);
                }
            }

        #endregion

        #region Nested type: GuiGraphCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiGraphCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiGraphCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Sets up the given plotting curve to automatically plot the value of the @a variable with a 
            ///    frequency of @a updateFrequency.
            ///    @param plotId Index of the plotting curve.  Must be 0=plotId6.
            ///    @param variable Name of the global variable.
            ///    @param updateFrequency Frequency with which to add new data points to the plotting curve (in milliseconds).
            ///    @tsexample
            ///    // Plot FPS counter at 1 second intervals.
            ///    %graph.addAutoPlot( 0, \"fps::real\", 1000 );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void addAutoPlot(string guigraphctrl, int plotId, string variable, int updateFrequency)
                {
                m_ts.fnGuiGraphCtrl_addAutoPlot(guigraphctrl, plotId, variable, updateFrequency);
                }

            /// <summary>
            /// Add a data point to the plot's curve.
            ///    @param plotId Index of the plotting curve to which to add the data point.  Must be 0=plotId6.
            ///    @param value Value of the data point to add to the curve.
            ///    @note Data values are added to the @b left end of the plotting curve.
            ///    @note A maximum number of 200 data points can be added to any single plotting curve at any one time.  If 
            ///       this limit is exceeded, data points on the right end of the curve are culled. )
            /// 
            /// </summary>
            public void addDatum(string guigraphctrl, int plotId, float value)
                {
                m_ts.fnGuiGraphCtrl_addDatum(guigraphctrl, plotId, value);
                }

            /// <summary>
            /// Get a data point on the given plotting curve.
            ///    @param plotId Index of the plotting curve from which to fetch the data point.  Must be 0=plotId6.
            ///    @param index Index of the data point on the curve.
            ///    @return The value of the data point or -1 if @a plotId or @a index are out of range. )
            /// 
            /// </summary>
            public float getDatum(string guigraphctrl, int plotId, int index)
                {
                return m_ts.fnGuiGraphCtrl_getDatum(guigraphctrl, plotId, index);
                }

            /// <summary>
            /// Stop automatic variable plotting for the given curve.
            ///    @param plotId Index of the plotting curve.  Must be 0=plotId6. )
            /// 
            /// </summary>
            public void removeAutoPlot(string guigraphctrl, int plotId)
                {
                m_ts.fnGuiGraphCtrl_removeAutoPlot(guigraphctrl, plotId);
                }

            /// <summary>
            /// Change the charting type of the given plotting curve.
            ///    @param plotId Index of the plotting curve.  Must be 0=plotId6.
            ///    @param graphType Charting type to use for the curve.
            ///    @note Instead of calling this method, you can directly assign to #plotType. )
            /// 
            /// </summary>
            public void setGraphType(string guigraphctrl, int plotId, GuiGraphType graphType)
                {
                m_ts.fnGuiGraphCtrl_setGraphType(guigraphctrl, plotId, (int) graphType);
                }
            }

        #endregion

        #region Nested type: GuiIconButtonCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiIconButtonCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiIconButtonCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Set the bitmap to use for the button portion of this control.
            ///    @param buttonFilename Filename for the image
            ///    @tsexample
            ///    // Define the button filename
            ///    %buttonFilename = \"pearlButton\";
            ///    // Inform the GuiIconButtonCtrl control to update its main button graphic to the defined bitmap
            ///    %thisGuiIconButtonCtrl.setBitmap(%buttonFilename);
            ///    @endtsexample
            ///    @see GuiControl
            ///    @see GuiButtonCtrl)
            /// 
            /// </summary>
            public void setBitmap(string guiiconbuttonctrl, string buttonFilename)
                {
                m_ts.fnGuiIconButtonCtrl_setBitmap(guiiconbuttonctrl, buttonFilename);
                }
            }

        #endregion

        #region Nested type: GuiImageListObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiImageListObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiImageListObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Clears the imagelist
            ///    @tsexample
            ///    // Inform the GuiImageList control to clear itself.
            ///    %isFinished = %thisGuiImageList.clear();
            ///    @endtsexample
            ///    @return Returns true when finished.
            ///    @see SimObject)
            /// 
            /// </summary>
            public bool clear(string guiimagelist)
                {
                return m_ts.fnGuiImageList_clear(guiimagelist);
                }

            /// <summary>
            /// @brief Gets the number of images in the list.
            ///    @tsexample
            ///    // Request the number of images from the GuiImageList control.
            ///    %imageCount = %thisGuiImageList.count();
            ///    @endtsexample
            ///    @return Number of images in the control.
            ///    @see SimObject)
            /// 
            /// </summary>
            public int count(string guiimagelist)
                {
                return m_ts.fnGuiImageList_count(guiimagelist);
                }

            /// <summary>
            /// @brief Get a path to the texture at the specified index.
            ///    @param index Index of the image in the list.
            ///    @tsexample
            ///    // Define the image index/n
            ///    %index = \"5\";
            ///    // Request the image path location from the control.
            ///    %imagePath = %thisGuiImageList.getImage(%index);
            ///    @endtsexample
            ///    @return File path to the image map for the specified index.
            ///    @see SimObject)
            /// 
            /// </summary>
            public string getImage(string guiimagelist, int index)
                {
                return m_ts.fnGuiImageList_getImage(guiimagelist, index);
                }

            /// <summary>
            /// @brief Retrieves the imageindex of a specified texture in the list.
            ///    @param imagePath Imagemap including filepath of image to search for
            ///    @tsexample
            ///    // Define the imagemap to search for
            ///    %imagePath = \"./game/client/data/images/thisImage\";
            ///    // Request the index entry for the defined imagemap
            ///    %imageIndex = %thisGuiImageList.getIndex(%imagePath);
            ///    @endtsexample
            ///    @return Index of the imagemap matching the defined image path.
            ///    @see SimObject)
            /// 
            /// </summary>
            public int getIndex(string guiimagelist, string imagePath)
                {
                return m_ts.fnGuiImageList_getIndex(guiimagelist, imagePath);
                }

            /// <summary>
            /// @brief Insert an image into imagelist- returns the image index or -1 for failure.
            ///    @param imagePath Imagemap, with path, to add to the list.
            ///    @tsexample
            ///    // Define the imagemap to add to the list
            ///    %imagePath = \"./game/client/data/images/thisImage\";
            ///    // Request the GuiImageList control to add the defined image to its list.
            ///    %imageIndex = %thisGuiImageList.insert(%imagePath);
            ///    @endtsexample
            ///    @return The index of the newly inserted imagemap, or -1 if the insertion failed.
            ///    @see SimObject)
            /// 
            /// </summary>
            public int insert(string guiimagelist, string imagePath)
                {
                return m_ts.fnGuiImageList_insert(guiimagelist, imagePath);
                }

            /// <summary>
            /// @brief Removes an image from the list by index.
            ///    @param index Image index to remove.
            ///    @tsexample
            ///    // Define the image index.
            ///    %imageIndex = \"4\";
            ///    // Inform the GuiImageList control to remove the image at the defined index.
            ///    %wasSuccessful = %thisGuiImageList.remove(%imageIndex);
            ///    @endtsexample
            ///    @return True if the operation was successful, false if it was not.
            ///    @see SimObject)
            /// 
            /// </summary>
            public bool remove(string guiimagelist, int index)
                {
                return m_ts.fnGuiImageList_remove(guiimagelist, index);
                }
            }

        #endregion

        #region Nested type: GuiInspectorDynamicFieldObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiInspectorDynamicFieldObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiInspectorDynamicFieldObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiInspectorDynamicField, renameField, void, 3,3, field.renameField(newDynamicFieldName); )
            /// 
            /// </summary>
            public void renameField(string guiinspectordynamicfield, string a2 = "")
                {
                m_ts.fnGuiInspectorDynamicField_renameField(guiinspectordynamicfield, a2);
                }
            }

        #endregion

        #region Nested type: GuiInspectorDynamicGroupObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiInspectorDynamicGroupObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiInspectorDynamicGroupObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiInspectorDynamicGroup, addDynamicField, void, 2, 2, obj.addDynamicField(); )
            /// 
            /// </summary>
            public void addDynamicField(string guiinspectordynamicgroup = "")
                {
                m_ts.fnGuiInspectorDynamicGroup_addDynamicField(guiinspectordynamicgroup);
                }

            /// <summary>
            /// (GuiInspectorDynamicGroup, inspectGroup, bool, 2, 2, Refreshes the dynamic fields in the inspector.)
            /// 
            /// </summary>
            public bool inspectGroup(string guiinspectordynamicgroup = "")
                {
                return m_ts.fnGuiInspectorDynamicGroup_inspectGroup(guiinspectordynamicgroup);
                }

            /// <summary>
            /// ( GuiInspectorDynamicGroup, removeDynamicField, void, 3, 3,  )
            /// 
            /// </summary>
            public void removeDynamicField(string guiinspectordynamicgroup, string a2 = "")
                {
                m_ts.fnGuiInspectorDynamicGroup_removeDynamicField(guiinspectordynamicgroup, a2);
                }
            }

        #endregion

        #region Nested type: GuiInspectorFieldObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiInspectorFieldObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiInspectorFieldObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiInspectorField, apply, void, 3, 4, ( string newValue, bool callbacks=true ) - Set the field's value. Suppress callbacks for undo if callbacks=false. )
            /// 
            /// </summary>
            public void apply(string guiinspectorfield, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiInspectorField_apply(guiinspectorfield, a2, a3);
                }

            /// <summary>
            /// ( GuiInspectorField, applyWithoutUndo, void, 3, 3, () - Set field value without recording undo (same as 'apply( value, false )'). )
            /// 
            /// </summary>
            public void applyWithoutUndo(string guiinspectorfield, string a2 = "")
                {
                m_ts.fnGuiInspectorField_applyWithoutUndo(guiinspectorfield, a2);
                }

            /// <summary>
            /// ( GuiInspectorField, getData, const char*, 2, 2, () - Return the value currently displayed on the field. )
            /// 
            /// </summary>
            public string getData(string guiinspectorfield = "")
                {
                return m_ts.fnGuiInspectorField_getData(guiinspectorfield);
                }

            /// <summary>
            /// ( GuiInspectorField, getInspectedFieldName, const char*, 2, 2, () - Return the name of the field edited by this inspector field. )
            /// 
            /// </summary>
            public string getInspectedFieldName(string guiinspectorfield = "")
                {
                return m_ts.fnGuiInspectorField_getInspectedFieldName(guiinspectorfield);
                }

            /// <summary>
            /// ( GuiInspectorField, getInspectedFieldType, const char*, 2, 2, () - Return the type of the field edited by this inspector field. )
            /// 
            /// </summary>
            public string getInspectedFieldType(string guiinspectorfield = "")
                {
                return m_ts.fnGuiInspectorField_getInspectedFieldType(guiinspectorfield);
                }

            /// <summary>
            /// ( GuiInspectorField, getInspector, S32, 2, 2, () - Return the GuiInspector to which this field belongs. )
            /// 
            /// </summary>
            public int getInspector(string guiinspectorfield = "")
                {
                return m_ts.fnGuiInspectorField_getInspector(guiinspectorfield);
                }

            /// <summary>
            /// ( GuiInspectorField, reset, void, 2, 2, () - Reset to default value. )
            /// 
            /// </summary>
            public void reset(string guiinspectorfield = "")
                {
                m_ts.fnGuiInspectorField_reset(guiinspectorfield);
                }
            }

        #endregion

        #region Nested type: GuiInspectorObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiInspectorObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiInspectorObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiInspector, addInspect, void, 3, 4, ( id object, (bool autoSync = true) ) - Add the object to the list of objects being inspected. )
            /// 
            /// </summary>
            public void addInspect(string guiinspector, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiInspector_addInspect(guiinspector, a2, a3);
                }

            /// <summary>
            /// ( GuiInspector, apply, void, 2, 2, apply() - Force application of inspected object's attributes )
            /// 
            /// </summary>
            public void apply(string guiinspector = "")
                {
                m_ts.fnGuiInspector_apply(guiinspector);
                }

            /// <summary>
            /// ( GuiInspector, getInspectObject, const char*, 2, 3, getInspectObject( int index=0 ) - Returns currently inspected object )
            /// 
            /// </summary>
            public string getInspectObject(string guiinspector = "", string a2 = "")
                {
                return m_ts.fnGuiInspector_getInspectObject(guiinspector, a2);
                }

            /// <summary>
            /// ( GuiInspector, getNumInspectObjects, S32, 2, 2, () - Return the number of objects currently being inspected. )
            /// 
            /// </summary>
            public int getNumInspectObjects(string guiinspector = "")
                {
                return m_ts.fnGuiInspector_getNumInspectObjects(guiinspector);
                }

            /// <summary>
            /// ( GuiInspector, inspect, void, 3, 3, Inspect(Object))
            /// 
            /// </summary>
            public void inspect(string guiinspector, string a2 = "")
                {
                m_ts.fnGuiInspector_inspect(guiinspector, a2);
                }

            /// <summary>
            /// ( GuiInspector, refresh, void, 2, 2, Reinspect the currently selected object. )
            /// 
            /// </summary>
            public void refresh(string guiinspector = "")
                {
                m_ts.fnGuiInspector_refresh(guiinspector);
                }

            /// <summary>
            /// ( GuiInspector, removeInspect, void, 3, 3, ( id object ) - Remove the object from the list of objects being inspected. )
            /// 
            /// </summary>
            public void removeInspect(string guiinspector, string a2 = "")
                {
                m_ts.fnGuiInspector_removeInspect(guiinspector, a2);
                }

            /// <summary>
            /// ( GuiInspector, setName, void, 3, 3, setName(NewObjectName))
            /// 
            /// </summary>
            public void setName(string guiinspector, string a2 = "")
                {
                m_ts.fnGuiInspector_setName(guiinspector, a2);
                }

            /// <summary>
            /// ( GuiInspector, setObjectField, void, 4, 4, 
            ///    setObjectField( fieldname, data ) - Set a named fields value on the inspected object if it exists. This triggers all the usual callbacks that would occur if the field had been changed through the gui. )
            /// 
            /// </summary>
            public void setObjectField(string guiinspector, string a2, string a3 = "")
                {
                m_ts.fnGuiInspector_setObjectField(guiinspector, a2, a3);
                }
            }

        #endregion

        #region Nested type: GuiInspectorTypeBitMask32Object

        /// <summary>
        /// 
        /// </summary>
        public class GuiInspectorTypeBitMask32Object
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiInspectorTypeBitMask32Object(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiInspectorTypeBitMask32, applyBit, void, 2,2, apply(); )
            /// 
            /// </summary>
            public void applyBit(string guiinspectortypebitmask32 = "")
                {
                m_ts.fnGuiInspectorTypeBitMask32_applyBit(guiinspectortypebitmask32);
                }
            }

        #endregion

        #region Nested type: GuiInspectorTypeFileNameObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiInspectorTypeFileNameObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiInspectorTypeFileNameObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiInspectorTypeFileName, apply, void, 3,3, apply(newValue); )
            /// 
            /// </summary>
            public void apply(string guiinspectortypefilename, string a2 = "")
                {
                m_ts.fnGuiInspectorTypeFileName_apply(guiinspectortypefilename, a2);
                }
            }

        #endregion

        #region Nested type: GuiListBoxCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiListBoxCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiListBoxCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Checks if there is an item with the exact text of what is passed in, and if so
            ///    the item is removed from the list and adds that item's data to the filtered list.
            ///    @param itemName Name of the item that we wish to add to the filtered item list of the GuiListBoxCtrl.
            ///    @tsexample
            ///    // Define the itemName that we wish to add to the filtered item list.
            ///    %itemName = \"This Item Name\";
            ///    // Add the item name to the filtered item list.
            ///    %thisGuiListBoxCtrl.addFilteredItem(%filteredItemName);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void addFilteredItem(string guilistboxctrl, string newItem)
                {
                m_ts.fnGuiListBoxCtrl_addFilteredItem(guilistboxctrl, newItem);
                }

            /// <summary>
            ///  ),
            ///    @brief Adds an item to the end of the list with an optional color.
            ///    @param newItem New item to add to the list.
            ///    @param color Optional color parameter to add to the new item.
            ///    @tsexample
            ///    // Define the item to add to the list.
            ///    %newItem = \"Gideon's Blue Coat\";
            ///    // Define the optional color for the new list item.
            ///    %color = \"0.0 0.0 1.0\";
            ///    // Inform the GuiListBoxCtrl object to add the item to the end of the list with the defined color.
            ///    %thisGuiListBoxCtrl.addItem(%newItem,%color);
            ///    @endtsexample
            ///    @return If not void, return value and description
            ///    @see GuiControl
            ///    @hide)
            /// 
            /// </summary>
            public int addItem(string guilistboxctrl, string newItem, string color)
                {
                return m_ts.fnGuiListBoxCtrl_addItem(guilistboxctrl, newItem, color);
                }

            /// <summary>
            /// @brief Removes any custom coloring from an item at the defined index id in the list.
            ///    @param index Index id for the item to clear any custom color from.
            ///    @tsexample
            ///    // Define the index id
            ///    %index = \"4\";
            ///    // Request the GuiListBoxCtrl object to remove any custom coloring from the defined index entry
            ///    %thisGuiListBoxCtrl.clearItemColor(%index);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void clearItemColor(string guilistboxctrl, int index)
                {
                m_ts.fnGuiListBoxCtrl_clearItemColor(guilistboxctrl, index);
                }

            /// <summary>
            /// @brief Clears all the items in the listbox.
            ///    @tsexample
            ///    // Inform the GuiListBoxCtrl object to clear all items from its list.
            ///    %thisGuiListBoxCtrl.clearItems();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void clearItems(string guilistboxctrl)
                {
                m_ts.fnGuiListBoxCtrl_clearItems(guilistboxctrl);
                }

            /// <summary>
            /// @brief Sets all currently selected items to unselected.
            ///    Detailed description
            ///    @tsexample
            ///    // Inform the GuiListBoxCtrl object to set all of its items to unselected./n
            ///    %thisGuiListBoxCtrl.clearSelection();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void clearSelection(string guilistboxctrl)
                {
                m_ts.fnGuiListBoxCtrl_clearSelection(guilistboxctrl);
                }

            /// <summary>
            /// @brief Removes the list entry at the requested index id from the control and clears the memory associated with it.
            ///    @param itemIndex Index id location to remove the item from.
            ///    @tsexample
            ///    // Define the index id we want to remove from the list
            ///    %itemIndex = \"8\";
            ///    // Inform the GuiListBoxCtrl object to remove the item at the defined index id.
            ///    %thisGuiListBoxCtrl.deleteItem(%itemIndex);
            ///    @endtsexample
            ///    @see References)
            /// 
            /// </summary>
            public void deleteItem(string guilistboxctrl, int itemIndex)
                {
                m_ts.fnGuiListBoxCtrl_deleteItem(guilistboxctrl, itemIndex);
                }

            /// <summary>
            /// @brief Informs the GuiListBoxCtrl object to mirror the contents of the GuiListBoxCtrl stored in the mirrorSet field.
            ///    @tsexample
            ///    \\ Inform the object to mirror the object located at %thisGuiListBox.mirrorSet
            ///    %thisGuiListBox.doMirror();
            ///    @endtsexample
            ///    @see GuiCore)
            /// 
            /// </summary>
            public void doMirror(string guilistboxctrl)
                {
                m_ts.fnGuiListBoxCtrl_doMirror(guilistboxctrl);
                }

            /// <summary>
            /// @brief Returns index of item with matching text or -1 if none found.
            ///    @param findText Text in the list to find.
            ///    @param isCaseSensitive If true, the search will be case sensitive.
            ///    @tsexample
            ///    // Define the text we wish to find in the list.
            ///    %findText = \"Hickory Smoked Gideon\"/n/n
            ///    // Define if this is a case sensitive search or not.
            ///    %isCaseSensitive = \"false\";
            ///    // Ask the GuiListBoxCtrl object what item id in the list matches the requested text.
            ///    %matchingId = %thisGuiListBoxCtrl.findItemText(%findText,%isCaseSensitive);
            ///    @endtsexample
            ///    @return Index id of item with matching text or -1 if none found.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int findItemText(string guilistboxctrl, string findText, bool bCaseSensitive)
                {
                return m_ts.fnGuiListBoxCtrl_findItemText(guilistboxctrl, findText, bCaseSensitive);
                }

            /// <summary>
            /// @brief Returns the number of items in the list.
            ///    @tsexample
            ///    // Request the number of items in the list of the GuiListBoxCtrl object.
            ///    %listItemCount = %thisGuiListBoxCtrl.getItemCount();
            ///    @endtsexample
            ///    @return The number of items in the list.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getItemCount(string guilistboxctrl)
                {
                return m_ts.fnGuiListBoxCtrl_getItemCount(guilistboxctrl);
                }

            /// <summary>
            /// @brief Returns the object associated with an item. This only makes sense if you are mirroring a simset.
            ///    @param index Index id to request the associated item from.
            ///    @tsexample
            ///    // Define the index id
            ///    %index = \"12\";
            ///    // Request the item from the GuiListBoxCtrl object
            ///    %object = %thisGuiListBoxCtrl.getItemObject(%index);
            ///    @endtsexample
            ///    @return The object associated with the item in the list.
            ///    @see References)
            /// 
            /// </summary>
            public string getItemObject(string guilistboxctrl, int index)
                {
                return m_ts.fnGuiListBoxCtrl_getItemObject(guilistboxctrl, index);
                }

            /// <summary>
            /// @brief Returns the text of the item at the specified index.
            ///    @param index Index id to return the item text from.
            ///    @tsexample
            ///    // Define the index id entry to request the text from
            ///    %index = \"12\";
            ///    // Request the item id text from the GuiListBoxCtrl object.
            ///    %text = %thisGuiListBoxCtrl.getItemText(%index);
            ///    @endtsexample
            ///    @return The text of the requested index id.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getItemText(string guilistboxctrl, int index)
                {
                return m_ts.fnGuiListBoxCtrl_getItemText(guilistboxctrl, index);
                }

            /// <summary>
            /// @brief Request the item index for the item that was last clicked.
            ///    @tsexample
            ///    // Request the item index for the last clicked item in the list
            ///    %lastClickedIndex = %thisGuiListBoxCtrl.getLastClickItem();
            ///    @endtsexample
            ///    @return Index id for the last clicked item in the list.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getLastClickItem(string guilistboxctrl)
                {
                return m_ts.fnGuiListBoxCtrl_getLastClickItem(guilistboxctrl);
                }

            /// <summary>
            /// @brief Returns the number of items currently selected.
            ///    @tsexample
            ///    // Request the number of currently selected items
            ///    %selectedItemCount = %thisGuiListBoxCtrl.getSelCount();
            ///    @endtsexample
            ///    @return Number of currently selected items.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getSelCount(string guilistboxctrl)
                {
                return m_ts.fnGuiListBoxCtrl_getSelCount(guilistboxctrl);
                }

            /// <summary>
            /// @brief Returns the selected items index or -1 if none selected. If multiple selections exist it returns the first selected item. 
            ///    @tsexample
            ///    // Request the index id of the currently selected item
            ///    %selectedItemId = %thisGuiListBoxCtrl.getSelectedItem();
            ///    @endtsexample
            ///    @return The selected items index or -1 if none selected.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getSelectedItem(string guilistboxctrl)
                {
                return m_ts.fnGuiListBoxCtrl_getSelectedItem(guilistboxctrl);
                }

            /// <summary>
            /// @brief Returns a space delimited list of the selected items indexes in the list.
            ///    @tsexample
            ///    // Request a space delimited list of the items in the GuiListBoxCtrl object.
            ///    %selectionList = %thisGuiListBoxCtrl.getSelectedItems();
            ///    @endtsexample
            ///    @return Space delimited list of the selected items indexes in the list
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getSelectedItems(string guilistboxctrl)
                {
                return m_ts.fnGuiListBoxCtrl_getSelectedItems(guilistboxctrl);
                }

            /// <summary>
            /// @brief Inserts an item into the list at the specified index and returns the index assigned or -1 on error.
            ///    @param text Text item to add.
            ///    @param index Index id to insert the list item text at.
            ///    @tsexample
            ///    // Define the text to insert
            ///    %text = \"Secret Agent Gideon\";
            ///    // Define the index entry to insert the text at
            ///    %index = \"14\";
            ///    // In form the GuiListBoxCtrl object to insert the text at the defined index.
            ///    %assignedId = %thisGuiListBoxCtrl.insertItem(%text,%index);
            ///    @endtsexample
            ///    @return If successful will return the index id assigned. If unsuccessful, will return -1.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void insertItem(string guilistboxctrl, string text, int index)
                {
                m_ts.fnGuiListBoxCtrl_insertItem(guilistboxctrl, text, index);
                }

            /// <summary>
            /// @brief Removes an item of the entered name from the filtered items list.
            ///    @param itemName Name of the item to remove from the filtered list.
            ///    @tsexample
            ///    // Define the itemName that you wish to remove.
            ///    %itemName = \"This Item Name\";
            ///    // Remove the itemName from the GuiListBoxCtrl
            ///    %thisGuiListBoxCtrl.removeFilteredItem(%itemName);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void removeFilteredItem(string guilistboxctrl, string itemName)
                {
                m_ts.fnGuiListBoxCtrl_removeFilteredItem(guilistboxctrl, itemName);
                }

            /// <summary>
            /// @brief Sets the currently selected item at the specified index.
            ///    @param indexId Index Id to set selected.
            ///    @tsexample
            ///    // Define the index id that we wish to select.
            ///    %selectId = \"4\";
            ///    // Inform the GuiListBoxCtrl object to set the requested index as selected.
            ///    %thisGuiListBoxCtrl.setCurSel(%selectId);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setCurSel(string guilistboxctrl, int indexId)
                {
                m_ts.fnGuiListBoxCtrl_setCurSel(guilistboxctrl, indexId);
                }

            /// <summary>
            /// @brief Sets the current selection range from index start to stop. If no stop is specified it sets from start index to the end of the list
            ///    @param indexStart Index Id to start selection.
            ///    @param indexStop Index Id to end selection.
            ///    @tsexample
            ///    // Set start id
            ///    %indexStart = \"3\";
            ///    // Set end id
            ///    %indexEnd = \"6\";
            ///    // Request the GuiListBoxCtrl object to select the defined range.
            ///    %thisGuiListBoxCtrl.setCurSelRange(%indexStart,%indexEnd);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setCurSelRange(string guilistboxctrl, int indexStart, int indexStop)
                {
                m_ts.fnGuiListBoxCtrl_setCurSelRange(guilistboxctrl, indexStart, indexStop);
                }

            /// <summary>
            /// @brief Sets the color of a single list entry at the specified index id.
            ///    @param index Index id to modify the color of in the list.
            ///    @param color Color value to set the list entry to.
            ///    @tsexample
            ///    // Define the index id value
            ///    %index = \"5\";
            ///    // Define the color value
            ///    %color = \"1.0 0.0 0.0\";
            ///    // Inform the GuiListBoxCtrl object to change the color of the requested index
            ///    %thisGuiListBoxCtrl.setItemColor(%index,%color);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setItemColor(string guilistboxctrl, int index, ColorF color)
                {
                m_ts.fnGuiListBoxCtrl_setItemColor(guilistboxctrl, index, color.AsString());
                }

            /// <summary>
            /// @brief Sets the items text at the specified index.
            ///    @param index Index id to set the item text at.
            ///    @param newtext Text to change the list item at index id to.
            ///    @tsexample
            ///    // Define the index id/n
            ///    %index = \"12\";
            ///    // Define the text to set the list item to
            ///    %newtext = \"Gideon's Fancy Goggles\";
            ///    // Inform the GuiListBoxCtrl object to change the text at the requested index
            ///    %thisGuiListBoxCtrl.setItemText(%index,%newText);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setItemText(string guilistboxctrl, int index, string newtext)
                {
                m_ts.fnGuiListBoxCtrl_setItemText(guilistboxctrl, index, newtext);
                }

            /// <summary>
            /// @brief Set the tooltip text to display for the given list item.
            ///    @param index Index id to change the tooltip text
            ///    @param text Text for the tooltip.
            ///    @tsexample
            ///    // Define the index id
            ///    %index = \"12\";
            ///    // Define the tooltip text
            ///    %tooltip = \"Gideon's goggles can see through space and time.\"
            ///    // Inform the GuiListBoxCtrl object to set the tooltop for the item at the defined index id
            ///    %thisGuiListBoxCtrl.setItemToolTip(%index,%tooltip);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setItemTooltip(string guilistboxctrl, int index, string text)
                {
                m_ts.fnGuiListBoxCtrl_setItemTooltip(guilistboxctrl, index, text);
                }

            /// <summary>
            /// @brief Enable or disable multiple selections for this GuiListBoxCtrl object.
            ///    @param allowMultSelections Boolean variable to set the use of multiple selections or not.
            ///    @tsexample
            ///    // Define the multiple selection use state.
            ///    %allowMultSelections = \"true\";
            ///    // Set the allow  multiple selection state on the GuiListBoxCtrl object.
            ///    %thisGuiListBoxCtrl.setMultipleSelection(%allowMultSelections);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setMultipleSelection(string guilistboxctrl, bool allowMultSelections)
                {
                m_ts.fnGuiListBoxCtrl_setMultipleSelection(guilistboxctrl, allowMultSelections);
                }

            /// <summary>
            /// @brief Sets the item at the index specified to selected or not.
            ///    Detailed description
            ///    @param index Item index to set selected or unselected.
            ///    @param setSelected Boolean selection state to set the requested item index.
            ///    @tsexample
            ///    // Define the index
            ///    %index = \"5\";
            ///    // Define the selection state
            ///    %selected = \"true\"
            ///    // Inform the GuiListBoxCtrl object of the new selection state for the requested index entry.
            ///    %thisGuiListBoxCtrl.setSelected(%index,%selected);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setSelected(string guilistboxctrl, int index, bool setSelected)
                {
                m_ts.fnGuiListBoxCtrl_setSelected(guilistboxctrl, index, setSelected);
                }
            }

        #endregion

        #region Nested type: GuiMLTextCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiMLTextCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiMLTextCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Appends the text in the control with additional text. Also .
            ///    @param text New text to append to the existing text.
            ///    @param reformat If true, the control will also be visually reset.
            ///    @tsexample
            ///    // Define new text to add
            ///    %text = \"New Text to Add\";
            ///    // Set reformat boolean
            ///    %reformat = \"true\";
            ///    // Inform the control to add the new text
            ///    %thisGuiMLTextCtrl.addText(%text,%reformat);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void addText(string guimltextctrl, string text, bool reformat)
                {
                m_ts.fnGuiMLTextCtrl_addText(guimltextctrl, text, reformat);
                }

            /// <summary>
            /// @brief Forces the text control to reflow the text after new text is added, possibly resizing the control.
            ///    @tsexample
            ///    // Define new text to add
            ///    %newText = \"BACON!\";
            ///    // Add the new text to the control
            ///    %thisGuiMLTextCtrl.addText(%newText);
            ///    // Inform the GuiMLTextCtrl object to force a reflow to ensure the added text fits properly.
            ///    %thisGuiMLTextCtrl.forceReflow();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void forceReflow(string guimltextctrl)
                {
                m_ts.fnGuiMLTextCtrl_forceReflow(guimltextctrl);
                }

            /// <summary>
            /// @brief Returns the text from the control, including TorqueML characters.
            ///    @tsexample
            ///    // Get the text displayed in the control
            ///    %controlText = %thisGuiMLTextCtrl.getText();
            ///    @endtsexample
            ///    @return Text string displayed in the control, including any TorqueML characters.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getText(string guimltextctrl)
                {
                return m_ts.fnGuiMLTextCtrl_getText(guimltextctrl);
                }

            /// <summary>
            /// @brief Scroll to the bottom of the text.
            ///    @tsexample
            ///    // Inform GuiMLTextCtrl object to scroll to its bottom
            ///    %thisGuiMLTextCtrl.scrollToBottom();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void scrollToBottom(string guimltextctrl)
                {
                m_ts.fnGuiMLTextCtrl_scrollToBottom(guimltextctrl);
                }

            /// <summary>
            /// @brief Scroll down to a specified tag.
            ///    Detailed description
            ///    @param tagID TagID to scroll the control to
            ///    @tsexample
            ///    // Define the TagID we want to scroll the control to
            ///    %tagId = \"4\";
            ///    // Inform the GuiMLTextCtrl to scroll to the defined TagID
            ///    %thisGuiMLTextCtrl.scrollToTag(%tagId);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void scrollToTag(string guimltextctrl, int tagID)
                {
                m_ts.fnGuiMLTextCtrl_scrollToTag(guimltextctrl, tagID);
                }

            /// <summary>
            /// @brief Scroll to the top of the text.
            ///    @tsexample
            ///    // Inform GuiMLTextCtrl object to scroll to its top
            ///    %thisGuiMLTextCtrl.scrollToTop();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void scrollToTop(string guimltextctrl, int param1, int param2)
                {
                m_ts.fnGuiMLTextCtrl_scrollToTop(guimltextctrl, param1, param2);
                }

            /// <summary>
            /// @brief Sets the alpha value of the control.
            ///    @param alphaVal n - 1.0 floating value for the alpha
            ///    @tsexample
            ///    // Define the alphe value
            ///    %alphaVal = \"0.5\";
            ///    // Inform the control to update its alpha value.
            ///    %thisGuiMLTextCtrl.setAlpha(%alphaVal);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setAlpha(string guimltextctrl, float alphaVal)
                {
                m_ts.fnGuiMLTextCtrl_setAlpha(guimltextctrl, alphaVal);
                }

            /// <summary>
            /// @brief Change the text cursor's position to a new defined offset within the text in the control.
            ///    @param newPos Offset to place cursor.
            ///    @tsexample
            ///    // Define cursor offset position
            ///    %position = \"23\";
            ///    // Inform the GuiMLTextCtrl object to move the cursor to the new position.
            ///    %thisGuiMLTextCtrl.setCursorPosition(%position);
            ///    @endtsexample
            ///    @return Returns true if the cursor position moved, or false if the position was not changed.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public bool setCursorPosition(string guimltextctrl, int newPos)
                {
                return m_ts.fnGuiMLTextCtrl_setCursorPosition(guimltextctrl, newPos);
                }

            /// <summary>
            /// @brief Set the text contained in the control.
            ///    @param text The text to display in the control.
            ///    @tsexample
            ///    // Define the text to display
            ///    %text = \"Nifty Control Text\";
            ///    // Set the text displayed within the control
            ///    %thisGuiMLTextCtrl.setText(%text);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setText(string guimltextctrl, string text)
                {
                m_ts.fnGuiMLTextCtrl_setText(guimltextctrl, text);
                }
            }

        #endregion

        #region Nested type: GuiMaterialCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiMaterialCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiMaterialCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiMaterialCtrl, setMaterial, bool, 3, 3, ( string materialName )
            ///                Set the material to be displayed in the control. )
            /// 
            /// </summary>
            public bool setMaterial(string guimaterialctrl, string a2 = "")
                {
                return m_ts.fnGuiMaterialCtrl_setMaterial(guimaterialctrl, a2);
                }
            }

        #endregion

        #region Nested type: GuiMaterialPreviewObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiMaterialPreviewObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiMaterialPreviewObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Deletes the preview model.)
            /// 
            /// </summary>
            public void deleteModel(string guimaterialpreview)
                {
                m_ts.fnGuiMaterialPreview_deleteModel(guimaterialpreview);
                }

            /// <summary>
            /// Resets the viewport to default zoom, pan, rotate and lighting.)
            /// 
            /// </summary>
            public void reset(string guimaterialpreview)
                {
                m_ts.fnGuiMaterialPreview_reset(guimaterialpreview);
                }

            /// <summary>
            /// Sets the color of the ambient light in the scene.)
            /// 
            /// </summary>
            public void setAmbientLightColor(string guimaterialpreview, ColorF color)
                {
                m_ts.fnGuiMaterialPreview_setAmbientLightColor(guimaterialpreview, color.AsString());
                }

            /// <summary>
            /// Sets the color of the light in the scene.)
            /// 
            /// </summary>
            public void setLightColor(string guimaterialpreview, ColorF color)
                {
                m_ts.fnGuiMaterialPreview_setLightColor(guimaterialpreview, color.AsString());
                }

            /// <summary>
            /// Sets the model to be displayed in this control
            ///    @param shapeName Name of the model to display.)
            /// 
            /// </summary>
            public void setModel(string guimaterialpreview, string shapeName)
                {
                m_ts.fnGuiMaterialPreview_setModel(guimaterialpreview, shapeName);
                }

            /// <summary>
            /// Sets the distance at which the camera orbits the object. Clamped to the 
            ///    acceptable range defined in the class by min and max orbit distances.
            ///    @param distance The distance to set the orbit to (will be clamped).)
            /// 
            /// </summary>
            public void setOrbitDistance(string guimaterialpreview, float distance)
                {
                m_ts.fnGuiMaterialPreview_setOrbitDistance(guimaterialpreview, distance);
                }
            }

        #endregion

        #region Nested type: GuiMenuBarObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiMenuBarObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiMenuBarObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Adds a new menu to the menu bar.
            ///    @param menuText Text to display for the new menu item.
            ///    @param menuId ID for the new menu item.
            ///    @tsexample
            ///    // Define the menu text
            ///    %menuText = \"New Menu\";
            ///    // Define the menu ID.
            ///    %menuId = \"2\";
            ///    // Inform the GuiMenuBar control to add the new menu
            ///    %thisGuiMenuBar.addMenu(%menuText,%menuId);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void addMenu(string guimenubar, string menuText, int menuId)
                {
                m_ts.fnGuiMenuBar_addMenu(guimenubar, menuText, menuId);
                }

            /// <summary>
            /// ,,0,NULL,-1),
            ///    @brief Adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.
            ///    @param menu Menu name or menu Id to add the new item to.
            ///    @param menuItemText Text for the new menu item.
            ///    @param menuItemId Id for the new menu item.
            ///    @param accelerator Accelerator key for the new menu item.
            ///    @param checkGroup Check group to include this menu item in.
            ///    @tsexample
            ///    // Define the menu we wish to add the item to
            ///    %targetMenu = \"New Menu\";  or  %menu = \"4\";
            ///    // Define the text for the new menu item
            ///    %menuItemText = \"Menu Item\";
            ///    // Define the id for the new menu item
            ///    %menuItemId = \"3\";
            ///    // Set the accelerator key to toggle this menu item with
            ///    %accelerator = \"n\";
            ///    // Define the Check Group that this menu item will be in, if we want it to be in a check group. -1 sets it in no check group.
            ///    %checkGroup = \"4\";
            ///    // Inform the GuiMenuBar control to add the new menu item with the defined fields
            ///    %thisGuiMenuBar.addMenuItem(%menu,%menuItemText,%menuItemId,%accelerator,%checkGroup);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void addMenuItem(string guimenubar, string targetMenu, string menuItemText, int menuItemId, string accelerator, int checkGroup)
                {
                m_ts.fnGuiMenuBar_addMenuItem(guimenubar, targetMenu, menuItemText, menuItemId, accelerator, checkGroup);
                }

            /// <summary>
            /// @brief Adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.
            ///    @param menuTarget Menu to affect a submenu in
            ///    @param menuItem Menu item to affect
            ///    @param submenuItemText Text to show for the new submenu
            ///    @param submenuItemId Id for the new submenu
            ///    @param accelerator Accelerator key for the new submenu
            ///    @param checkGroup Which check group the new submenu should be in, or -1 for none.
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or  %menuTarget = \"3\";
            ///    // Define the menuItem
            ///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
            ///    // Define the text for the new submenu
            ///    %submenuItemText = \"New Submenu Item\";
            ///    // Define the id for the new submenu
            ///    %submenuItemId = \"4\";
            ///    // Define the accelerator key for the new submenu
            ///    %accelerator = \"n\";
            ///    // Define the checkgroup for the new submenu
            ///    %checkgroup = \"7\";
            ///    // Request the GuiMenuBar control to add the new submenu with the defined information
            ///    %thisGuiMenuBar.addSubmenuItem(%menuTarget,%menuItem,%submenuItemText,%submenuItemId,%accelerator,%checkgroup);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void addSubmenuItem(string guimenubar, string menuTarget, string menuItem, string submenuItemText, int submenuItemId, string accelerator, int checkGroup)
                {
                m_ts.fnGuiMenuBar_addSubmenuItem(guimenubar, menuTarget, menuItem, submenuItemText, submenuItemId, accelerator, checkGroup);
                }

            /// <summary>
            /// @brief Removes all the menu items from the specified menu.
            ///    @param menuTarget Menu to remove all items from  
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
            ///    // Inform the GuiMenuBar control to clear all menu items from the defined menu
            ///    %thisGuiMenuBar.clearMenuItems(%menuTarget);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void clearMenuItems(string guimenubar, string menuTarget)
                {
                m_ts.fnGuiMenuBar_clearMenuItems(guimenubar, menuTarget);
                }

            /// <summary>
            /// @brief Clears all the menus from the menu bar.
            ///    @tsexample
            ///    // Inform the GuiMenuBar control to clear all menus from itself.
            ///    %thisGuiMenuBar.clearMenus();
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void clearMenus(string guimenubar, int param1, int param2)
                {
                m_ts.fnGuiMenuBar_clearMenus(guimenubar, param1, param2);
                }

            /// <summary>
            /// @brief Removes all the menu items from the specified submenu.
            ///    @param menuTarget Menu to affect a submenu in
            ///    @param menuItem Menu item to affect
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
            ///    // Define the menuItem
            ///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
            ///    // Inform the GuiMenuBar to remove all submenu items from the defined menu item
            ///    %thisGuiMenuBar.clearSubmenuItems(%menuTarget,%menuItem);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void clearSubmenuItems(string guimenubar, string menuTarget, string menuItem)
                {
                m_ts.fnGuiMenuBar_clearSubmenuItems(guimenubar, menuTarget, menuItem);
                }

            /// <summary>
            /// @brief Removes the specified menu from the menu bar.
            ///    @param menuTarget Menu to remove from the menu bar  
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
            ///    // Inform the GuiMenuBar to remove the defined menu from the menu bar
            ///    %thisGuiMenuBar.removeMenu(%menuTarget);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void removeMenu(string guimenubar, string menuTarget)
                {
                m_ts.fnGuiMenuBar_removeMenu(guimenubar, menuTarget);
                }

            /// <summary>
            /// @brief Removes the specified menu item from the menu.
            ///    @param menuTarget Menu to affect the menu item in
            ///    @param menuItem Menu item to affect
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
            ///    // Define the menuItem
            ///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
            ///    // Request the GuiMenuBar control to remove the define menu item
            ///    %thisGuiMenuBar.removeMenuItem(%menuTarget,%menuItem);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void removeMenuItem(string guimenubar, string menuTarget, string menuItemTarget)
                {
                m_ts.fnGuiMenuBar_removeMenuItem(guimenubar, menuTarget, menuItemTarget);
                }

            /// <summary>
            /// @brief Sets the menu bitmap index for the check mark image.
            ///    @param bitmapIndex Bitmap index for the check mark image.
            ///    @tsexample
            ///    // Define the bitmap index
            ///    %bitmapIndex = \"2\";
            ///    // Inform the GuiMenuBar control of the proper bitmap index for the check mark image
            ///    %thisGuiMenuBar.setCheckmarkBitmapIndex(%bitmapIndex);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setCheckmarkBitmapIndex(string guimenubar, int bitmapindex)
                {
                m_ts.fnGuiMenuBar_setCheckmarkBitmapIndex(guimenubar, bitmapindex);
                }

            /// <summary>
            /// @brief Sets the bitmap index for the menu and toggles rendering only the bitmap.
            ///    @param menuTarget Menu to affect
            ///    @param bitmapindex Bitmap index to set for the menu
            ///    @param bitmaponly If true, only the bitmap will be rendered
            ///    @param drawborder If true, a border will be drawn around the menu.
            ///    @tsexample
            ///    // Define the menuTarget to affect
            ///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
            ///    // Set the bitmap index
            ///    %bitmapIndex = \"5\";
            ///    // Set if we are only to render the bitmap or not
            ///    %bitmaponly = \"true\";
            ///    // Set if we are rendering a border or not
            ///    %drawborder = \"true\";
            ///    // Inform the GuiMenuBar of the bitmap and rendering changes
            ///    %thisGuiMenuBar.setMenuBitmapIndex(%menuTarget,%bitmapIndex,%bitmapOnly,%drawBorder);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuBitmapIndex(string guimenubar, string menuTarget, int bitmapindex, bool bitmaponly, bool drawborder)
                {
                m_ts.fnGuiMenuBar_setMenuBitmapIndex(guimenubar, menuTarget, bitmapindex, bitmaponly, drawborder);
                }

            /// <summary>
            /// @brief Sets the specified menu item bitmap index in the bitmap array.  Setting the item's index to -1 will remove any bitmap.
            ///    @param menuTarget Menu to affect the menuItem in
            ///    @param menuItem Menu item to affect
            ///    @param bitmapIndex Bitmap index to set the menu item to
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or  %menuTarget = \"3\";
            ///    // Define the menuItem\"
            ///    %menuItem = \"New Menu Item\";  or %menuItem = \"2\";
            ///    // Define the bitmapIndex
            ///    %bitmapIndex = \"6\";
            ///    // Inform the GuiMenuBar control to set the menu item to the defined bitmap
            ///    %thisGuiMenuBar.setMenuItemBitmap(%menuTarget,%menuItem,%bitmapIndex);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuItemBitmap(string guimenubar, string menuTarget, string menuItemTarget, int bitmapIndex)
                {
                m_ts.fnGuiMenuBar_setMenuItemBitmap(guimenubar, menuTarget, menuItemTarget, bitmapIndex);
                }

            /// <summary>
            /// @brief Sets the menu item bitmap to a check mark, which by default is the first element in
            ///    the bitmap array (although this may be changed with setCheckmarkBitmapIndex()).
            ///    Any other menu items in the menu with the same check group become unchecked if they are checked.
            ///    @param menuTarget Menu to work in
            ///    @param menuItem Menu item to affect
            ///    @param checked Whether we are setting it to checked or not
            ///    @tsexample
            ///    
            ///    @endtsexample
            ///    @return If not void, return value and description
            ///    @see References)
            /// 
            /// </summary>
            public void setMenuItemChecked(string guimenubar, string menuTarget, string menuItemTarget, bool xchecked)
                {
                m_ts.fnGuiMenuBar_setMenuItemChecked(guimenubar, menuTarget, menuItemTarget, xchecked);
                }

            /// <summary>
            /// @brief sets the menu item to enabled or disabled based on the enable parameter.
            ///    The specified menu and menu item can either be text or ids.
            ///    Detailed description
            ///    @param menuTarget Menu to work in
            ///    @param menuItemTarget The menu item inside of the menu to enable or disable
            ///    @param enabled Boolean enable / disable value.
            ///    @tsexample
            ///    // Define the menu
            ///    %menu = \"New Menu\";  or  %menu = \"4\";
            ///    // Define the menu item
            ///    %menuItem = \"New Menu Item\";  or %menuItem = \"2\";
            ///    // Define the enabled state
            ///    %enabled = \"true\";
            ///    // Inform the GuiMenuBar control to set the enabled state of the requested menu item
            ///    %thisGuiMenuBar.setMenuItemEnable(%menu,%menuItme,%enabled);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuItemEnable(string guimenubar, string menuTarget, string menuItemTarget, bool enabled)
                {
                m_ts.fnGuiMenuBar_setMenuItemEnable(guimenubar, menuTarget, menuItemTarget, enabled);
                }

            /// <summary>
            /// @brief Sets the given menu item to be a submenu.
            ///    @param menuTarget Menu to affect a submenu in
            ///    @param menuItem Menu item to affect
            ///    @param isSubmenu Whether or not the menuItem will become a subMenu or not
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
            ///    // Define the menuItem
            ///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
            ///    // Define whether or not the Menu Item is a sub menu or not
            ///    %isSubmenu = \"true\";
            ///    // Inform the GuiMenuBar control to set the defined menu item to be a submenu or not.
            ///    %thisGuiMenuBar.setMenuItemSubmenuState(%menuTarget,%menuItem,%isSubmenu);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuItemSubmenuState(string guimenubar, string menuTarget, string menuItem, bool isSubmenu)
                {
                m_ts.fnGuiMenuBar_setMenuItemSubmenuState(guimenubar, menuTarget, menuItem, isSubmenu);
                }

            /// <summary>
            /// @brief Sets the text of the specified menu item to the new string.
            ///    @param menuTarget Menu to affect
            ///    @param menuItem Menu item in the menu to change the text at
            ///    @param newMenuItemText New menu text
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or  %menuTarget = \"4\";
            ///    // Define the menuItem
            ///    %menuItem = \"New Menu Item\";  or  %menuItem = \"2\";
            ///    // Define the new text for the menu item
            ///    %newMenuItemText = \"Very New Menu Item\";
            ///    // Inform the GuiMenuBar control to change the defined menu item with the new text
            ///    %thisGuiMenuBar.setMenuItemText(%menuTarget,%menuItem,%newMenuItemText);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuItemText(string guimenubar, string menuTarget, string menuItemTarget, string newMenuItemText)
                {
                m_ts.fnGuiMenuBar_setMenuItemText(guimenubar, menuTarget, menuItemTarget, newMenuItemText);
                }

            /// <summary>
            /// @brief Brief Description.
            ///    Detailed description
            ///    @param menuTarget Menu to affect the menu item in
            ///    @param menuItem Menu item to affect
            ///    @param isVisible Visible state to set the menu item to.
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or  %menuTarget = \"3\";
            ///    // Define the menuItem
            ///    %menuItem = \"New Menu Item\";  or  %menuItem = \"2\";
            ///    // Define the visibility state
            ///    %isVisible = \"true\";
            ///    // Inform the GuiMenuBarControl of the visibility state of the defined menu item
            ///    %thisGuiMenuBar.setMenuItemVisible(%menuTarget,%menuItem,%isVisible);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuItemVisible(string guimenubar, string menuTarget, string menuItemTarget, bool isVisible)
                {
                m_ts.fnGuiMenuBar_setMenuItemVisible(guimenubar, menuTarget, menuItemTarget, isVisible);
                }

            /// <summary>
            /// @brief Sets the menu rendering margins: horizontal, vertical, bitmap spacing.
            ///    Detailed description
            ///    @param horizontalMargin Number of pixels on the left and right side of a menu's text.
            ///    @param verticalMargin Number of pixels on the top and bottom of a menu's text.
            ///    @param bitmapToTextSpacing Number of pixels between a menu's bitmap and text.
            ///    @tsexample
            ///    // Define the horizontalMargin
            ///    %horizontalMargin = \"5\";
            ///    // Define the verticalMargin
            ///    %verticalMargin = \"5\";
            ///    // Define the bitmapToTextSpacing
            ///    %bitmapToTextSpacing = \"12\";
            ///    // Inform the GuiMenuBar control to set its margins based on the defined values.
            ///    %thisGuiMenuBar.setMenuMargins(%horizontalMargin,%verticalMargin,%bitmapToTextSpacing);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuMargins(string guimenubar, int horizontalMargin, int verticalMargin, int bitmapToTextSpacing)
                {
                m_ts.fnGuiMenuBar_setMenuMargins(guimenubar, horizontalMargin, verticalMargin, bitmapToTextSpacing);
                }

            /// <summary>
            /// @brief Sets the text of the specified menu to the new string.
            ///    @param menuTarget Menu to affect
            ///    @param newMenuText New menu text
            ///    @tsexample
            ///    // Define the menu to affect
            ///    %menu = \"New Menu\";  or %menu = \"3\";
            ///    // Define the text to change the menu to
            ///    %newMenuText = \"Still a New Menu\";
            ///    // Inform the GuiMenuBar control to change the defined menu to the defined text
            ///    %thisGuiMenuBar.setMenuText(%menu,%newMenuText);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuText(string guimenubar, string menuTarget, string newMenuText)
                {
                m_ts.fnGuiMenuBar_setMenuText(guimenubar, menuTarget, newMenuText);
                }

            /// <summary>
            /// @brief Sets the whether or not to display the specified menu.
            ///    @param menuTarget Menu item to affect
            ///    @param visible Whether the menu item will be visible or not
            ///    @tsexample
            ///    // Define the menu to work with
            ///    %menuTarget = \"New Menu\";  or  %menuTarget = \"4\";
            ///    // Define if the menu should be visible or not
            ///    %visible = \"true\";
            ///    // Inform the GuiMenuBar control of the new visibility state for the defined menu
            ///    %thisGuiMenuBar.setMenuVisible(%menuTarget,%visible);
            ///    @endtsexample
            ///    @see GuiTickCtrl)
            /// 
            /// </summary>
            public void setMenuVisible(string guimenubar, string menuTarget, bool visible)
                {
                m_ts.fnGuiMenuBar_setMenuVisible(guimenubar, menuTarget, visible);
                }

            /// <summary>
            /// @brief Sets the menu item bitmap to a check mark, which by default is the first element in the
            ///    bitmap array (although this may be changed with setCheckmarkBitmapIndex()).
            ///    Any other menu items in the menu with the same check group become unchecked if they are checked.
            ///    @param menuTarget Menu to affect a submenu in
            ///    @param menuItem Menu item to affect
            ///    @param submenuItemText Text to show for submenu
            ///    @param checked Whether or not this submenu item will be checked.
            ///    @tsexample
            ///    // Define the menuTarget
            ///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
            ///    // Define the menuItem
            ///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
            ///    // Define the text for the new submenu
            ///    %submenuItemText = \"Submenu Item\";
            ///    // Define if this submenu item should be checked or not
            ///    %checked = \"true\";
            ///    // Inform the GuiMenuBar control to set the checked state of the defined submenu item
            ///    %thisGuiMenuBar.setSubmenuItemChecked(%menuTarget,%menuItem,%submenuItemText,%checked);
            ///    @endtsexample
            ///    @return If not void, return value and description
            ///    @see References)
            /// 
            /// </summary>
            public void setSubmenuItemChecked(string guimenubar, string menuTarget, string menuItemTarget, string submenuItemText, bool xchecked)
                {
                m_ts.fnGuiMenuBar_setSubmenuItemChecked(guimenubar, menuTarget, menuItemTarget, submenuItemText, xchecked);
                }
            }

        #endregion

        #region Nested type: GuiMessageVectorCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiMessageVectorCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiMessageVectorCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Push a line onto the back of the list.
            /// 
            /// 	   @param item The GUI element being pushed into the control
            /// 
            /// 	   @tsexample
            /// 	   // All messages are stored in this HudMessageVector, the actual
            /// 	   // MainChatHud only displays the contents of this vector.
            /// 	   new MessageVector(HudMessageVector);
            /// 	   // Attach the MessageVector to the chat control
            /// 	   chatHud.attach(HudMessageVector);
            /// 	   @endtsexample
            /// 
            /// 	   @return Value)
            /// 
            /// </summary>
            public bool attach(string guimessagevectorctrl, string item)
                {
                return m_ts.fnGuiMessageVectorCtrl_attach(guimessagevectorctrl, item);
                }

            /// <summary>
            /// @brief Stop listing messages from the MessageVector previously attached to, if any.
            /// 
            /// 				   Detailed description
            /// 
            /// 				   @param param Description
            /// 
            /// 				   @tsexample
            /// 				   // Deatch the MessageVector from HudMessageVector
            /// 				   // HudMessageVector will no longer render the text
            /// 				   chatHud.detach();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void detach(string guimessagevectorctrl)
                {
                m_ts.fnGuiMessageVectorCtrl_detach(guimessagevectorctrl);
                }
            }

        #endregion

        #region Nested type: GuiMissionAreaCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiMissionAreaCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiMissionAreaCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Set the MissionArea to edit.)
            /// 
            /// </summary>
            public void setMissionArea(string guimissionareactrl, string area)
                {
                m_ts.fnGuiMissionAreaCtrl_setMissionArea(guimissionareactrl, area);
                }

            /// <summary>
            /// @brief Update the terrain bitmap.)
            /// 
            /// </summary>
            public void updateTerrain(string guimissionareactrl)
                {
                m_ts.fnGuiMissionAreaCtrl_updateTerrain(guimissionareactrl);
                }
            }

        #endregion

        #region Nested type: GuiObjectViewObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiObjectViewObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiObjectViewObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Return the current multiplier for camera zooming and rotation.
            ///    @tsexample
            ///    // Request the current camera zooming and rotation multiplier value
            ///    %multiplier = %thisGuiObjectView.getCameraSpeed();
            ///    @endtsexample
            ///    @return Camera zooming / rotation multiplier value.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public float getCameraSpeed(string guiobjectview)
                {
                return m_ts.fnGuiObjectView_getCameraSpeed(guiobjectview);
                }

            /// <summary>
            /// @brief Return the model displayed in this view.
            ///    @tsexample
            ///    // Request the displayed model name from the GuiObjectView object.
            ///    %modelName = %thisGuiObjectView.getModel();
            ///    @endtsexample
            ///    @return Name of the displayed model.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getModel(string guiobjectview)
                {
                return m_ts.fnGuiObjectView_getModel(guiobjectview);
                }

            /// <summary>
            /// @brief Return the name of the mounted model.
            ///    @tsexample
            ///    // Request the name of the mounted model from the GuiObjectView object
            ///    %mountedModelName = %thisGuiObjectView.getMountedModel();
            ///    @endtsexample
            ///    @return Name of the mounted model.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getMountedModel(string guiobjectview)
                {
                return m_ts.fnGuiObjectView_getMountedModel(guiobjectview);
                }

            /// <summary>
            /// @brief Return the name of skin used on the mounted model.
            ///    @tsexample
            ///    // Request the skin name from the model mounted on to the main model in the control
            ///    %mountModelSkin = %thisGuiObjectView.getMountSkin();
            ///    @endtsexample
            ///    @return Name of the skin used on the mounted model.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getMountSkin(string guiobjectview, int param1, int param2)
                {
                return m_ts.fnGuiObjectView_getMountSkin(guiobjectview, param1, param2);
                }

            /// <summary>
            /// @brief Return the current distance at which the camera orbits the object.
            ///    @tsexample
            ///    // Request the current orbit distance
            ///    %orbitDistance = %thisGuiObjectView.getOrbitDistance();
            ///    @endtsexample
            ///    @return The distance at which the camera orbits the object.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public float getOrbitDistance(string guiobjectview)
                {
                return m_ts.fnGuiObjectView_getOrbitDistance(guiobjectview);
                }

            /// <summary>
            /// @brief Return the name of skin used on the primary model.
            ///    @tsexample
            ///    // Request the name of the skin used on the primary model in the control
            ///    %skinName = %thisGuiObjectView.getSkin();
            ///    @endtsexample
            ///    @return Name of the skin used on the primary model.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getSkin(string guiobjectview)
                {
                return m_ts.fnGuiObjectView_getSkin(guiobjectview);
                }

            /// <summary>
            /// @brief Sets the multiplier for the camera rotation and zoom speed.
            ///    @param factor Multiplier for camera rotation and zoom speed.
            ///    @tsexample
            ///    // Set the factor value
            ///    %factor = \"0.75\";
            ///    // Inform the GuiObjectView object to set the camera speed.
            ///    %thisGuiObjectView.setCameraSpeed(%factor);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setCameraSpeed(string guiobjectview, float factor)
                {
                m_ts.fnGuiObjectView_setCameraSpeed(guiobjectview, factor);
                }

            /// <summary>
            /// @brief Set the light ambient color on the sun object used to render the model.
            ///    @param color Ambient color of sunlight.
            ///    @tsexample
            ///    // Define the sun ambient color value
            ///    %color = \"1.0 0.4 0.6\";
            ///    // Inform the GuiObjectView object to set the sun ambient color to the requested value
            ///    %thisGuiObjectView.setLightAmbient(%color);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setLightAmbient(string guiobjectview, ColorF color)
                {
                m_ts.fnGuiObjectView_setLightAmbient(guiobjectview, color.AsString());
                }

            /// <summary>
            /// @brief Set the light color on the sun object used to render the model.
            ///    @param color Color of sunlight.
            ///    @tsexample
            ///    // Set the color value for the sun
            ///    %color = \"1.0 0.4 0.5\";
            ///    // Inform the GuiObjectView object to change the sun color to the defined value
            ///    %thisGuiObjectView.setLightColor(%color);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setLightColor(string guiobjectview, ColorF color)
                {
                m_ts.fnGuiObjectView_setLightColor(guiobjectview, color.AsString());
                }

            /// <summary>
            /// @brief Set the light direction from which to light the model.
            ///    @param direction XYZ direction from which the light will shine on the model
            ///    @tsexample
            ///    // Set the light direction
            ///    %direction = \"1.0 0.2 0.4\"
            ///    // Inform the GuiObjectView object to change the light direction to the defined value
            ///    %thisGuiObjectView.setLightDirection(%direction);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setLightDirection(string guiobjectview, Point3F direction)
                {
                m_ts.fnGuiObjectView_setLightDirection(guiobjectview, direction.AsString());
                }

            /// <summary>
            /// @brief Sets the model to be displayed in this control.
            ///    @param shapeName Name of the model to display.
            ///    @tsexample
            ///    // Define the model we want to display
            ///    %shapeName = \"gideon.dts\";
            ///    // Tell the GuiObjectView object to display the defined model
            ///    %thisGuiObjectView.setModel(%shapeName);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setModel(string guiobjectview, string shapeName)
                {
                m_ts.fnGuiObjectView_setModel(guiobjectview, shapeName);
                }

            /// <summary>
            /// @brief Mounts the given model to the specified mount point of the primary model displayed in this control.
            ///    Detailed description
            ///    @param shapeName Name of the model to mount.
            ///    @param mountNodeIndexOrName Index or name of the mount point to be mounted to. If index, corresponds to \"mountN\" in your shape where N is the number passed here.
            ///    @tsexample
            ///    // Set the shapeName to mount
            ///    %shapeName = \"GideonGlasses.dts\"
            ///    // Set the mount node of the primary model in the control to mount the new shape at
            ///    %mountNodeIndexOrName = \"3\";
            ///    //OR:
            ///    %mountNodeIndexOrName = \"Face\";
            ///    // Inform the GuiObjectView object to mount the shape at the specified node.
            ///    %thisGuiObjectView.setMount(%shapeName,%mountNodeIndexOrName);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setMount(string guiobjectview, string shapeName, string mountNodeIndexOrName)
                {
                m_ts.fnGuiObjectView_setMount(guiobjectview, shapeName, mountNodeIndexOrName);
                }

            /// <summary>
            /// @brief Sets the model to be mounted on the primary model.
            ///    @param shapeName Name of the model to mount.
            ///    @tsexample
            ///    // Define the model name to mount
            ///    %modelToMount = \"GideonGlasses.dts\";
            ///    // Inform the GuiObjectView object to mount the defined model to the existing model in the control
            ///    %thisGuiObjectView.setMountedModel(%modelToMount);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setMountedModel(string guiobjectview, string shapeName)
                {
                m_ts.fnGuiObjectView_setMountedModel(guiobjectview, shapeName);
                }

            /// <summary>
            /// @brief Sets the skin to use on the mounted model.
            ///    @param skinName Name of the skin to set on the model mounted to the main model in the control
            ///    @tsexample
            ///    // Define the name of the skin
            ///    %skinName = \"BronzeGlasses\";
            ///    // Inform the GuiObjectView Control of the skin to use on the mounted model
            ///    %thisGuiObjectViewCtrl.setMountSkin(%skinName);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setMountSkin(string guiobjectview, string skinName)
                {
                m_ts.fnGuiObjectView_setMountSkin(guiobjectview, skinName);
                }

            /// <summary>
            /// @brief Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.
            ///    Detailed description
            ///    @param distance The distance to set the orbit to (will be clamped).
            ///    @tsexample
            ///    // Define the orbit distance value
            ///    %orbitDistance = \"1.5\";
            ///    // Inform the GuiObjectView object to set the orbit distance to the defined value
            ///    %thisGuiObjectView.setOrbitDistance(%orbitDistance);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setOrbitDistance(string guiobjectview, float distance)
                {
                m_ts.fnGuiObjectView_setOrbitDistance(guiobjectview, distance);
                }

            /// <summary>
            /// @brief Sets the animation to play for the viewed object.
            ///    @param indexOrName The index or name of the animation to play.
            ///    @tsexample
            ///    // Set the animation index value, or animation sequence name.
            ///    %indexVal = \"3\";
            ///    //OR:
            ///    %indexVal = \"idle\";
            ///    // Inform the GuiObjectView object to set the animation sequence of the object in the control.
            ///    %thisGuiObjectVew.setSeq(%indexVal);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setSeq(string guiobjectview, string indexOrName)
                {
                m_ts.fnGuiObjectView_setSeq(guiobjectview, indexOrName);
                }

            /// <summary>
            /// @brief Sets the skin to use on the model being displayed.
            ///    @param skinName Name of the skin to use.
            ///    @tsexample
            ///    // Define the skin we want to apply to the main model in the control
            ///    %skinName = \"disco_gideon\";
            ///    // Inform the GuiObjectView control to update the skin the to defined skin
            ///    %thisGuiObjectView.setSkin(%skinName);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setSkin(string guiobjectview, string skinName)
                {
                m_ts.fnGuiObjectView_setSkin(guiobjectview, skinName);
                }
            }

        #endregion

        #region Nested type: GuiPaneControlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiPaneControlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiPaneControlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Collapse or un-collapse the control.
            ///    @param collapse True to collapse the control, false to un-collapse it )
            /// 
            /// </summary>
            public void setCollapsed(string guipanecontrol, bool collapse)
                {
                m_ts.fnGuiPaneControl_setCollapsed(guipanecontrol, collapse);
                }
            }

        #endregion

        #region Nested type: GuiParticleGraphCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiParticleGraphCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiParticleGraphCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, addPlotPoint, const char*, 5, 6, (int plotID, float x, float y, bool setAdded = true;)
            ///               Add a data point to the given plot.
            /// 			  @return)
            /// 
            /// </summary>
            public string addPlotPoint(string guiparticlegraphctrl, string a2, string a3, string a4 = "", string a5 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_addPlotPoint(guiparticlegraphctrl, a2, a3, a4, a5);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, changePlotPoint, const char*, 6, 6, (int plotID, int i, float x, float y)
            ///               Change a data point to the given plot and plot position.
            /// 			  @param plotID The plot you want to access
            /// 			  @param i The data point.
            /// 			  @param x,y The plot position.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public string changePlotPoint(string guiparticlegraphctrl, string a2, string a3, string a4, string a5 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_changePlotPoint(guiparticlegraphctrl, a2, a3, a4, a5);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, clearAllGraphs, void, 2, 2, ()
            ///               Clear all of the graphs.
            /// 			  @return No return value)
            /// 
            /// </summary>
            public void clearAllGraphs(string guiparticlegraphctrl = "")
                {
                m_ts.fnGuiParticleGraphCtrl_clearAllGraphs(guiparticlegraphctrl);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, clearGraph, void, 3, 3, (int plotID)
            ///               Clear the graph of the given plot.
            /// 			  @return No return value)
            /// 
            /// </summary>
            public void clearGraph(string guiparticlegraphctrl, string a2 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_clearGraph(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, getGraphColor, const char*, 3, 3, (int plotID)
            ///               Get the color of the graph passed.
            /// 			  @return Returns the color of the graph as a string of RGB values formatted as \"R G B\")
            /// 
            /// </summary>
            public string getGraphColor(string guiparticlegraphctrl, string a2 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_getGraphColor(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, getGraphMax, const char*, 3, 3, (int plotID) 
            /// 			  Get the maximum values of the graph ranges.
            /// 			  @return Returns the maximum of the range formatted as \"x-max y-max\")
            /// 
            /// </summary>
            public string getGraphMax(string guiparticlegraphctrl, string a2 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_getGraphMax(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, getGraphMin, const char*, 3, 3, (int plotID) 
            ///               Get the minimum values of the graph ranges.
            /// 			  @return Returns the minimum of the range formatted as \"x-min y-min\")
            /// 
            /// </summary>
            public string getGraphMin(string guiparticlegraphctrl, string a2 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_getGraphMin(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, getGraphName, const char*, 3, 3, (int plotID) 
            ///               Get the name of the graph passed.
            /// 			  @return Returns the name of the plot)
            /// 
            /// </summary>
            public string getGraphName(string guiparticlegraphctrl, string a2 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_getGraphName(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, getPlotIndex, const char*, 5, 5, (int plotID, float x, float y)
            ///               Gets the index of the point passed on the plotID passed (graph ID).
            /// 			  @param plotID The plot you wish to check.
            /// 			  @param x,y The coordinates of the point to get.
            /// 			  @return Returns the index of the point.)
            /// 
            /// </summary>
            public string getPlotIndex(string guiparticlegraphctrl, string a2, string a3, string a4 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_getPlotIndex(guiparticlegraphctrl, a2, a3, a4);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, getPlotPoint, const char*, 4, 4, (int plotID, int samples)
            ///               Get a data point from the plot specified, samples from the start of the graph.
            /// 			  @return The data point ID)
            /// 
            /// </summary>
            public string getPlotPoint(string guiparticlegraphctrl, string a2, string a3 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_getPlotPoint(guiparticlegraphctrl, a2, a3);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, getSelectedPlot, const char*, 2, 2, () 
            ///               Gets the selected Plot (a.k.a. graph).
            /// 			  @return The plot's ID.)
            /// 
            /// </summary>
            public string getSelectedPlot(string guiparticlegraphctrl = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_getSelectedPlot(guiparticlegraphctrl);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, getSelectedPoint, const char*, 2, 2, ()
            ///               Gets the selected Point on the Plot (a.k.a. graph).
            /// 			  @return The last selected point ID)
            /// 
            /// </summary>
            public string getSelectedPoint(string guiparticlegraphctrl = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_getSelectedPoint(guiparticlegraphctrl);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, insertPlotPoint, void, 6, 6, (int plotID, int i, float x, float y)
            ///               Insert a data point to the given plot and plot position.
            /// 			  @param plotID The plot you want to access
            /// 			  @param i The data point.
            /// 			  @param x,y The plot position.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void insertPlotPoint(string guiparticlegraphctrl, string a2, string a3, string a4, string a5 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_insertPlotPoint(guiparticlegraphctrl, a2, a3, a4, a5);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, isExistingPoint, const char*, 4, 4, (int plotID, int samples)
            ///               @return Returns true or false whether or not the point in the plot passed is an existing point.)
            /// 
            /// </summary>
            public string isExistingPoint(string guiparticlegraphctrl, string a2, string a3 = "")
                {
                return m_ts.fnGuiParticleGraphCtrl_isExistingPoint(guiparticlegraphctrl, a2, a3);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, resetSelectedPoint, void, 2, 2, ()
            /// 			  This will reset the currently selected point to nothing.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void resetSelectedPoint(string guiparticlegraphctrl = "")
                {
                m_ts.fnGuiParticleGraphCtrl_resetSelectedPoint(guiparticlegraphctrl);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setAutoGraphMax, void, 3, 3, (bool autoMax) 
            /// 			  Set whether the max will automatically be set when adding points 
            /// 			  (ie if you add a value over the current max, the max is increased to that value).
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setAutoGraphMax(string guiparticlegraphctrl, string a2 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setAutoGraphMax(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setAutoRemove, void, 3, 3, (bool autoRemove) 
            /// 			  Set whether or not a point should be deleted when you drag another one over it.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setAutoRemove(string guiparticlegraphctrl, string a2 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setAutoRemove(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setGraphHidden, void, 4, 4, (int plotID, bool isHidden)
            /// 			  Set whether the graph number passed is hidden or not.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setGraphHidden(string guiparticlegraphctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setGraphHidden(guiparticlegraphctrl, a2, a3);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setGraphMax, void, 5, 5, (int plotID, float maxX, float maxY) 
            /// 			  Set the max values of the graph of plotID.
            /// 			  @param plotID The plot to modify
            /// 			  @param maxX,maxY The maximum bound of the value range.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setGraphMax(string guiparticlegraphctrl, string a2, string a3, string a4 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setGraphMax(guiparticlegraphctrl, a2, a3, a4);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setGraphMaxX, void, 4, 4, (int plotID, float maxX)
            /// 			  Set the max X value of the graph of plotID.
            /// 			  @param plotID The plot to modify.
            /// 			  @param maxX The maximum x value.
            /// 			  @return No return Value.)
            /// 
            /// </summary>
            public void setGraphMaxX(string guiparticlegraphctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setGraphMaxX(guiparticlegraphctrl, a2, a3);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setGraphMaxY, void, 4, 4, (int plotID, float maxY)
            /// 			  Set the max Y value of the graph of plotID.
            /// 			  @param plotID The plot to modify.
            /// 			  @param maxY The maximum y value.
            /// 			  @return No return Value.)
            /// 
            /// </summary>
            public void setGraphMaxY(string guiparticlegraphctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setGraphMaxY(guiparticlegraphctrl, a2, a3);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setGraphMin, void, 5, 5, (int plotID, float minX, float minY) 
            /// 			  Set the min values of the graph of plotID.
            /// 			  @param plotID The plot to modify
            /// 			  @param minX,minY The minimum bound of the value range.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setGraphMin(string guiparticlegraphctrl, string a2, string a3, string a4 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setGraphMin(guiparticlegraphctrl, a2, a3, a4);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setGraphMinX, void, 4, 4, (int plotID, float minX) 
            /// 			  Set the min X value of the graph of plotID.
            /// 			  @param plotID The plot to modify.
            /// 			  @param minX The minimum x value.
            /// 			  @return No return Value.)
            /// 
            /// </summary>
            public void setGraphMinX(string guiparticlegraphctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setGraphMinX(guiparticlegraphctrl, a2, a3);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setGraphMinY, void, 4, 4, (int plotID, float minY) 
            /// 			  Set the min Y value of the graph of plotID.
            /// 			  @param plotID The plot to modify.
            /// 			  @param minY The minimum y value.
            /// 			  @return No return Value.)
            /// 
            /// </summary>
            public void setGraphMinY(string guiparticlegraphctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setGraphMinY(guiparticlegraphctrl, a2, a3);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setGraphName, void, 4, 4, (int plotID, string graphName) 
            /// 			  Set the name of the given plot.
            /// 			  @param plotID The plot to modify.
            /// 			  @param graphName The name to set on the plot.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setGraphName(string guiparticlegraphctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setGraphName(guiparticlegraphctrl, a2, a3);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setPointXMovementClamped, void, 3, 3, (bool clamped)
            /// 			  Set whether the x position of the selected graph point should be clamped
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setPointXMovementClamped(string guiparticlegraphctrl, string a2 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setPointXMovementClamped(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setRenderAll, void, 3, 3, (bool renderAll)
            /// 			  Set whether or not a position should be rendered on every point or just the last selected.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setRenderAll(string guiparticlegraphctrl, string a2 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setRenderAll(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setRenderGraphTooltip, void, 3, 3, (bool renderGraphTooltip)
            /// 			  Set whether or not to render the graph tooltip.
            /// 			  @return No return value.)
            /// 
            /// </summary>
            public void setRenderGraphTooltip(string guiparticlegraphctrl, string a2 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setRenderGraphTooltip(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setSelectedPlot, void, 3, 3, (int plotID)
            ///               Set the selected plot (a.k.a. graph).
            /// 			  @return No return value )
            /// 
            /// </summary>
            public void setSelectedPlot(string guiparticlegraphctrl, string a2 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setSelectedPlot(guiparticlegraphctrl, a2);
                }

            /// <summary>
            /// (GuiParticleGraphCtrl, setSelectedPoint, void, 3, 3, (int point)
            ///               Set the selected point on the graph.
            /// 			  @return No return value)
            /// 
            /// </summary>
            public void setSelectedPoint(string guiparticlegraphctrl, string a2 = "")
                {
                m_ts.fnGuiParticleGraphCtrl_setSelectedPoint(guiparticlegraphctrl, a2);
                }
            }

        #endregion

        #region Nested type: GuiPopUpMenuCtrlExObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiPopUpMenuCtrlExObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiPopUpMenuCtrlExObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, add, void, 3, 5, (string name, int idNum, int scheme=0))
            /// 
            /// </summary>
            public void add(string guipopupmenuctrlex, string a2 = "", string a3 = "", string a4 = "")
                {
                m_ts.fnGuiPopUpMenuCtrlEx_add(guipopupmenuctrlex, a2, a3, a4);
                }

            /// <summary>
            /// @brief Add a category to the list.
            /// 
            /// 				   Acts as a separator between entries, allowing for sub-lists
            /// 
            /// 				   @param text Name of the new category)
            /// 
            /// </summary>
            public void addCategory(string guipopupmenuctrlex, string text)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_addCategory(guipopupmenuctrlex, text);
                }

            /// <summary>
            /// @brief Create a new scheme and add it to the list of choices for when a new text entry is added.
            /// 				   @param id Numerical id associated with this scheme
            /// 				   @param fontColor The base text font color. Formatted as \"Red Green Blue\", each a numerical between 0 and 255.
            /// 				   @param fontColorHL Color of text when being highlighted. Formatted as \"Red Green Blue\", each a numerical between 0 and 255.
            /// 				   @param fontColorSel Color of text when being selected. Formatted as \"Red Green Blue\", each a numerical between 0 and 255.)
            /// 
            /// </summary>
            public void addScheme(string guipopupmenuctrlex, int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_addScheme(guipopupmenuctrlex, id, fontColor.AsString(), fontColorHL.AsString(), fontColorSEL.AsString());
                }

            /// <summary>
            /// @brief Clear the popup list.)
            /// 
            /// </summary>
            public void clear(string guipopupmenuctrlex)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_clear(guipopupmenuctrlex);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, clearEntry, void, 3, 3, (S32 entry))
            /// 
            /// </summary>
            public void clearEntry(string guipopupmenuctrlex, string a2 = "")
                {
                m_ts.fnGuiPopUpMenuCtrlEx_clearEntry(guipopupmenuctrlex, a2);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, findText, S32, 3, 3, (string text)
            ///               Returns the id of the first entry containing the specified text or -1 if not found.
            /// 			  @param text String value used for the query
            /// 			  @return Numerical ID of entry containing the text.)
            /// 
            /// </summary>
            public int findText(string guipopupmenuctrlex, string a2 = "")
                {
                return m_ts.fnGuiPopUpMenuCtrlEx_findText(guipopupmenuctrlex, a2);
                }

            /// <summary>
            /// @brief Manually force this control to collapse and close.)
            /// 
            /// </summary>
            public void forceClose(string guipopupmenuctrlex)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_forceClose(guipopupmenuctrlex);
                }

            /// <summary>
            /// @brief Manually for the onAction function, which updates everything in this control.)
            /// 
            /// </summary>
            public void forceOnAction(string guipopupmenuctrlex)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_forceOnAction(guipopupmenuctrlex);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, getColorById, const char*, 3, 3,  
            /// 			  @brief Get color of an entry's box
            /// 			  @param id ID number of entry to query
            /// 			  @return ColorI in the format of \"Red Green Blue Alpha\", each of with is a value between 0 - 255)
            /// 
            /// </summary>
            public string getColorById(string guipopupmenuctrlex, string a2 = "")
                {
                return m_ts.fnGuiPopUpMenuCtrlEx_getColorById(guipopupmenuctrlex, a2);
                }

            /// <summary>
            /// @brief Get the current selection of the menu.
            /// 				   @return Returns the ID of the currently selected entry)
            /// 
            /// </summary>
            public int getSelected(string guipopupmenuctrlex)
                {
                return m_ts.fnGuiPopUpMenuCtrlEx_getSelected(guipopupmenuctrlex);
                }

            /// <summary>
            /// @brief Get the.
            /// 
            /// 				   Detailed description
            /// 
            /// 				   @param param Description
            /// 
            /// 				   @tsexample
            /// 				   // Comment
            /// 				   code();
            /// 				   @endtsexample
            /// 
            /// 				   @return Returns current text in string format)
            /// 
            /// </summary>
            public string getText(string guipopupmenuctrlex)
                {
                return m_ts.fnGuiPopUpMenuCtrlEx_getText(guipopupmenuctrlex);
                }

            /// <summary>
            /// @brief Get the text of an entry based on an ID.
            /// 				   @param id The ID assigned to the entry being queried
            /// 				   @return String contained by the specified entry, NULL if empty or bad ID)
            /// 
            /// </summary>
            public string getTextById(string guipopupmenuctrlex, int id)
                {
                return m_ts.fnGuiPopUpMenuCtrlEx_getTextById(guipopupmenuctrlex, id);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, replaceText, void, 3, 3, 
            /// 			  @brief Flag that causes each new text addition to replace the current entry
            /// 			  @param True to turn on replacing, false to disable it)
            /// 
            /// </summary>
            public void replaceText(string guipopupmenuctrlex, string a2 = "")
                {
                m_ts.fnGuiPopUpMenuCtrlEx_replaceText(guipopupmenuctrlex, a2);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, setEnumContent, void, 4, 4,
            /// 			  @brief This fills the popup with a classrep's field enumeration type info.
            ///               More of a helper function than anything.   If console access to the field list is added, 
            ///               at least for the enumerated types, then this should go away.
            /// 			  @param class Name of the class containing the enum
            /// 			  @param enum Name of the enum value to acces)
            /// 
            /// </summary>
            public void setEnumContent(string guipopupmenuctrlex, string a2, string a3 = "")
                {
                m_ts.fnGuiPopUpMenuCtrlEx_setEnumContent(guipopupmenuctrlex, a2, a3);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, setFirstSelected, void, 2, 3, ([scriptCallback=true])
            /// 			  @hide)
            /// 
            /// </summary>
            public void setFirstSelected(string guipopupmenuctrlex = "", string a2 = "")
                {
                m_ts.fnGuiPopUpMenuCtrlEx_setFirstSelected(guipopupmenuctrlex, a2);
                }

            /// <summary>
            /// @brief Clears selection in the menu.)
            /// 
            /// </summary>
            public void setNoneSelected(string guipopupmenuctrlex, int param)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_setNoneSelected(guipopupmenuctrlex, param);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, setSelected, void, 3, 4, (int id, [scriptCallback=true])
            /// 			  @hide)
            /// 
            /// </summary>
            public void setSelected(string guipopupmenuctrlex, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiPopUpMenuCtrlEx_setSelected(guipopupmenuctrlex, a2, a3);
                }

            /// <summary>
            /// @brief Set the current text to a specified value.
            /// 				   @param text String containing new text to set)
            /// 
            /// </summary>
            public void setText(string guipopupmenuctrlex, string text)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_setText(guipopupmenuctrlex, text);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrlEx, size, S32, 2, 2, 
            /// 			  @brief Get the size of the menu
            /// 			  @return Number of entries in the menu)
            /// 
            /// </summary>
            public int size(string guipopupmenuctrlex = "")
                {
                return m_ts.fnGuiPopUpMenuCtrlEx_size(guipopupmenuctrlex);
                }

            /// <summary>
            /// @brief Sort the list alphabetically.)
            /// 
            /// </summary>
            public void sort(string guipopupmenuctrlex)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_sort(guipopupmenuctrlex);
                }

            /// <summary>
            /// @brief Sort the list by ID.)
            /// 
            /// </summary>
            public void sortID(string guipopupmenuctrlex)
                {
                m_ts.fnGuiPopUpMenuCtrlEx_sortID(guipopupmenuctrlex);
                }
            }

        #endregion

        #region Nested type: GuiPopUpMenuCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiPopUpMenuCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiPopUpMenuCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, add, void, 3, 5, (string name, int idNum, int scheme=0))
            /// 
            /// </summary>
            public void add(string guipopupmenuctrl, string a2 = "", string a3 = "", string a4 = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_add(guipopupmenuctrl, a2, a3, a4);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, addScheme, void, 6, 6, (int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL))
            /// 
            /// </summary>
            public void addScheme(string guipopupmenuctrl, string a2, string a3, string a4, string a5 = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_addScheme(guipopupmenuctrl, a2, a3, a4, a5);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, changeTextById, void, 4, 4, ( int id, string text ) )
            /// 
            /// </summary>
            public void changeTextById(string guipopupmenuctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_changeTextById(guipopupmenuctrl, a2, a3);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, clear, void, 2, 2, Clear the popup list.)
            /// 
            /// </summary>
            public void clear(string guipopupmenuctrl = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_clear(guipopupmenuctrl);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, clearEntry, void, 3, 3, (S32 entry))
            /// 
            /// </summary>
            public void clearEntry(string guipopupmenuctrl, string a2 = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_clearEntry(guipopupmenuctrl, a2);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, findText, S32, 3, 3, (string text)
            ///               Returns the position of the first entry containing the specified text.)
            /// 
            /// </summary>
            public int findText(string guipopupmenuctrl, string a2 = "")
                {
                return m_ts.fnGuiPopUpMenuCtrl_findText(guipopupmenuctrl, a2);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, forceClose, void, 2, 2, )
            /// 
            /// </summary>
            public void forceClose(string guipopupmenuctrl = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_forceClose(guipopupmenuctrl);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, forceOnAction, void, 2, 2, )
            /// 
            /// </summary>
            public void forceOnAction(string guipopupmenuctrl = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_forceOnAction(guipopupmenuctrl);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, getSelected, S32, 2, 2, )
            /// 
            /// </summary>
            public int getSelected(string guipopupmenuctrl = "")
                {
                return m_ts.fnGuiPopUpMenuCtrl_getSelected(guipopupmenuctrl);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, getText, const char*, 2, 2, )
            /// 
            /// </summary>
            public string getText(string guipopupmenuctrl = "")
                {
                return m_ts.fnGuiPopUpMenuCtrl_getText(guipopupmenuctrl);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, getTextById, const char*, 3, 3,  (int id))
            /// 
            /// </summary>
            public string getTextById(string guipopupmenuctrl, string a2 = "")
                {
                return m_ts.fnGuiPopUpMenuCtrl_getTextById(guipopupmenuctrl, a2);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, replaceText, void, 3, 3, (bool doReplaceText))
            /// 
            /// </summary>
            public void replaceText(string guipopupmenuctrl, string a2 = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_replaceText(guipopupmenuctrl, a2);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, setEnumContent, void, 4, 4, (string class, string enum)
            ///               This fills the popup with a classrep's field enumeration type info.
            ///               More of a helper function than anything.   If console access to the field list is added, 
            ///               at least for the enumerated types, then this should go away..)
            /// 
            /// </summary>
            public void setEnumContent(string guipopupmenuctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_setEnumContent(guipopupmenuctrl, a2, a3);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, setFirstSelected, void, 2, 3, ([scriptCallback=true]))
            /// 
            /// </summary>
            public void setFirstSelected(string guipopupmenuctrl = "", string a2 = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_setFirstSelected(guipopupmenuctrl, a2);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, setNoneSelected, void, 2, 2, )
            /// 
            /// </summary>
            public void setNoneSelected(string guipopupmenuctrl = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_setNoneSelected(guipopupmenuctrl);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, setSelected, void, 3, 4, (int id, [scriptCallback=true]))
            /// 
            /// </summary>
            public void setSelected(string guipopupmenuctrl, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_setSelected(guipopupmenuctrl, a2, a3);
                }

            /// <summary>
            /// ( GuiPopUpMenuCtrl, size, S32, 2, 2, Get the size of the menu - the number of entries in it.)
            /// 
            /// </summary>
            public int size(string guipopupmenuctrl = "")
                {
                return m_ts.fnGuiPopUpMenuCtrl_size(guipopupmenuctrl);
                }

            /// <summary>
            /// (GuiPopUpMenuCtrl, sort, void, 2, 2, Sort the list alphabetically.)
            /// 
            /// </summary>
            public void sort(string guipopupmenuctrl = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_sort(guipopupmenuctrl);
                }

            /// <summary>
            /// (GuiPopUpMenuCtrl, sortID, void, 2, 2, Sort the list by ID.)
            /// 
            /// </summary>
            public void sortID(string guipopupmenuctrl = "")
                {
                m_ts.fnGuiPopUpMenuCtrl_sortID(guipopupmenuctrl);
                }
            }

        #endregion

        #region Nested type: GuiProgressBitmapCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiProgressBitmapCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiProgressBitmapCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Set the bitmap to use for rendering the progress bar.
            ///    @param filename ~Path to the bitmap file.
            ///    @note Directly assign to #bitmap rather than using this method.
            ///    @see GuiProgressBitmapCtrl::setBitmap )
            /// 
            /// </summary>
            public void setBitmap(string guiprogressbitmapctrl, string filename)
                {
                m_ts.fnGuiProgressBitmapCtrl_setBitmap(guiprogressbitmapctrl, filename);
                }
            }

        #endregion

        #region Nested type: GuiRoadEditorCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiRoadEditorCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiRoadEditorCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, deleteNode, void, 2, 2, deleteNode() )
            /// 
            /// </summary>
            public void deleteNode(string guiroadeditorctrl = "")
                {
                m_ts.fnGuiRoadEditorCtrl_deleteNode(guiroadeditorctrl);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, deleteRoad, void, 2, 2,  )
            /// 
            /// </summary>
            public void deleteRoad(string guiroadeditorctrl = "")
                {
                m_ts.fnGuiRoadEditorCtrl_deleteRoad(guiroadeditorctrl);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, getMode, const char*, 2, 2,  )
            /// 
            /// </summary>
            public string getMode(string guiroadeditorctrl = "")
                {
                return m_ts.fnGuiRoadEditorCtrl_getMode(guiroadeditorctrl);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, getNodePosition, const char*, 2, 2,  )
            /// 
            /// </summary>
            public string getNodePosition(string guiroadeditorctrl = "")
                {
                return m_ts.fnGuiRoadEditorCtrl_getNodePosition(guiroadeditorctrl);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, getNodeWidth, F32, 2, 2,  )
            /// 
            /// </summary>
            public float getNodeWidth(string guiroadeditorctrl = "")
                {
                return m_ts.fnGuiRoadEditorCtrl_getNodeWidth(guiroadeditorctrl);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, getSelectedNode, S32, 2, 2,  )
            /// 
            /// </summary>
            public int getSelectedNode(string guiroadeditorctrl = "")
                {
                return m_ts.fnGuiRoadEditorCtrl_getSelectedNode(guiroadeditorctrl);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, getSelectedRoad, const char*, 2, 2,  )
            /// 
            /// </summary>
            public string getSelectedRoad(string guiroadeditorctrl = "")
                {
                return m_ts.fnGuiRoadEditorCtrl_getSelectedRoad(guiroadeditorctrl);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, setNodePosition, void, 3, 3,  )
            /// 
            /// </summary>
            public void setNodePosition(string guiroadeditorctrl, string a2 = "")
                {
                m_ts.fnGuiRoadEditorCtrl_setNodePosition(guiroadeditorctrl, a2);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, setNodeWidth, void, 3, 3,  )
            /// 
            /// </summary>
            public void setNodeWidth(string guiroadeditorctrl, string a2 = "")
                {
                m_ts.fnGuiRoadEditorCtrl_setNodeWidth(guiroadeditorctrl, a2);
                }

            /// <summary>
            /// ( GuiRoadEditorCtrl, setSelectedRoad, void, 2, 3,  )
            /// 
            /// </summary>
            public void setSelectedRoad(string guiroadeditorctrl = "", string a2 = "")
                {
                m_ts.fnGuiRoadEditorCtrl_setSelectedRoad(guiroadeditorctrl, a2);
                }
            }

        #endregion

        #region Nested type: GuiRolloutCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiRolloutCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiRolloutCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Collapse the rollout if it is currently expanded.  This will make the rollout's child control invisible.
            ///    @note The rollout will animate to collapsed state.  To instantly collapse without animation, use instantCollapse(). )
            /// 
            /// </summary>
            public void collapse(string guirolloutctrl)
                {
                m_ts.fnGuiRolloutCtrl_collapse(guirolloutctrl);
                }

            /// <summary>
            /// Expand the rollout if it is currently collapsed.  This will make the rollout's child control visible.
            ///    @note The rollout will animate to expanded state.  To instantly expand without animation, use instantExpand(). )
            /// 
            /// </summary>
            public void expand(string guirolloutctrl)
                {
                m_ts.fnGuiRolloutCtrl_expand(guirolloutctrl);
                }

            /// <summary>
            /// Instantly collapse the rollout without animation.  To smoothly slide the rollout to collapsed state, use collapse(). )
            /// 
            /// </summary>
            public void instantCollapse(string guirolloutctrl)
                {
                m_ts.fnGuiRolloutCtrl_instantCollapse(guirolloutctrl);
                }

            /// <summary>
            /// Instantly expand the rollout without animation.  To smoothly slide the rollout to expanded state, use expand(). )
            /// 
            /// </summary>
            public void instantExpand(string guirolloutctrl)
                {
                m_ts.fnGuiRolloutCtrl_instantExpand(guirolloutctrl);
                }

            /// <summary>
            /// Determine whether the rollout is currently expanded, i.e. whether the child control is visible.
            ///    @return True if the rollout is expanded, false if not. )
            /// 
            /// </summary>
            public bool isExpanded(string guirolloutctrl)
                {
                return m_ts.fnGuiRolloutCtrl_isExpanded(guirolloutctrl);
                }

            /// <summary>
            /// Resize the rollout to exactly fit around its child control.  This can be used to manually trigger a recomputation of 
            ///    the rollout size. )
            /// 
            /// </summary>
            public void sizeToContents(string guirolloutctrl)
                {
                m_ts.fnGuiRolloutCtrl_sizeToContents(guirolloutctrl);
                }

            /// <summary>
            /// Toggle the current collapse state of the rollout.  If it is currently expanded, then collapse it.  If it 
            ///    is currently collapsed, then expand it. )
            /// 
            /// </summary>
            public void toggleCollapse(string guirolloutctrl)
                {
                m_ts.fnGuiRolloutCtrl_toggleCollapse(guirolloutctrl);
                }

            /// <summary>
            /// Toggle the current expansion state of the rollout  If it is currently expanded, then collapse it.  If it 
            ///    is currently collapsed, then expand it.
            ///    @param instant If true, the rollout will toggle its state without animation.  Otherwise, the rollout will 
            ///       smoothly slide into the opposite state. )
            /// 
            /// </summary>
            public void toggleExpanded(string guirolloutctrl, bool instantly)
                {
                m_ts.fnGuiRolloutCtrl_toggleExpanded(guirolloutctrl, instantly);
                }
            }

        #endregion

        #region Nested type: GuiScrollCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiScrollCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiScrollCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Refresh sizing and positioning of child controls. )
            /// 
            /// </summary>
            public void computeSizes(string guiscrollctrl)
                {
                m_ts.fnGuiScrollCtrl_computeSizes(guiscrollctrl);
                }

            /// <summary>
            /// Get the current coordinates of the scrolled content.
            ///    @return The current position of the scrolled content. )
            /// 
            /// </summary>
            public Point2I getScrollPosition(string guiscrollctrl)
                {
                return new Point2I(m_ts.fnGuiScrollCtrl_getScrollPosition(guiscrollctrl));
                }

            /// <summary>
            /// Get the current X coordinate of the scrolled content.
            ///    @return The current X coordinate of the scrolled content. )
            /// 
            /// </summary>
            public int getScrollPositionX(string guiscrollctrl)
                {
                return m_ts.fnGuiScrollCtrl_getScrollPositionX(guiscrollctrl);
                }

            /// <summary>
            /// Get the current Y coordinate of the scrolled content.
            ///    @return The current Y coordinate of the scrolled content. )
            /// 
            /// </summary>
            public int getScrollPositionY(string guiscrollctrl)
                {
                return m_ts.fnGuiScrollCtrl_getScrollPositionY(guiscrollctrl);
                }

            /// <summary>
            /// Scroll all the way to the bottom of the vertical scrollbar and the left of the horizontal bar. )
            /// 
            /// </summary>
            public void scrollToBottom(string guiscrollctrl)
                {
                m_ts.fnGuiScrollCtrl_scrollToBottom(guiscrollctrl);
                }

            /// <summary>
            /// Scroll the control so that the given child @a control is visible.
            ///    @param control A child control. )
            /// 
            /// </summary>
            public void scrollToObject(string guiscrollctrl, string control)
                {
                m_ts.fnGuiScrollCtrl_scrollToObject(guiscrollctrl, control);
                }

            /// <summary>
            /// Scroll all the way to the top of the vertical and left of the horizontal scrollbar. )
            /// 
            /// </summary>
            public void scrollToTop(string guiscrollctrl)
                {
                m_ts.fnGuiScrollCtrl_scrollToTop(guiscrollctrl);
                }

            /// <summary>
            /// Set the position of the scrolled content.
            ///    @param x Position on X axis.
            ///    @param y Position on y axis. )
            /// 
            /// </summary>
            public void setScrollPosition(string guiscrollctrl, int x, int y)
                {
                m_ts.fnGuiScrollCtrl_setScrollPosition(guiscrollctrl, x, y);
                }
            }

        #endregion

        #region Nested type: GuiShapeEdPreviewObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiShapeEdPreviewObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiShapeEdPreviewObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Add a new thread (initially without any sequence set) )
            /// 
            /// </summary>
            public void addThread(string guishapeedpreview)
                {
                m_ts.fnGuiShapeEdPreview_addThread(guishapeedpreview);
                }

            /// <summary>
            /// Compute the bounding box of the shape using the current detail and node transforms
            ///    @return the bounding box \"min.x min.y min.z max.x max.y max.z\" )
            /// 
            /// </summary>
            public Box3F computeShapeBounds(string guishapeedpreview)
                {
                return new Box3F(m_ts.fnGuiShapeEdPreview_computeShapeBounds(guishapeedpreview));
                }

            /// <summary>
            /// Export the current shape and all mounted objects to COLLADA (.dae).
            ///    Note that animation is not exported, and all geometry is combined into a 
            ///    single mesh.
            ///    @param path Destination filename )
            /// 
            /// </summary>
            public void exportToCollada(string guishapeedpreview, string path)
                {
                m_ts.fnGuiShapeEdPreview_exportToCollada(guishapeedpreview, path);
                }

            /// <summary>
            /// Adjust the camera position and zoom to fit the shape within the view. )
            /// 
            /// </summary>
            public void fitToShape(string guishapeedpreview)
                {
                m_ts.fnGuiShapeEdPreview_fitToShape(guishapeedpreview);
                }

            /// <summary>
            /// Return whether the named object is currently hidden )
            /// 
            /// </summary>
            public bool getMeshHidden(string guishapeedpreview, string name)
                {
                return m_ts.fnGuiShapeEdPreview_getMeshHidden(guishapeedpreview, name);
                }

            /// <summary>
            /// Get the playback direction of the sequence playing on this mounted shape
            ///    @param slot mounted shape slot
            ///    @return direction of the sequence (-1=reverse, 0=paused, 1=forward) )
            /// 
            /// </summary>
            public float getMountThreadDir(string guishapeedpreview, int slot)
                {
                return m_ts.fnGuiShapeEdPreview_getMountThreadDir(guishapeedpreview, slot);
                }

            /// <summary>
            /// Get the playback position of the sequence playing on this mounted shape
            ///    @param slot mounted shape slot
            ///    @return playback position of the sequence (0-1) )
            /// 
            /// </summary>
            public float getMountThreadPos(string guishapeedpreview, int slot)
                {
                return m_ts.fnGuiShapeEdPreview_getMountThreadPos(guishapeedpreview, slot);
                }

            /// <summary>
            /// Get the name of the sequence playing on this mounted shape
            ///    @param slot mounted shape slot
            ///    @return name of the sequence (if any) )
            /// 
            /// </summary>
            public string getMountThreadSequence(string guishapeedpreview, int slot)
                {
                return m_ts.fnGuiShapeEdPreview_getMountThreadSequence(guishapeedpreview, slot);
                }

            /// <summary>
            /// Get the number of threads
            ///    @return the number of threads )
            /// 
            /// </summary>
            public int getThreadCount(string guishapeedpreview)
                {
                return m_ts.fnGuiShapeEdPreview_getThreadCount(guishapeedpreview);
                }

            /// <summary>
            /// Get the name of the sequence assigned to the active thread )
            /// 
            /// </summary>
            public string getThreadSequence(string guishapeedpreview)
                {
                return m_ts.fnGuiShapeEdPreview_getThreadSequence(guishapeedpreview);
                }

            /// <summary>
            /// Mount a shape onto the main shape at the specified node
            ///    @param shapePath path to the shape to mount
            ///    @param nodeName name of the node on the main shape to mount to
            ///    @param type type of mounting to use (Object, Image or Wheel)
            ///    @param slot mount slot )
            /// 
            /// </summary>
            public bool mountShape(string guishapeedpreview, string shapePath, string nodeName, string type, int slot)
                {
                return m_ts.fnGuiShapeEdPreview_mountShape(guishapeedpreview, shapePath, nodeName, type, slot);
                }

            /// <summary>
            /// Refresh the shape (used when the shape meshes or nodes have been added or removed) )
            /// 
            /// </summary>
            public void refreshShape(string guishapeedpreview)
                {
                m_ts.fnGuiShapeEdPreview_refreshShape(guishapeedpreview);
                }

            /// <summary>
            /// Refreshes thread sequences (in case of removed/renamed sequences )
            /// 
            /// </summary>
            public void refreshThreadSequences(string guishapeedpreview)
                {
                m_ts.fnGuiShapeEdPreview_refreshThreadSequences(guishapeedpreview);
                }

            /// <summary>
            /// Removes the specifed thread
            ///    @param slot index of the thread to remove )
            /// 
            /// </summary>
            public void removeThread(string guishapeedpreview, int slot)
                {
                m_ts.fnGuiShapeEdPreview_removeThread(guishapeedpreview, slot);
                }

            /// <summary>
            /// Show or hide all objects in the shape )
            /// 
            /// </summary>
            public void setAllMeshesHidden(string guishapeedpreview, bool hidden)
                {
                m_ts.fnGuiShapeEdPreview_setAllMeshesHidden(guishapeedpreview, hidden);
                }

            /// <summary>
            /// Show or hide the named object in the shape )
            /// 
            /// </summary>
            public void setMeshHidden(string guishapeedpreview, string name, bool hidden)
                {
                m_ts.fnGuiShapeEdPreview_setMeshHidden(guishapeedpreview, name, hidden);
                }

            /// <summary>
            /// Sets the model to be displayed in this control
            ///    @param shapeName Name of the model to display.
            ///    @return True if the model was loaded successfully, false otherwise. )
            /// 
            /// </summary>
            public bool setModel(string guishapeedpreview, string shapePath)
                {
                return m_ts.fnGuiShapeEdPreview_setModel(guishapeedpreview, shapePath);
                }

            /// <summary>
            /// Set the node a shape is mounted to.
            ///    @param slot mounted shape slot
            ///    @param nodename name of the node to mount to )
            /// 
            /// </summary>
            public void setMountNode(string guishapeedpreview, int slot, string nodeName)
                {
                m_ts.fnGuiShapeEdPreview_setMountNode(guishapeedpreview, slot, nodeName);
                }

            /// <summary>
            /// Set the playback direction of the shape mounted in the specified slot
            ///    @param slot mounted shape slot
            ///    @param dir playback direction (-1=backwards, 0=paused, 1=forwards) )
            /// 
            /// </summary>
            public void setMountThreadDir(string guishapeedpreview, int slot, float dir)
                {
                m_ts.fnGuiShapeEdPreview_setMountThreadDir(guishapeedpreview, slot, dir);
                }

            /// <summary>
            /// Set the sequence position of the shape mounted in the specified slot
            ///    @param slot mounted shape slot
            ///    @param pos sequence position (0-1) )
            /// 
            /// </summary>
            public void setMountThreadPos(string guishapeedpreview, int slot, float pos)
                {
                m_ts.fnGuiShapeEdPreview_setMountThreadPos(guishapeedpreview, slot, pos);
                }

            /// <summary>
            /// Set the sequence to play for the shape mounted in the specified slot
            ///    @param slot mounted shape slot
            ///    @param name name of the sequence to play )
            /// 
            /// </summary>
            public void setMountThreadSequence(string guishapeedpreview, int slot, string name)
                {
                m_ts.fnGuiShapeEdPreview_setMountThreadSequence(guishapeedpreview, slot, name);
                }

            /// <summary>
            /// Set the camera orbit position
            ///    @param pos Position in the form \"x y z\" )
            /// 
            /// </summary>
            public void setOrbitPos(string guishapeedpreview, Point3F pos)
                {
                m_ts.fnGuiShapeEdPreview_setOrbitPos(guishapeedpreview, pos.AsString());
                }

            /// <summary>
            /// Sets the sequence to play for the active thread.
            ///    @param name name of the sequence to play
            ///    @param duration transition duration (0 for no transition)
            ///    @param pos position in the new sequence to transition to
            ///    @param play if true, the new sequence will play during the transition )
            /// 
            /// </summary>
            public void setThreadSequence(string guishapeedpreview, string name, float duration, float pos, bool play)
                {
                m_ts.fnGuiShapeEdPreview_setThreadSequence(guishapeedpreview, name, duration, pos, play);
                }

            /// <summary>
            /// Set the time scale of all threads
            ///    @param scale new time scale value )
            /// 
            /// </summary>
            public void setTimeScale(string guishapeedpreview, float scale)
                {
                m_ts.fnGuiShapeEdPreview_setTimeScale(guishapeedpreview, scale);
                }

            /// <summary>
            /// Unmount all shapes )
            /// 
            /// </summary>
            public void unmountAll(string guishapeedpreview)
                {
                m_ts.fnGuiShapeEdPreview_unmountAll(guishapeedpreview);
                }

            /// <summary>
            /// Unmount the shape in the specified slot
            ///    @param slot mounted shape slot )
            /// 
            /// </summary>
            public void unmountShape(string guishapeedpreview, int slot)
                {
                m_ts.fnGuiShapeEdPreview_unmountShape(guishapeedpreview, slot);
                }

            /// <summary>
            /// Refresh the shape node transforms (used when a node transform has been modified externally) )
            /// 
            /// </summary>
            public void updateNodeTransforms(string guishapeedpreview)
                {
                m_ts.fnGuiShapeEdPreview_updateNodeTransforms(guishapeedpreview);
                }
            }

        #endregion

        #region Nested type: GuiSliderCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiSliderCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiSliderCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get the current value of the slider based on the position of the thumb.
            ///    @return Slider position (from range.x to range.y). )
            /// 
            /// </summary>
            public float getValue(string guisliderctrl)
                {
                return m_ts.fnGuiSliderCtrl_getValue(guisliderctrl);
                }

            /// <summary>
            /// Returns true if the thumb is currently being dragged by the user.  This method is mainly useful 
            ///    for scrubbing type sliders where the slider position is sync'd to a changing value.  When the 
            ///    user is dragging the thumb, however, the sync'ing should pause and not get in the way of the user. )
            /// 
            /// </summary>
            public bool isThumbBeingDragged(string guisliderctrl)
                {
                return m_ts.fnGuiSliderCtrl_isThumbBeingDragged(guisliderctrl);
                }

            /// <summary>
            /// Set position of the thumb on the slider.
            ///    @param pos New slider position (from range.x to range.y)
            ///    @param doCallback If true, the altCommand callback will be invoked )
            /// 
            /// </summary>
            public void setValue(string guisliderctrl, float pos, bool doCallback)
                {
                m_ts.fnGuiSliderCtrl_setValue(guisliderctrl, pos, doCallback);
                }
            }

        #endregion

        #region Nested type: GuiStackControlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiStackControlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiStackControlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Prevents control from restacking - useful when adding or removing child controls
            ///    @param freeze True to freeze the control, false to unfreeze it
            ///    @tsexample
            ///    %stackCtrl.freeze(true);
            ///    // add controls to stack
            ///    %stackCtrl.freeze(false);
            ///    @endtsexample )
            /// 
            /// </summary>
            public void freeze(string guistackcontrol, bool freeze)
                {
                m_ts.fnGuiStackControl_freeze(guistackcontrol, freeze);
                }

            /// <summary>
            /// Return whether or not this control is frozen )
            /// 
            /// </summary>
            public bool isFrozen(string guistackcontrol)
                {
                return m_ts.fnGuiStackControl_isFrozen(guistackcontrol);
                }

            /// <summary>
            /// Restack the child controls. )
            /// 
            /// </summary>
            public void updateStack(string guistackcontrol)
                {
                m_ts.fnGuiStackControl_updateStack(guistackcontrol);
                }
            }

        #endregion

        #region Nested type: GuiSwatchButtonCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiSwatchButtonCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiSwatchButtonCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Set the color of the swatch control.
            ///    @param newColor The new color string given to the swatch control in float format \"r g b a\".
            ///    @note It's also important to note that when setColor is called causes
            ///    the control's altCommand field to be executed. )
            /// 
            /// </summary>
            public void setColor(string guiswatchbuttonctrl, string newColor)
                {
                m_ts.fnGuiSwatchButtonCtrl_setColor(guiswatchbuttonctrl, newColor);
                }
            }

        #endregion

        #region Nested type: GuiTSCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTSCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTSCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Given the camera's current FOV, get the distance from the camera's viewpoint at which the given radius will fit in the render area.
            ///    @param radius Radius in world-space units which should fit in the view.
            ///    @return The distance from the viewpoint at which the given radius would be fully visible. )
            /// 
            /// </summary>
            public float calculateViewDistance(string guitsctrl, float radius)
                {
                return m_ts.fnGuiTSCtrl_calculateViewDistance(guitsctrl, radius);
                }

            /// <summary>
            /// Get the ratio between world-space units and pixels.
            ///    @return The amount of world-space units covered by the extent of a single pixel. )
            /// 
            /// </summary>
            public Point2F getWorldToScreenScale(string guitsctrl)
                {
                return new Point2F(m_ts.fnGuiTSCtrl_getWorldToScreenScale(guitsctrl));
                }

            /// <summary>
            /// Transform world-space coordinates to screen-space (x, y, depth) coordinates.
            ///    @param worldPosition The world-space position to transform to screen-space.
            ///    @return The  )
            /// 
            /// </summary>
            public Point3F project(string guitsctrl, Point3F worldPosition)
                {
                return new Point3F(m_ts.fnGuiTSCtrl_project(guitsctrl, worldPosition.AsString()));
                }

            /// <summary>
            /// Transform 3D screen-space coordinates (x, y, depth) to world space.
            ///    This method can be, for example, used to find the world-space position relating to the current mouse cursor position.
            ///    @param screenPosition The x/y position on the screen plus the depth from the screen-plane outwards.
            ///    @return The world-space position corresponding to the given screen-space coordinates. )
            /// 
            /// </summary>
            public Point3F unproject(string guitsctrl, Point3F screenPosition)
                {
                return new Point3F(m_ts.fnGuiTSCtrl_unproject(guitsctrl, screenPosition.AsString()));
                }
            }

        #endregion

        #region Nested type: GuiTabBookCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTabBookCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTabBookCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            ///  ),
            ///    Add a new tab page to the control.
            ///    @param title Title text for the tab page header. )
            /// 
            /// </summary>
            public void addPage(string guitabbookctrl, string title)
                {
                m_ts.fnGuiTabBookCtrl_addPage(guitabbookctrl, title);
                }

            /// <summary>
            /// Get the index of the currently selected tab page.
            ///    @return Index of the selected tab page or -1 if no tab page is selected. )
            /// 
            /// </summary>
            public int getSelectedPage(string guitabbookctrl)
                {
                return m_ts.fnGuiTabBookCtrl_getSelectedPage(guitabbookctrl);
                }

            /// <summary>
            /// Set the selected tab page.
            ///    @param index Index of the tab page. )
            /// 
            /// </summary>
            public void selectPage(string guitabbookctrl, int index)
                {
                m_ts.fnGuiTabBookCtrl_selectPage(guitabbookctrl, index);
                }
            }

        #endregion

        #region Nested type: GuiTabPageCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTabPageCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTabPageCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Select this page in its tab book. )
            /// 
            /// </summary>
            public void select(string guitabpagectrl)
                {
                m_ts.fnGuiTabPageCtrl_select(guitabpagectrl);
                }
            }

        #endregion

        #region Nested type: GuiTextCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTextCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTextCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Sets the text in the control.
            ///    @param text Text to display in the control.
            ///    @tsexample
            ///    // Set the text to show in the control
            ///    %text = \"Gideon - Destroyer of World\";
            ///    // Inform the GuiTextCtrl control to change its text to the defined value
            ///    %thisGuiTextCtrl.setText(%text);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setText(string guitextctrl, string text)
                {
                m_ts.fnGuiTextCtrl_setText(guitextctrl, text);
                }

            /// <summary>
            /// @brief Maps the text ctrl to a variable used in localization, rather than raw text.
            ///    @param textID Name of variable text should be mapped to
            ///    @tsexample
            ///    // Inform the GuiTextCtrl control of the textID to use
            ///    %thisGuiTextCtrl.setTextID(\"STR_QUIT\");
            ///    @endtsexample
            ///    @see GuiControl
            ///    @see Localization)
            /// 
            /// </summary>
            public void setTextID(string guitextctrl, string textID)
                {
                m_ts.fnGuiTextCtrl_setTextID(guitextctrl, textID);
                }
            }

        #endregion

        #region Nested type: GuiTextEditCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTextEditCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTextEditCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Unselects all selected text in the control.
            ///    @tsexample
            ///    // Inform the control to unselect all of its selected text
            ///    %thisGuiTextEditCtrl.clearSelectedText();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void clearSelectedText(string guitexteditctrl)
                {
                m_ts.fnGuiTextEditCtrl_clearSelectedText(guitexteditctrl);
                }

            /// <summary>
            /// @brief Force a validation to occur.
            ///    @tsexample
            ///    // Inform the control to force a validation of its text.
            ///    %thisGuiTextEditCtrl.forceValidateText();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void forceValidateText(string guitexteditctrl)
                {
                m_ts.fnGuiTextEditCtrl_forceValidateText(guitexteditctrl);
                }

            /// <summary>
            /// @brief Returns the current position of the text cursor in the control.
            ///    @tsexample
            ///    // Acquire the cursor position in the control
            ///    %position = %thisGuiTextEditCtrl.getCursorPost();
            ///    @endtsexample
            ///    @return Text cursor position within the control.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getCursorPos(string guitexteditctrl)
                {
                return m_ts.fnGuiTextEditCtrl_getCursorPos(guitexteditctrl);
                }

            /// <summary>
            /// @brief Acquires the current text displayed in this control.
            ///    @tsexample
            ///    // Acquire the value of the text control.
            ///    %text = %thisGuiTextEditCtrl.getText();
            ///    @endtsexample
            ///    @return The current text within the control.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getText(string guitexteditctrl)
                {
                return m_ts.fnGuiTextEditCtrl_getText(guitexteditctrl);
                }

            /// <summary>
            /// @brief Checks to see if all text in the control has been selected.
            ///    @tsexample
            ///    // Check to see if all text has been selected or not.
            ///    %allSelected = %thisGuiTextEditCtrl.isAllTextSelected();
            ///    @endtsexample
            ///    @return True if all text in the control is selected, otherwise false.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public bool isAllTextSelected(string guitexteditctrl)
                {
                return m_ts.fnGuiTextEditCtrl_isAllTextSelected(guitexteditctrl);
                }

            /// <summary>
            /// @brief Selects all text within the control.
            ///    @tsexample
            ///    // Inform the control to select all of its text.
            ///    %thisGuiTextEditCtrl.selectAllText();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void selectAllText(string guitexteditctrl)
                {
                m_ts.fnGuiTextEditCtrl_selectAllText(guitexteditctrl);
                }

            /// <summary>
            /// @brief Sets the text cursor at the defined position within the control.
            ///    @param position Text position to set the text cursor.
            ///    @tsexample
            ///    // Define the cursor position
            ///    %position = \"12\";
            ///    // Inform the GuiTextEditCtrl control to place the text cursor at the defined position
            ///    %thisGuiTextEditCtrl.setCursorPos(%position);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setCursorPos(string guitexteditctrl, int position)
                {
                m_ts.fnGuiTextEditCtrl_setCursorPos(guitexteditctrl, position);
                }

            /// <summary>
            /// @brief Sets the text in the control.
            ///    @param text Text to place in the control.
            ///    @tsexample
            ///    // Define the text to display
            ///    %text = \"Text!\"
            ///    // Inform the GuiTextEditCtrl to display the defined text
            ///    %thisGuiTextEditCtrl.setText(%text);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setText(string guitexteditctrl, string text)
                {
                m_ts.fnGuiTextEditCtrl_setText(guitexteditctrl, text);
                }
            }

        #endregion

        #region Nested type: GuiTextListCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTextListCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTextListCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ,-1),
            ///    @brief Adds a new row at end of the list with the defined id and text.
            ///    If index is used, then the new row is inserted at the row location of 'index'.
            ///    @param id Id of the new row.
            ///    @param text Text to display at the new row.
            ///    @param index Index to insert the new row at. If not used, new row will be placed at the end of the list.
            ///    @tsexample
            ///    // Define the id
            ///    %id = \"4\";
            ///    // Define the text to display
            ///    %text = \"Display Text\"
            ///    // Define the index (optional)
            ///    %index = \"2\"
            ///    // Inform the GuiTextListCtrl control to add the new row with the defined information.
            ///    %rowIndex = %thisGuiTextListCtrl.addRow(%id,%text,%index);
            ///    @endtsexample
            ///    @return Returns the row index of the new row. If 'index' was defined, then this just returns the number of rows in the list.
            ///    @see References)
            /// 
            /// </summary>
            public int addRow(string guitextlistctrl, int id, string text, int index)
                {
                return m_ts.fnGuiTextListCtrl_addRow(guitextlistctrl, id, text, index);
                }

            /// <summary>
            /// @brief Clear the list.
            ///    @tsexample
            ///    // Inform the GuiTextListCtrl control to clear its contents
            ///    %thisGuiTextListCtrl.clear();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void clear(string guitextlistctrl)
                {
                m_ts.fnGuiTextListCtrl_clear(guitextlistctrl);
                }

            /// <summary>
            /// @brief Set the selection to nothing.
            ///    @tsexample
            ///    // Deselect anything that is currently selected
            ///    %thisGuiTextListCtrl.clearSelection();
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void clearSelection(string guitextlistctrl)
                {
                m_ts.fnGuiTextListCtrl_clearSelection(guitextlistctrl);
                }

            /// <summary>
            /// @brief Find needle in the list, and return the row number it was found in.
            ///    @param needle Text to find in the list.
            ///    @tsexample
            ///    // Define the text to find in the list
            ///    %needle = \"Text To Find\";
            ///    // Request the row number that contains the defined text to find
            ///    %rowNumber = %thisGuiTextListCtrl.findTextIndex(%needle);
            ///    @endtsexample
            ///    @return Row number that the defined text was found in,
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int findTextIndex(string guitextlistctrl, string needle)
                {
                return m_ts.fnGuiTextListCtrl_findTextIndex(guitextlistctrl, needle);
                }

            /// <summary>
            /// @brief Get the row ID for an index.
            ///    @param index Index to get the RowID at
            ///    @tsexample
            ///    // Define the index
            ///    %index = \"3\";
            ///    // Request the row ID at the defined index
            ///    %rowId = %thisGuiTextListCtrl.getRowId(%index);
            ///    @endtsexample
            ///    @return RowId at the defined index.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getRowId(string guitextlistctrl, int index)
                {
                return m_ts.fnGuiTextListCtrl_getRowId(guitextlistctrl, index);
                }

            /// <summary>
            /// @brief Get the row number for a specified id.
            ///    @param id Id to get the row number at
            ///    @tsexample
            ///    // Define the id
            ///    %id = \"4\";
            ///    // Request the row number from the GuiTextListCtrl control at the defined id.
            ///    %rowNumber = %thisGuiTextListCtrl.getRowNumById(%id);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getRowNumById(string guitextlistctrl, int id)
                {
                return m_ts.fnGuiTextListCtrl_getRowNumById(guitextlistctrl, id);
                }

            /// <summary>
            /// @brief Get the text of the row with the specified index.
            ///    @param index Row index to acquire the text at.
            ///    @tsexample
            ///    // Define the row index
            ///    %index = \"5\";
            ///    // Request the text from the row at the defined index
            ///    %rowText = %thisGuiTextListCtrl.getRowText(%index);
            ///    @endtsexample
            ///    @return Text at the defined row index.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getRowText(string guitextlistctrl, int index)
                {
                return m_ts.fnGuiTextListCtrl_getRowText(guitextlistctrl, index);
                }

            /// <summary>
            /// @brief Get the text of a row with the specified id.
            ///    @tsexample
            ///    // Define the id
            ///    %id = \"4\";
            ///    // Inform the GuiTextListCtrl control to return the text at the defined row id
            ///    %rowText = %thisGuiTextListCtrl.getRowTextById(%id);
            ///    @endtsexample
            ///    @return Row text at the requested row id.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public string getRowTextById(string guitextlistctrl, int id)
                {
                return m_ts.fnGuiTextListCtrl_getRowTextById(guitextlistctrl, id);
                }

            /// <summary>
            /// @brief Get the ID of the currently selected item.
            ///    @tsexample
            ///    // Acquire the ID of the selected item in the list.
            ///    %id = %thisGuiTextListCtrl.getSelectedId();
            ///    @endtsexample
            ///    @return The id of the selected item in the list.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getSelectedId(string guitextlistctrl)
                {
                return m_ts.fnGuiTextListCtrl_getSelectedId(guitextlistctrl);
                }

            /// <summary>
            /// @brief Returns the selected row index (not the row ID).
            ///    @tsexample
            ///    // Acquire the selected row index
            ///    %rowIndex = %thisGuiTextListCtrl.getSelectedRow();
            ///    @endtsexample
            ///    @return Index of the selected row
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int getSelectedRow(string guitextlistctrl)
                {
                return m_ts.fnGuiTextListCtrl_getSelectedRow(guitextlistctrl);
                }

            /// <summary>
            /// @brief Check if the specified row is currently active or not.
            ///    @param rowNum Row number to check the active state.
            ///    @tsexample
            ///    // Define the row number
            ///    %rowNum = \"5\";
            ///    // Request the active state of the defined row number from the GuiTextListCtrl control.
            ///    %rowActiveState = %thisGuiTextListCtrl.isRowActive(%rowNum);
            ///    @endtsexample
            ///    @return Active state of the defined row number.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public bool isRowActive(string guitextlistctrl, int rowNum)
                {
                return m_ts.fnGuiTextListCtrl_isRowActive(guitextlistctrl, rowNum);
                }

            /// <summary>
            /// @brief Remove a row from the table, based on its index.
            ///    @param index Row index to remove from the list.
            ///    @tsexample
            ///    // Define the row index
            ///    %index = \"4\";
            ///    // Inform the GuiTextListCtrl control to remove the row at the defined row index
            ///    %thisGuiTextListCtrl.removeRow(%index);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void removeRow(string guitextlistctrl, int index)
                {
                m_ts.fnGuiTextListCtrl_removeRow(guitextlistctrl, index);
                }

            /// <summary>
            /// @brief Remove row with the specified id.
            ///    @param id Id to remove the row entry at
            ///    @tsexample
            ///    // Define the id
            ///    %id = \"4\";
            ///    // Inform the GuiTextListCtrl control to remove the row at the defined id
            ///    %thisGuiTextListCtrl.removeRowById(%id);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void removeRowById(string guitextlistctrl, int id)
                {
                m_ts.fnGuiTextListCtrl_removeRowById(guitextlistctrl, id);
                }

            /// <summary>
            /// @brief Get the number of rows.
            ///    @tsexample
            ///    // Get the number of rows in the list
            ///    %rowCount = %thisGuiTextListCtrl.rowCount();
            ///    @endtsexample
            ///    @return Number of rows in the list.
            ///    @see GuiControl)
            /// 
            /// </summary>
            public int rowCount(string guitextlistctrl)
                {
                return m_ts.fnGuiTextListCtrl_rowCount(guitextlistctrl);
                }

            /// <summary>
            /// @brief Scroll so the specified row is visible
            ///    @param rowNum Row number to make visible
            ///    @tsexample
            ///    // Define the row number to make visible
            ///    %rowNum = \"4\";
            ///    // Inform the GuiTextListCtrl control to scroll the list so the defined rowNum is visible.
            ///    %thisGuiTextListCtrl.scrollVisible(%rowNum);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void scrollVisible(string guitextlistctrl, int rowNum)
                {
                m_ts.fnGuiTextListCtrl_scrollVisible(guitextlistctrl, rowNum);
                }

            /// <summary>
            /// @brief Mark a specified row as active/not.
            ///    @param rowNum Row number to change the active state.
            ///    @param active Boolean active state to set the row number.
            ///    @tsexample
            ///    // Define the row number
            ///    %rowNum = \"4\";
            ///    // Define the boolean active state
            ///    %active = \"true\";
            ///    // Informthe GuiTextListCtrl control to set the defined active state at the defined row number.
            ///    %thisGuiTextListCtrl.setRowActive(%rowNum,%active);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setRowActive(string guitextlistctrl, int rowNum, bool active)
                {
                m_ts.fnGuiTextListCtrl_setRowActive(guitextlistctrl, rowNum, active);
                }

            /// <summary>
            /// @brief Sets the text at the defined id.
            ///    @param id Id to change.
            ///    @param text Text to use at the Id.
            ///    @tsexample
            ///    // Define the id
            ///    %id = \"4\";
            ///    // Define the text
            ///    %text = \"Text To Display\";
            ///    // Inform the GuiTextListCtrl control to display the defined text at the defined id
            ///    %thisGuiTextListCtrl.setRowById(%id,%text);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setRowById(string guitextlistctrl, int id, string text)
                {
                m_ts.fnGuiTextListCtrl_setRowById(guitextlistctrl, id, text);
                }

            /// <summary>
            /// @brief Finds the specified entry by id, then marks its row as selected.
            ///    @param id Entry within the text list to make selected.
            ///    @tsexample
            ///    // Define the id
            ///    %id = \"5\";
            ///    // Inform the GuiTextListCtrl control to set the defined id entry as selected
            ///    %thisGuiTextListCtrl.setSelectedById(%id);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setSelectedById(string guitextlistctrl, int id)
                {
                m_ts.fnGuiTextListCtrl_setSelectedById(guitextlistctrl, id);
                }

            /// <summary>
            /// @briefSelects the specified row.
            ///    @param rowNum Row number to set selected.
            ///    @tsexample
            ///    // Define the row number to set selected
            ///    %rowNum = \"4\";
            ///    %guiTextListCtrl.setSelectedRow(%rowNum);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void setSelectedRow(string guitextlistctrl, int rowNum)
                {
                m_ts.fnGuiTextListCtrl_setSelectedRow(guitextlistctrl, rowNum);
                }

            /// <summary>
            /// @brief Performs a standard (alphabetical) sort on the values in the specified column.
            ///    @param columnId Column ID to perform the sort on.
            ///    @param increasing If false, sort will be performed in reverse.
            ///    @tsexample
            ///    // Define the columnId
            ///    %id = \"1\";
            ///    // Define if we are increasing or not
            ///    %increasing = \"false\";
            ///    // Inform the GuiTextListCtrl to perform the sort operation
            ///    %thisGuiTextListCtrl.sort(%id,%increasing);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void sort(string guitextlistctrl, int columnId, bool increasing)
                {
                m_ts.fnGuiTextListCtrl_sort(guitextlistctrl, columnId, increasing);
                }

            /// <summary>
            /// @brief Perform a numerical sort on the values in the specified column.
            ///    Detailed description
            ///    @param columnId Column ID to perform the sort on.
            ///    @param increasing If false, sort will be performed in reverse.
            ///    @tsexample
            ///    // Define the columnId
            ///    %id = \"1\";
            ///    // Define if we are increasing or not
            ///    %increasing = \"false\";
            ///    // Inform the GuiTextListCtrl to perform the sort operation
            ///    %thisGuiTextListCtrl.sortNumerical(%id,%increasing);
            ///    @endtsexample
            ///    @see GuiControl)
            /// 
            /// </summary>
            public void sortNumerical(string guitextlistctrl, int columnID, bool increasing)
                {
                m_ts.fnGuiTextListCtrl_sortNumerical(guitextlistctrl, columnID, increasing);
                }
            }

        #endregion

        #region Nested type: GuiTheoraCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTheoraCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTheoraCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get the current playback time.
            ///    @return The elapsed playback time in seconds. )
            /// 
            /// </summary>
            public float getCurrentTime(string guitheoractrl)
                {
                return m_ts.fnGuiTheoraCtrl_getCurrentTime(guitheoractrl);
                }

            /// <summary>
            /// Test whether the video has finished playing.
            ///    @return True if the video has finished playing, false otherwise. )
            /// 
            /// </summary>
            public bool isPlaybackDone(string guitheoractrl)
                {
                return m_ts.fnGuiTheoraCtrl_isPlaybackDone(guitheoractrl);
                }

            /// <summary>
            /// Pause playback of the video.  If the video is not currently playing, the call is ignored.
            ///    While stopped, the control displays the last frame. )
            /// 
            /// </summary>
            public void pause(string guitheoractrl)
                {
                m_ts.fnGuiTheoraCtrl_pause(guitheoractrl);
                }

            /// <summary>
            /// Start playing the video.  If the video is already playing, the call is ignored. )
            /// 
            /// </summary>
            public void play(string guitheoractrl)
                {
                m_ts.fnGuiTheoraCtrl_play(guitheoractrl);
                }

            /// <summary>
            /// Set the video file to play.  If a video is already playing, playback is stopped and 
            ///    the new video file is loaded.
            ///    @param filename The video file to load. )
            /// 
            /// </summary>
            public void setFile(string guitheoractrl, string filename)
                {
                m_ts.fnGuiTheoraCtrl_setFile(guitheoractrl, filename);
                }

            /// <summary>
            /// Stop playback of the video.  The next call to play() will then start playback from the beginning of the video.
            ///    While stopped, the control renders empty with just the background color. )
            /// 
            /// </summary>
            public void stop(string guitheoractrl)
                {
                m_ts.fnGuiTheoraCtrl_stop(guitheoractrl);
                }
            }

        #endregion

        #region Nested type: GuiTickCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTickCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTickCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiTickCtrl, setProcessTicks, void, 2, 3, ( [tick = true] ) - This will set this object to either be processing ticks or not )
            /// 
            /// </summary>
            public void setProcessTicks(string guitickctrl = "", string a2 = "")
                {
                m_ts.fnGuiTickCtrl_setProcessTicks(guitickctrl, a2);
                }
            }

        #endregion

        #region Nested type: GuiToolboxButtonCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiToolboxButtonCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiToolboxButtonCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiToolboxButtonCtrl, setHoverBitmap, void, 3, 3, ( filepath name ) sets the bitmap that shows when the button is disabled)
            /// 
            /// </summary>
            public void setHoverBitmap(string guitoolboxbuttonctrl, string a2 = "")
                {
                m_ts.fnGuiToolboxButtonCtrl_setHoverBitmap(guitoolboxbuttonctrl, a2);
                }

            /// <summary>
            /// ( GuiToolboxButtonCtrl, setLoweredBitmap, void, 3, 3, ( filepath name ) sets the bitmap that shows when the button is disabled)
            /// 
            /// </summary>
            public void setLoweredBitmap(string guitoolboxbuttonctrl, string a2 = "")
                {
                m_ts.fnGuiToolboxButtonCtrl_setLoweredBitmap(guitoolboxbuttonctrl, a2);
                }

            /// <summary>
            /// ( GuiToolboxButtonCtrl, setNormalBitmap, void, 3, 3, ( filepath name ) sets the bitmap that shows when the button is active)
            /// 
            /// </summary>
            public void setNormalBitmap(string guitoolboxbuttonctrl, string a2 = "")
                {
                m_ts.fnGuiToolboxButtonCtrl_setNormalBitmap(guitoolboxbuttonctrl, a2);
                }
            }

        #endregion

        #region Nested type: GuiTreeViewCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiTreeViewCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiTreeViewCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (GuiTreeViewCtrl, addChildSelectionByValue, void, 4, 4, addChildSelectionByValue(TreeItemId parent, value))
            /// 
            /// </summary>
            public void addChildSelectionByValue(string guitreeviewctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiTreeViewCtrl_addChildSelectionByValue(guitreeviewctrl, a2, a3);
                }

            /// <summary>
            /// Add an item/object to the current selection.
            ///    @param id ID of item/object to add to the selection.
            ///    @param isLastSelection Whether there are more pending items/objects to be added to the selection.  If false, 
            ///       the control will defer refreshing the tree and wait until addSelection() is called with this parameter set 
            ///       to true. )
            /// 
            /// </summary>
            public void addSelection(string guitreeviewctrl, int id, bool isLastSelection)
                {
                m_ts.fnGuiTreeViewCtrl_addSelection(guitreeviewctrl, id, isLastSelection);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, buildIconTable, bool, 3,3, (builds an icon table))
            /// 
            /// </summary>
            public bool buildIconTable(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_buildIconTable(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, buildVisibleTree, void, 2, 3, Build the visible tree)
            /// 
            /// </summary>
            public void buildVisibleTree(string guitreeviewctrl = "", string a2 = "")
                {
                m_ts.fnGuiTreeViewCtrl_buildVisibleTree(guitreeviewctrl, a2);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, cancelRename, void, 2, 2, For internal use. )
            /// 
            /// </summary>
            public void cancelRename(string guitreeviewctrl = "")
                {
                m_ts.fnGuiTreeViewCtrl_cancelRename(guitreeviewctrl);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, clear, void, 2, 2, () - empty tree)
            /// 
            /// </summary>
            public void clear(string guitreeviewctrl = "")
                {
                m_ts.fnGuiTreeViewCtrl_clear(guitreeviewctrl);
                }

            /// <summary>
            /// Clear the current item filtering pattern.
            ///    @see setFilterText
            ///    @see getFilterText )
            /// 
            /// </summary>
            public void clearFilterText(string guitreeviewctrl)
                {
                m_ts.fnGuiTreeViewCtrl_clearFilterText(guitreeviewctrl);
                }

            /// <summary>
            /// Unselect all currently selected items. )
            /// 
            /// </summary>
            public void clearSelection(string guitreeviewctrl)
                {
                m_ts.fnGuiTreeViewCtrl_clearSelection(guitreeviewctrl);
                }

            /// <summary>
            /// Delete all items/objects in the current selection. )
            /// 
            /// </summary>
            public void deleteSelection(string guitreeviewctrl)
                {
                m_ts.fnGuiTreeViewCtrl_deleteSelection(guitreeviewctrl);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, editItem, bool, 5, 5, (TreeItemId item, string newText, string newValue))
            /// 
            /// </summary>
            public bool editItem(string guitreeviewctrl, string a2, string a3, string a4 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_editItem(guitreeviewctrl, a2, a3, a4);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, expandItem, bool, 3, 4, (TreeItemId item, bool expand=true))
            /// 
            /// </summary>
            public bool expandItem(string guitreeviewctrl, string a2 = "", string a3 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_expandItem(guitreeviewctrl, a2, a3);
                }

            /// <summary>
            /// Get the child item of the given parent item whose text matches @a childName.
            ///    @param parentId Item ID of the parent in which to look for the child.
            ///    @param childName Text of the child item to find.
            ///    @return ID of the child item or -1 if no child in @a parentId has the given text @a childName.
            ///    @note This method does not recurse, i.e. it only looks for direct children. )
            /// 
            /// </summary>
            public int findChildItemByName(string guitreeviewctrl, int parentId, string childName)
                {
                return m_ts.fnGuiTreeViewCtrl_findChildItemByName(guitreeviewctrl, parentId, childName);
                }

            /// <summary>
            /// Get the ID of the item whose text matches the given @a text.
            ///    @param text Item text to match.
            ///    @return ID of the item or -1 if no item matches the given text. )
            /// 
            /// </summary>
            public int findItemByName(string guitreeviewctrl, string text)
                {
                return m_ts.fnGuiTreeViewCtrl_findItemByName(guitreeviewctrl, text);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, findItemByObjectId, S32, 3, 3, (find item by object id and returns the mId))
            /// 
            /// </summary>
            public int findItemByObjectId(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_findItemByObjectId(guitreeviewctrl, a2);
                }

            /// <summary>
            /// Get the ID of the item whose value matches @a value.
            ///    @param value Value text to match.
            ///    @return ID of the item or -1 if no item has the given value. )
            /// 
            /// </summary>
            public int findItemByValue(string guitreeviewctrl, string value)
                {
                return m_ts.fnGuiTreeViewCtrl_findItemByValue(guitreeviewctrl, value);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getChild, S32, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public int getChild(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getChild(guitreeviewctrl, a2);
                }

            /// <summary>
            /// Get the current filter expression.  Only tree items whose text matches this expression 
            ///    are displayed.  By default, the expression is empty and all items are shown.
            ///    @return The current filter pattern or an empty string if no filter pattern is currently active.
            ///    @see setFilterText
            ///    @see clearFilterText )
            /// 
            /// </summary>
            public string getFilterText(string guitreeviewctrl)
                {
                return m_ts.fnGuiTreeViewCtrl_getFilterText(guitreeviewctrl);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getFirstRootItem, S32, 2, 2, Get id for root item.)
            /// 
            /// </summary>
            public int getFirstRootItem(string guitreeviewctrl = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getFirstRootItem(guitreeviewctrl);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getItemCount, S32, 2, 2, )
            /// 
            /// </summary>
            public int getItemCount(string guitreeviewctrl = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getItemCount(guitreeviewctrl);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getItemText, const char *, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public string getItemText(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getItemText(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getItemValue, const char *, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public string getItemValue(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getItemValue(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getNextSibling, S32, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public int getNextSibling(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getNextSibling(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getParent, S32, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public int getParent(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getParent(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getPrevSibling, S32, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public int getPrevSibling(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getPrevSibling(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getSelectedItem, S32, 2, 3, ( int index=0 ) - Return the selected item at the given index.)
            /// 
            /// </summary>
            public int getSelectedItem(string guitreeviewctrl = "", string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getSelectedItem(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getSelectedItemList,const char*, 2,2,returns a space seperated list of mulitple item ids)
            /// 
            /// </summary>
            public string getSelectedItemList(string guitreeviewctrl = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getSelectedItemList(guitreeviewctrl);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getSelectedItemsCount, S32, 2, 2, )
            /// 
            /// </summary>
            public int getSelectedItemsCount(string guitreeviewctrl = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getSelectedItemsCount(guitreeviewctrl);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getSelectedObject, S32, 2, 3, ( int index=0 ) - Return the currently selected SimObject at the given index in inspector mode or -1)
            /// 
            /// </summary>
            public int getSelectedObject(string guitreeviewctrl = "", string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getSelectedObject(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getSelectedObjectList, const char*, 2, 2, 
            ///               Returns a space sperated list of all selected object ids.)
            /// 
            /// </summary>
            public string getSelectedObjectList(string guitreeviewctrl = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getSelectedObjectList(guitreeviewctrl);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, getTextToRoot, const char*,4,4,(TreeItemId item,Delimiter=none) gets the text from the current node to the root, concatenating at each branch upward, with a specified delimiter optionally)
            /// 
            /// </summary>
            public string getTextToRoot(string guitreeviewctrl, string a2, string a3 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_getTextToRoot(guitreeviewctrl, a2, a3);
                }

            /// <summary>
            /// Call SimObject::setHidden( @a state ) on all objects in the current selection.
            ///    @param state Visibility state to set objects in selection to. )
            /// 
            /// </summary>
            public void hideSelection(string guitreeviewctrl, bool state)
                {
                m_ts.fnGuiTreeViewCtrl_hideSelection(guitreeviewctrl, state);
                }

            /// <summary>
            /// , , 0, 0 ),
            ///    Add a new item to the tree.
            ///    @param parentId Item ID of parent to which to add the item as a child.  0 is root item.
            ///    @param text Text to display on the item in the tree.
            ///    @param value Behind-the-scenes value of the item.
            ///    @param icon
            ///    @param normalImage
            ///    @param expandedImage
            ///    @return The ID of the newly added item. )
            /// 
            /// </summary>
            public int insertItem(string guitreeviewctrl, int parentId, string text, string value, string icon, int normalImage, int expandedImage)
                {
                return m_ts.fnGuiTreeViewCtrl_insertItem(guitreeviewctrl, parentId, text, value, icon, normalImage, expandedImage);
                }

            /// <summary>
            /// Check whether the given item is currently selected in the tree.
            ///    @param id Item/object ID.
            ///    @return True if the given item/object is currently selected in the tree. )
            /// 
            /// </summary>
            public bool isItemSelected(string guitreeviewctrl, int id)
                {
                return m_ts.fnGuiTreeViewCtrl_isItemSelected(guitreeviewctrl, id);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, isParentItem, bool, 3, 3, ( int id ) - Returns true if the given item contains child items. )
            /// 
            /// </summary>
            public bool isParentItem(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_isParentItem(guitreeviewctrl, a2);
                }

            /// <summary>
            /// Set whether the current selection can be changed by the user or not.
            ///    @param lock If true, the current selection is frozen and cannot be changed.  If false, 
            ///       the selection may be modified. )
            /// 
            /// </summary>
            public void lockSelection(string guitreeviewctrl, bool xlock)
                {
                m_ts.fnGuiTreeViewCtrl_lockSelection(guitreeviewctrl, xlock);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, markItem, bool, 3, 4, (TreeItemId item, bool mark=true))
            /// 
            /// </summary>
            public bool markItem(string guitreeviewctrl, string a2 = "", string a3 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_markItem(guitreeviewctrl, a2, a3);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, moveItemDown, void, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public void moveItemDown(string guitreeviewctrl, string a2 = "")
                {
                m_ts.fnGuiTreeViewCtrl_moveItemDown(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, moveItemUp, void, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public void moveItemUp(string guitreeviewctrl, string a2 = "")
                {
                m_ts.fnGuiTreeViewCtrl_moveItemUp(guitreeviewctrl, a2);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, onRenameValidate, void, 2, 2, For internal use. )
            /// 
            /// </summary>
            public void onRenameValidate(string guitreeviewctrl = "")
                {
                m_ts.fnGuiTreeViewCtrl_onRenameValidate(guitreeviewctrl);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, open, void, 3, 4, (SimSet obj, bool okToEdit=true) Set the root of the tree view to the specified object, or to the root set.)
            /// 
            /// </summary>
            public void open(string guitreeviewctrl, string a2 = "", string a3 = "")
                {
                m_ts.fnGuiTreeViewCtrl_open(guitreeviewctrl, a2, a3);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, removeAllChildren, void, 3, 3, removeAllChildren(TreeItemId parent))
            /// 
            /// </summary>
            public void removeAllChildren(string guitreeviewctrl, string a2 = "")
                {
                m_ts.fnGuiTreeViewCtrl_removeAllChildren(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, removeChildSelectionByValue, void, 4, 4, removeChildSelectionByValue(TreeItemId parent, value))
            /// 
            /// </summary>
            public void removeChildSelectionByValue(string guitreeviewctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiTreeViewCtrl_removeChildSelectionByValue(guitreeviewctrl, a2, a3);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, removeItem, bool, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public bool removeItem(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_removeItem(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, removeSelection, void, 3, 3, (deselects an item))
            /// 
            /// </summary>
            public void removeSelection(string guitreeviewctrl, string a2 = "")
                {
                m_ts.fnGuiTreeViewCtrl_removeSelection(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, scrollVisible, void, 3, 3, (TreeItemId item))
            /// 
            /// </summary>
            public void scrollVisible(string guitreeviewctrl, string a2 = "")
                {
                m_ts.fnGuiTreeViewCtrl_scrollVisible(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, scrollVisibleByObjectId, S32, 3, 3, (show item by object id. returns true if sucessful.))
            /// 
            /// </summary>
            public int scrollVisibleByObjectId(string guitreeviewctrl, string a2 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_scrollVisibleByObjectId(guitreeviewctrl, a2);
                }

            /// <summary>
            /// (GuiTreeViewCtrl, selectItem, bool, 3, 4, (TreeItemId item, bool select=true))
            /// 
            /// </summary>
            public bool selectItem(string guitreeviewctrl, string a2 = "", string a3 = "")
                {
                return m_ts.fnGuiTreeViewCtrl_selectItem(guitreeviewctrl, a2, a3);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, setDebug, void, 2, 3, ( bool value=true ) - Enable/disable debug output. )
            /// 
            /// </summary>
            public void setDebug(string guitreeviewctrl = "", string a2 = "")
                {
                m_ts.fnGuiTreeViewCtrl_setDebug(guitreeviewctrl, a2);
                }

            /// <summary>
            /// Set the pattern by which to filter items in the tree.  Only items in the tree whose text 
            ///    matches this pattern are displayed.
            ///    @param pattern New pattern based on which visible items in the tree should be filtered.  If empty, all items become visible.
            ///    @see getFilterText
            ///    @see clearFilterText )
            /// 
            /// </summary>
            public void setFilterText(string guitreeviewctrl, string pattern)
                {
                m_ts.fnGuiTreeViewCtrl_setFilterText(guitreeviewctrl, pattern);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, setItemImages, void, 5, 5, ( int id, int normalImage, int expandedImage ) - Sets the normal and expanded images to show for the given item. )
            /// 
            /// </summary>
            public void setItemImages(string guitreeviewctrl, string a2, string a3, string a4 = "")
                {
                m_ts.fnGuiTreeViewCtrl_setItemImages(guitreeviewctrl, a2, a3, a4);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, setItemTooltip, void, 4, 4, ( int id, string text ) - Set the tooltip to show for the given item. )
            /// 
            /// </summary>
            public void setItemTooltip(string guitreeviewctrl, string a2, string a3 = "")
                {
                m_ts.fnGuiTreeViewCtrl_setItemTooltip(guitreeviewctrl, a2, a3);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, showItemRenameCtrl, void, 3, 3, ( TreeItemId id ) - Show the rename text field for the given item (only one at a time). )
            /// 
            /// </summary>
            public void showItemRenameCtrl(string guitreeviewctrl, string a2 = "")
                {
                m_ts.fnGuiTreeViewCtrl_showItemRenameCtrl(guitreeviewctrl, a2);
                }

            /// <summary>
            /// ( GuiTreeViewCtrl, sort, void, 2, 6, ( int parent, bool traverseHierarchy=false, bool parentsFirst=false, bool caseSensitive=true ) - Sorts all items of the given parent (or root).  With 'hierarchy', traverses hierarchy. )
            /// 
            /// </summary>
            public void sort(string guitreeviewctrl = "", string a2 = "", string a3 = "", string a4 = "", string a5 = "")
                {
                m_ts.fnGuiTreeViewCtrl_sort(guitreeviewctrl, a2, a3, a4, a5);
                }

            /// <summary>
            /// Toggle the hidden state of all objects in the current selection. )
            /// 
            /// </summary>
            public void toggleHideSelection(string guitreeviewctrl)
                {
                m_ts.fnGuiTreeViewCtrl_toggleHideSelection(guitreeviewctrl);
                }

            /// <summary>
            /// Toggle the locked state of all objects in the current selection. )
            /// 
            /// </summary>
            public void toggleLockSelection(string guitreeviewctrl)
                {
                m_ts.fnGuiTreeViewCtrl_toggleLockSelection(guitreeviewctrl);
                }
            }

        #endregion

        #region Nested type: GuiVariableInspectorObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiVariableInspectorObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiVariableInspectorObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( GuiVariableInspector, loadVars, void, 3, 3, loadVars( searchString ) )
            /// 
            /// </summary>
            public void loadVars(string guivariableinspector, string a2 = "")
                {
                m_ts.fnGuiVariableInspector_loadVars(guivariableinspector, a2);
                }
            }

        #endregion

        #region Nested type: GuiWindowCtrlObject

        /// <summary>
        /// 
        /// </summary>
        public class GuiWindowCtrlObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public GuiWindowCtrlObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void attachTo(string guiwindowctrl, string window)
                {
                m_ts.fnGuiWindowCtrl_attachTo(guiwindowctrl, window);
                }

            /// <summary>
            /// Bring the window to the front. )
            /// 
            /// </summary>
            public void selectWindow(string guiwindowctrl)
                {
                m_ts.fnGuiWindowCtrl_selectWindow(guiwindowctrl);
                }

            /// <summary>
            /// Set the window's collapsing state. )
            /// 
            /// </summary>
            public void setCollapseGroup(string guiwindowctrl, bool state)
                {
                m_ts.fnGuiWindowCtrl_setCollapseGroup(guiwindowctrl, state);
                }

            /// <summary>
            /// Toggle the window collapsing. )
            /// 
            /// </summary>
            public void toggleCollapseGroup(string guiwindowctrl)
                {
                m_ts.fnGuiWindowCtrl_toggleCollapseGroup(guiwindowctrl);
                }
            }

        #endregion

        #region Nested type: HTTPObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class HTTPObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public HTTPObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            ///  ),
            ///    @brief Send a GET command to a server to send or retrieve data.
            /// 
            ///    @param Address HTTP web address to send this get call to. Be sure to include the port at the end (IE: \"www.garagegames.com:80\").
            ///    @param requirstURI Specific location on the server to access (IE: \"index.php\".)
            ///    @param query Optional. Actual data to transmit to the server. Can be anything required providing it sticks with limitations of the HTTP protocol. 
            ///    If you were building the URL manually, this is the text that follows the question mark.  For example: http://www.google.com/ig/api?b>weather=Las-Vegas,US/b>
            ///    
            ///    @tsexample
            /// 	   // Create an HTTP object for communications
            /// 	   %httpObj = new HTTPObject();
            /// 	   // Specify a URL to transmit to
            ///       %url = \"www.garagegames.com:80\";
            /// 	   // Specify a URI to communicate with
            /// 	   %URI = \"/index.php\";
            /// 	   // Specify a query to send.
            /// 	   %query = \"\";
            /// 	   // Send the GET command to the server
            /// 	   %httpObj.get(%url,%URI,%query);
            ///    @endtsexample
            ///    )
            /// 
            /// </summary>
            public void get(string httpobject, string Address, string requirstURI, string query)
                {
                m_ts.fnHTTPObject_get(httpobject, Address, requirstURI, query);
                }

            /// <summary>
            /// @brief Send POST command to a server to send or retrieve data.
            /// 
            ///    @param Address HTTP web address to send this get call to. Be sure to include the port at the end (IE: \"www.garagegames.com:80\").
            ///    @param requirstURI Specific location on the server to access (IE: \"index.php\".)
            ///    @param query Actual data to transmit to the server. Can be anything required providing it sticks with limitations of the HTTP protocol. 
            ///    @param post Submission data to be processed.
            ///    
            ///    @note The post() method is currently non-functional.
            /// 
            ///    @tsexample
            /// 	   // Create an HTTP object for communications
            /// 	   %httpObj = new HTTPObject();
            /// 	   // Specify a URL to transmit to
            ///       %url = \"www.garagegames.com:80\";
            /// 	   // Specify a URI to communicate with
            /// 	   %URI = \"/index.php\";
            /// 	   // Specify a query to send.
            /// 	   %query = \"\";
            /// 	   // Specify the submission data.
            /// 	   %post = \"\";
            /// 	   // Send the POST command to the server
            /// 	   %httpObj.POST(%url,%URI,%query,%post);
            ///    @endtsexample
            ///    )
            /// 
            /// </summary>
            public void post(string httpobject, string Address, string requirstURI, string query, string post)
                {
                m_ts.fnHTTPObject_post(httpobject, Address, requirstURI, query, post);
                }
            }

        #endregion

        #region Nested type: InteriorInstanceObject

        /// <summary>
        /// 
        /// </summary>
        public class InteriorInstanceObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public InteriorInstanceObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Change one of the materials on the shape.
            /// 
            ///    This method changes materials per mapTo with others. The material that 
            ///    is being replaced is mapped to unmapped_mat as a part of this transition.
            /// 
            ///    @note Warning, right now this only sort of works. It doesn't do a live 
            ///    update like it should.\b
            /// 
            ///    @param mapTo The name of the material target to remap (from getTargetName)
            ///    @param oldMat The old Material that was mapped 
            ///    @param newMat The new Material to map
            /// 
            ///    @tsexample
            ///    // remap the first material in the shape
            ///    %mapTo = %interiorObject.getTargetName( 0 );
            ///    %interiorObject.changeMaterial( %mapTo, 0, MyMaterial );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void changeMaterial(string interiorinstance, string mapTo, string oldMat, string newMat)
                {
                m_ts.fnInteriorInstance_changeMaterial(interiorinstance, mapTo, oldMat, newMat);
                }

            /// <summary>
            /// @brief Exports the Interior to a Collada file
            /// 
            ///    @param bakeTransform Bakes the InteriorInstance's transform into the vertex positions
            ///    
            ///    @tsexample
            ///    // Export to COLLADA, do not bakeTransform
            ///    %interiorObject.exportToCollada(0);
            ///    @endtsexample)
            /// 
            /// </summary>
            public void exportToCollada(string interiorinstance, bool bakeTransform)
                {
                m_ts.fnInteriorInstance_exportToCollada(interiorinstance, bakeTransform);
                }

            /// <summary>
            /// @brief Get the interior file name
            ///    
            /// 
            ///    @return The name of the interior's model file in .DIF.
            /// 
            ///    @tsexample
            ///    %interiorObject.getModelFile();
            ///    @endtsexample)
            /// 
            /// </summary>
            public string getModelFile(string interiorinstance)
                {
                return m_ts.fnInteriorInstance_getModelFile(interiorinstance);
                }

            /// <summary>
            /// @brief Get the number of detail levels interior was created with
            ///    
            ///    @tsexample
            ///    %numLODs = %interiorObject.getNumDetailLevels();
            ///    echo(%numLODs);
            ///    @endtsexample)
            /// 
            /// </summary>
            public int getNumDetailLevels(string interiorinstance)
                {
                return m_ts.fnInteriorInstance_getNumDetailLevels(interiorinstance);
                }

            /// <summary>
            /// @brief Get the number of materials used by interior
            ///    
            ///    @param	detailLevel Interior level of detail to scan
            /// 
            ///    @return The number of materials used by the interior at a specified detail level
            /// 
            ///    @tsexample
            ///    // Find materials used at first level of detail
            ///    %targetCount = %interiorObject.getTargetCount(1);
            ///    echo(%targetCount);
            ///    @endtsexample)
            /// 
            /// </summary>
            public int getTargetCount(string interiorinstance, uint detailLevel)
                {
                return m_ts.fnInteriorInstance_getTargetCount(interiorinstance, detailLevel);
                }

            /// <summary>
            /// @brief Get the name of the indexed shape material
            ///    
            ///    @param	detailLevel Target LOD
            ///    @param	targetNum Index mapped to the target
            /// 
            ///    @return The name of the target (material) at the specified detail level and index
            /// 
            ///    @tsexample
            ///    // First level of detail, top of the index map
            ///    %targetName = %interiorObject.getTargetName(1, 0);
            ///    echo(%targetName);
            ///    @endtsexample)
            /// 
            /// </summary>
            public string getTargetName(string interiorinstance, int detailLevel, int targetNum)
                {
                return m_ts.fnInteriorInstance_getTargetName(interiorinstance, detailLevel, targetNum);
                }

            /// <summary>
            /// @brief This sets the alarm mode of the interior
            /// 
            ///    The alarm mode is used when debugging bad geometry for an interior. When on, the the bad verties 
            ///    will be rendered a different color.
            /// 
            ///    @param alarmMode If true the interior will be in an alarm state next frame. Options are \'On\' or \'Off\'.
            ///    
            ///    @tsexample
            ///    // Turn on alarm mode debugging for interior
            ///    %interiorObject.setAlarmMode(\"On\");
            ///    @endtsexample)
            /// 
            /// </summary>
            public void setAlarmMode(string interiorinstance, string alarmMode)
                {
                m_ts.fnInteriorInstance_setAlarmMode(interiorinstance, alarmMode);
                }

            /// <summary>
            /// @brief Manually changes the current detail level, rather than automatically via view distance
            ///    
            ///    @param level Detail level to force.
            /// 
            ///    @tsexample
            ///    %interiorObject.setDetailLevel(2);
            ///    @endtsexample)
            /// 
            /// </summary>
            public void setDetailLevel(string interiorinstance, int level)
                {
                m_ts.fnInteriorInstance_setDetailLevel(interiorinstance, level);
                }
            }

        #endregion

        #region Nested type: ItemObject

        /// <summary>
        /// 
        /// </summary>
        public class ItemObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ItemObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Get the normal of the surface on which the object is stuck.   
            ///    @return Returns The XYZ normal from where this Item is stuck.
            ///    @tsexample
            /// 	   // Acquire the position where this Item is currently stuck
            /// 	   %stuckPosition = %item.getLastStickPos();
            ///    @endtsexample
            ///    @note Server side only.
            ///    )
            /// 
            /// </summary>
            public string getLastStickyNormal(string item)
                {
                return m_ts.fnItem_getLastStickyNormal(item);
                }

            /// <summary>
            /// @brief Get the position on the surface on which this Item is stuck.   
            ///    @return Returns The XYZ position of where this Item is stuck.
            ///    @tsexample
            /// 	   // Acquire the position where this Item is currently stuck
            /// 	   %stuckPosition = %item.getLastStickPos();
            ///    @endtsexample
            ///    @note Server side only.
            ///    )
            /// 
            /// </summary>
            public string getLastStickyPos(string item)
                {
                return m_ts.fnItem_getLastStickyPos(item);
                }

            /// <summary>
            /// @brief Is the object at rest (ie, no longer moving)?   
            ///    @return True if the object is at rest, false if it is not.
            ///    @tsexample
            /// 	   // Query the item on if it is or is not at rest.
            /// 	   %isAtRest = %item.isAtRest();
            ///    @endtsexample
            ///    )
            /// 
            /// </summary>
            public bool isAtRest(string item)
                {
                return m_ts.fnItem_isAtRest(item);
                }

            /// <summary>
            /// @brief Is the object still rotating?   
            ///    @return True if the object is still rotating, false if it is not.
            ///    @tsexample
            /// 	   // Query the item on if it is or is not rotating.
            /// 	   %isRotating = %itemData.isRotating();
            ///    @endtsexample
            ///    @see rotate
            ///    )
            /// 
            /// </summary>
            public bool isRotating(string item)
                {
                return m_ts.fnItem_isRotating(item);
                }

            /// <summary>
            /// @brief Is the object static (ie, non-movable)?   
            ///    @return True if the object is static, false if it is not.
            ///    @tsexample
            /// 	   // Query the item on if it is or is not static.
            /// 	   %isStatic = %itemData.isStatic();
            ///    @endtsexample
            ///    @see static
            ///    )
            /// 
            /// </summary>
            public bool isStatic(string item)
                {
                return m_ts.fnItem_isStatic(item);
                }

            /// <summary>
            /// @brief Temporarily disable collisions against a specific ShapeBase object.
            /// 
            ///    This is useful to prevent a player from immediately picking up an Item they have 
            ///    just thrown.  Only one object may be on the timeout list at a time.  The timeout is 
            ///    defined as 15 ticks.
            /// 
            ///    @param objectID ShapeBase object ID to disable collisions against.
            ///    @return Returns true if the ShapeBase object requested could be found, false if it could not.
            /// 
            ///    @tsexample
            /// 	   // Set the ShapeBase Object ID to disable collisions against
            /// 	   %ignoreColObj = %player.getID();
            /// 	   // Inform this Item object to ignore collisions temproarily against the %ignoreColObj.
            /// 	   %item.setCollisionTimeout(%ignoreColObj);
            ///    @endtsexample
            ///    )
            /// 
            /// </summary>
            public bool setCollisionTimeout(string item, int ignoreColObj)
                {
                return m_ts.fnItem_setCollisionTimeout(item, ignoreColObj);
                }
            }

        #endregion

        #region Nested type: LangTableObject

        /// <summary>
        /// 
        /// </summary>
        public class LangTableObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public LangTableObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (LangTable, addLanguage, S32, 3, 4, 
            /// 			  (string filename, [string languageName])
            /// 			  @brief Adds a language to the table
            /// 			  @param filename Name and path to the language file
            /// 			  @param languageName Optional name to assign to the new language entry
            /// 			  @return True If file was successfully found and language created
            /// 			  )
            /// 
            /// </summary>
            public int addLanguage(string langtable, string a2 = "", string a3 = "")
                {
                return m_ts.fnLangTable_addLanguage(langtable, a2, a3);
                }

            /// <summary>
            /// (LangTable, getCurrentLanguage, S32, 2, 2, ()
            /// 			  @brief Get the ID of the current language table
            /// 			  @return Numerical ID of the current language table)
            /// 
            /// </summary>
            public int getCurrentLanguage(string langtable = "")
                {
                return m_ts.fnLangTable_getCurrentLanguage(langtable);
                }

            /// <summary>
            /// (LangTable, getLangName, const char *, 3, 3, (int language)
            /// 			  @brief Return the readable name of the language table
            /// 			  @param language Numerical ID of the language table to access
            /// 			  @return String containing the name of the table, NULL if ID was invalid or name was never specified)
            /// 
            /// </summary>
            public string getLangName(string langtable, string a2 = "")
                {
                return m_ts.fnLangTable_getLangName(langtable, a2);
                }

            /// <summary>
            /// (LangTable, getNumLang, S32, 2, 2, ()
            /// 			  @brief Used to find out how many languages are in the table
            /// 			  @return Size of the vector containing the languages, numerical)
            /// 
            /// </summary>
            public int getNumLang(string langtable = "")
                {
                return m_ts.fnLangTable_getNumLang(langtable);
                }

            /// <summary>
            /// (LangTable, getString, const char *, 3, 3, 
            /// 			  (string filename)
            /// 			  @brief Grabs a string from the specified table
            /// 			  If an invalid is passed, the function will attempt to 
            /// 			  to grab from the default table
            /// 			  @param filename Name of the language table to access
            /// 			  @return Text from the specified language table, \"\" if ID was invalid and default table is not set)
            /// 
            /// </summary>
            public string getString(string langtable, string a2 = "")
                {
                return m_ts.fnLangTable_getString(langtable, a2);
                }

            /// <summary>
            /// (LangTable, setCurrentLanguage, void, 3, 3, 
            /// 			  (int language)
            /// 			  @brief Sets the current language table for grabbing text
            /// 			  @param language ID of the table)
            /// 
            /// </summary>
            public void setCurrentLanguage(string langtable, string a2 = "")
                {
                m_ts.fnLangTable_setCurrentLanguage(langtable, a2);
                }

            /// <summary>
            /// (LangTable, setDefaultLanguage, void, 3, 3, (int language)
            /// 			  @brief Sets the default language table
            /// 			  @param language ID of the table)
            /// 
            /// </summary>
            public void setDefaultLanguage(string langtable, string a2 = "")
                {
                m_ts.fnLangTable_setDefaultLanguage(langtable, a2);
                }
            }

        #endregion

        #region Nested type: LightBaseObject

        /// <summary>
        /// 
        /// </summary>
        public class LightBaseObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public LightBaseObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( LightBase, pauseAnimation, void, 2, 2, Stops the light animation. )
            /// 
            /// </summary>
            public void pauseAnimation(string lightbase = "")
                {
                m_ts.fnLightBase_pauseAnimation(lightbase);
                }

            /// <summary>
            /// ( LightBase, playAnimation, void, 2, 3, ( [LightAnimData anim] )\t
            ///    Plays a light animation on the light.  If no LightAnimData is passed the 
            ///    existing one is played.
            ///    @hide)
            /// 
            /// </summary>
            public void playAnimation(string lightbase = "", string a2 = "")
                {
                m_ts.fnLightBase_playAnimation(lightbase, a2);
                }

            /// <summary>
            /// @brief Toggles the light on and off
            ///    
            ///    @param state Turns the light on (true) or off (false)
            /// 
            ///    @tsexample
            ///    // Disable the light
            ///    CrystalLight.setLightEnabled(false);
            ///    // Renable the light
            ///    CrystalLight.setLightEnabled(true);
            ///    
            ///    @endtsexample
            /// )
            /// 
            /// </summary>
            public void setLightEnabled(string lightbase, bool state)
                {
                m_ts.fnLightBase_setLightEnabled(lightbase, state);
                }
            }

        #endregion

        #region Nested type: LightDescriptionObject

        /// <summary>
        /// 
        /// </summary>
        public class LightDescriptionObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public LightDescriptionObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Force an inspectPostApply call for the benefit of tweaking via the console
            ///    
            ///    Normally this functionality is only exposed to objects via the World Editor, once changes have been made. 
            ///    Exposing apply to script allows you to make changes to it on the fly without the World Editor.
            /// 
            ///    @note This is intended for debugging and tweaking, not for game play
            /// 
            ///    @tsexample
            ///    // Change a property of the light description
            ///    RocketLauncherLightDesc.brightness = 10;
            ///    // Make it so
            ///    RocketLauncherLightDesc.apply();
            ///    
            ///    @endtsexample
            /// )
            /// 
            /// </summary>
            public void apply(string lightdescription)
                {
                m_ts.fnLightDescription_apply(lightdescription);
                }
            }

        #endregion

        #region Nested type: LightFlareDataObject

        /// <summary>
        /// 
        /// </summary>
        public class LightFlareDataObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public LightFlareDataObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Force trigger an inspectPostApply
            ///                    )
            /// 
            /// </summary>
            public void apply(string lightflaredata)
                {
                m_ts.fnLightFlareData_apply(lightflaredata);
                }
            }

        #endregion

        #region Nested type: LightningObject

        /// <summary>
        /// 
        /// </summary>
        public class LightningObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public LightningObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Creates a LightningStrikeEvent which strikes a specific object.
            ///    @note This method is currently unimplemented. )
            /// 
            /// </summary>
            public void strikeObject(string lightning, int id)
                {
                m_ts.fnLightning_strikeObject(lightning, id);
                }

            /// <summary>
            /// Creates a LightningStrikeEvent which attempts to strike and damage a random 
            ///    object in range of the Lightning object.
            ///    @tsexample
            ///    // Generate a damaging lightning strike effect on all clients
            ///    %lightning.strikeRandomPoint();
            ///    @endtsexample )
            /// 
            /// </summary>
            public void strikeRandomPoint(string lightning)
                {
                m_ts.fnLightning_strikeRandomPoint(lightning);
                }

            /// <summary>
            /// @brief Creates a LightningStrikeEvent that triggers harmless lightning 
            ///    bolts on all clients.
            ///    No objects will be damaged by these bolts.
            ///    @tsexample
            ///    // Generate a harmless lightning strike effect on all clients
            ///    %lightning.warningFlashes();
            ///    @endtsexample )
            /// 
            /// </summary>
            public void warningFlashes(string lightning)
                {
                m_ts.fnLightning_warningFlashes(lightning);
                }
            }

        #endregion

        #region Nested type: MECreateUndoActionObject

        /// <summary>
        /// 
        /// </summary>
        public class MECreateUndoActionObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public MECreateUndoActionObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( MECreateUndoAction, addObject, void, 3, 3, ( SimObject obj ))
            /// 
            /// </summary>
            public void addObject(string mecreateundoaction, string a2 = "")
                {
                m_ts.fnMECreateUndoAction_addObject(mecreateundoaction, a2);
                }
            }

        #endregion

        #region Nested type: MEDeleteUndoActionObject

        /// <summary>
        /// 
        /// </summary>
        public class MEDeleteUndoActionObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public MEDeleteUndoActionObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( MEDeleteUndoAction, deleteObject, void, 3, 3, ( SimObject obj ))
            /// 
            /// </summary>
            public void deleteObject(string medeleteundoaction, string a2 = "")
                {
                m_ts.fnMEDeleteUndoAction_deleteObject(medeleteundoaction, a2);
                }
            }

        #endregion

        #region Nested type: MaterialObject

        /// <summary>
        /// 
        /// </summary>
        public class MaterialObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public MaterialObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( Material, dumpInstances, void, 2, 2, 
            ///    Dumps a formatted list of the currently allocated material instances for this material to the console. )
            /// 
            /// </summary>
            public void dumpInstances(string material = "")
                {
                m_ts.fnMaterial_dumpInstances(material);
                }

            /// <summary>
            /// ( Material, flush, void, 2, 2, 
            ///    Flushes all material instances that use this material. )
            /// 
            /// </summary>
            public void flush(string material = "")
                {
                m_ts.fnMaterial_flush(material);
                }

            /// <summary>
            /// ( Material, getAnimFlags, const char*, 3, 3,  )
            /// 
            /// </summary>
            public string getAnimFlags(string material, string a2 = "")
                {
                return m_ts.fnMaterial_getAnimFlags(material, a2);
                }

            /// <summary>
            /// (Material, getFilename, const char*, 2, 2, Get filename of material)
            /// 
            /// </summary>
            public string getFilename(string material = "")
                {
                return m_ts.fnMaterial_getFilename(material);
                }

            /// <summary>
            /// ( Material, isAutoGenerated, bool, 2, 2, 
            ///               Returns true if this Material was automatically generated by MaterialList::mapMaterials() )
            /// 
            /// </summary>
            public bool isAutoGenerated(string material = "")
                {
                return m_ts.fnMaterial_isAutoGenerated(material);
                }

            /// <summary>
            /// ( Material, reload, void, 2, 2, 
            ///    Reloads all material instances that use this material. )
            /// 
            /// </summary>
            public void reload(string material = "")
                {
                m_ts.fnMaterial_reload(material);
                }

            /// <summary>
            /// ( Material, setAutoGenerated, void, 3, 3, 
            ///               setAutoGenerated(bool isAutoGenerated): Set whether or not the Material is autogenerated. )
            /// 
            /// </summary>
            public void setAutoGenerated(string material, string a2 = "")
                {
                m_ts.fnMaterial_setAutoGenerated(material, a2);
                }
            }

        #endregion

        #region Nested type: MenuBarObject

        /// <summary>
        /// 
        /// </summary>
        public class MenuBarObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public MenuBarObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (MenuBar, attachToCanvas, void, 4, 4, (GuiCanvas, pos))
            /// 
            /// </summary>
            public void attachToCanvas(string menubar, string a2, string a3 = "")
                {
                m_ts.fnMenuBar_attachToCanvas(menubar, a2, a3);
                }

            /// <summary>
            /// (MenuBar, insert, void, 4, 4,(object, pos) insert object at position)
            /// 
            /// </summary>
            public void insert(string menubar, string a2, string a3 = "")
                {
                m_ts.fnMenuBar_insert(menubar, a2, a3);
                }

            /// <summary>
            /// (MenuBar, removeFromCanvas, void, 2, 2, ())
            /// 
            /// </summary>
            public void removeFromCanvas(string menubar = "")
                {
                m_ts.fnMenuBar_removeFromCanvas(menubar);
                }
            }

        #endregion

        #region Nested type: MeshRoadObject

        /// <summary>
        /// 
        /// </summary>
        public class MeshRoadObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public MeshRoadObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Force trigger an inspectPostApply. This will transmit 
            ///                    material and other fields ( not including nodes ) to client objects.
            ///                    )
            /// 
            /// </summary>
            public void postApply(string meshroad)
                {
                m_ts.fnMeshRoad_postApply(meshroad);
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Force MeshRoad to recreate its geometry.
            ///                    )
            /// 
            /// </summary>
            public void regenerate(string meshroad)
                {
                m_ts.fnMeshRoad_regenerate(meshroad);
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Sets the depth in meters of a particular node.
            ///                    )
            /// 
            /// </summary>
            public void setNodeDepth(string meshroad, int idx, float meters)
                {
                m_ts.fnMeshRoad_setNodeDepth(meshroad, idx, meters);
                }
            }

        #endregion

        #region Nested type: MessageObject

        /// <summary>
        /// 
        /// </summary>
        public class MessageObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public MessageObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (Message, addReference, void, 2, 2, () Increment the reference count for this message)
            /// 
            /// </summary>
            public void addReference(string message = "")
                {
                m_ts.fnMessage_addReference(message);
                }

            /// <summary>
            /// (Message, freeReference, void, 2, 2, () Decrement the reference count for this message)
            /// 
            /// </summary>
            public void freeReference(string message = "")
                {
                m_ts.fnMessage_freeReference(message);
                }

            /// <summary>
            /// (Message, getType, const char *, 2, 2, () Get message type (script class name or C++ class name if no script defined class))
            /// 
            /// </summary>
            public string getType(string message = "")
                {
                return m_ts.fnMessage_getType(message);
                }
            }

        #endregion

        #region Nested type: MessageVectorObject

        /// <summary>
        /// 
        /// </summary>
        public class MessageVectorObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public MessageVectorObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Clear all messages in the vector
            ///    @tsexample
            ///    HudMessageVector.clear();
            ///    @endtsexample)
            /// 
            /// </summary>
            public void clear(string messagevector)
                {
                m_ts.fnMessageVector_clear(messagevector);
                }

            /// <summary>
            /// Delete the line at the specified position.
            ///    @param deletePos Position in the vector containing the line to be deleted
            ///    @tsexample
            ///    // Delete the first line (index 0) in the vector...
            ///    HudMessageVector.deleteLine(0);
            ///    @endtsexample
            ///    @return False if deletePos is greater than the number of lines in the current vector)
            /// 
            /// </summary>
            public bool deleteLine(string messagevector, int deletePos)
                {
                return m_ts.fnMessageVector_deleteLine(messagevector, deletePos);
                }

            /// <summary>
            /// ( MessageVector, dump, void, 3, 4, (string filename, string header=NULL)
            ///               Dump the message vector to a file, optionally prefixing a header.
            /// 			  @hide)
            /// 
            /// </summary>
            public void dump(string messagevector, string a2 = "", string a3 = "")
                {
                m_ts.fnMessageVector_dump(messagevector, a2, a3);
                }

            /// <summary>
            /// Scan through the vector, returning the line number of the first line that matches the specified tag; else returns -1 if no match was found.
            ///    @param tag Numerical value assigned to a message when it was added or inserted
            ///    @tsexample
            ///    // Locate a line of text tagged with the value \"1\", then delete it.
            ///    %taggedLine = HudMessageVector.getLineIndexByTag(1);
            ///    HudMessageVector.deleteLine(%taggedLine);
            ///    @endtsexample
            ///    @return Line with matching tag, other wise -1)
            /// 
            /// </summary>
            public int getLineIndexByTag(string messagevector, int tag)
                {
                return m_ts.fnMessageVector_getLineIndexByTag(messagevector, tag);
                }

            /// <summary>
            /// Get the tag of a specified line.
            ///    @param pos Position in vector to grab tag from
            ///    @tsexample
            ///    // Remove all lines that do not have a tag value of 1.
            ///    while( HudMessageVector.getNumLines())
            ///    {
            ///       %tag = HudMessageVector.getLineTag(1);
            ///       if(%tag != 1)
            ///          %tag.delete();
            ///       HudMessageVector.popFrontLine();
            ///    }
            ///    @endtsexample
            ///    @return Tag value of a given line, if the position is greater than the number of lines return 0)
            /// 
            /// </summary>
            public int getLineTag(string messagevector, int pos)
                {
                return m_ts.fnMessageVector_getLineTag(messagevector, pos);
                }

            /// <summary>
            /// Get the text at a specified line.
            ///    @param pos Position in vector to grab text from
            ///    @tsexample
            ///    // Print a line of text at position 1.
            ///    %text = HudMessageVector.getLineText(1);
            ///    echo(%text);
            ///    @endtsexample
            ///    @return Text at specified line, if the position is greater than the number of lines return \"\")
            /// 
            /// </summary>
            public string getLineText(string messagevector, int pos)
                {
                return m_ts.fnMessageVector_getLineText(messagevector, pos);
                }

            /// <summary>
            /// Scan through the lines in the vector, returning the first line that has a matching tag.
            ///    @param tag Numerical value assigned to a message when it was added or inserted
            ///    @tsexample
            ///    // Locate text in the vector tagged with the value \"1\", then print it
            ///    %taggedText = HudMessageVector.getLineTextByTag(1);
            ///    echo(%taggedText);
            ///    @endtsexample
            ///    @return Text from a line with matching tag, other wise \"\")
            /// 
            /// </summary>
            public string getLineTextByTag(string messagevector, int tag)
                {
                return m_ts.fnMessageVector_getLineTextByTag(messagevector, tag);
                }

            /// <summary>
            /// Get the number of lines in the vector.
            ///    @tsexample
            ///    // Find out how many lines have been stored in HudMessageVector
            ///    %chatLines = HudMessageVector.getNumLines();
            ///    echo(%chatLines);
            ///    @endtsexample)
            /// 
            /// </summary>
            public int getNumLines(string messagevector)
                {
                return m_ts.fnMessageVector_getNumLines(messagevector);
                }

            /// <summary>
            /// Push a line onto the back of the list.
            ///    @param msg Text that makes up the message
            ///    @param tag Numerical value associated with this message, useful for searching.
            ///    @tsexample
            ///    // Add the message...
            ///    HudMessageVector.insertLine(1, \"Hello World\", 0);
            ///    @endtsexample
            ///    @return False if insertPos is greater than the number of lines in the current vector)
            /// 
            /// </summary>
            public bool insertLine(string messagevector, int insertPos, string msg, int tag)
                {
                return m_ts.fnMessageVector_insertLine(messagevector, insertPos, msg, tag);
                }

            /// <summary>
            /// Pop a line from the back of the list; destroys the line.
            ///    @tsexample
            ///    HudMessageVector.popBackLine();
            ///    @endtsexample
            ///    @return False if there are no lines to pop (underflow), true otherwise)
            /// 
            /// </summary>
            public bool popBackLine(string messagevector)
                {
                return m_ts.fnMessageVector_popBackLine(messagevector);
                }

            /// <summary>
            /// Pop a line from the front of the vector, destroying the line.
            ///    @tsexample
            ///    HudMessageVector.popFrontLine();
            ///    @endtsexample
            ///    @return False if there are no lines to pop (underflow), true otherwise)
            /// 
            /// </summary>
            public bool popFrontLine(string messagevector)
                {
                return m_ts.fnMessageVector_popFrontLine(messagevector);
                }

            /// <summary>
            /// Push a line onto the back of the list.
            ///    @param msg Text that makes up the message
            ///    @param tag Numerical value associated with this message, useful for searching.
            ///    @tsexample
            ///    // Add the message...
            ///    HudMessageVector.pushBackLine(\"Hello World\", 0);
            ///    @endtsexample)
            /// 
            /// </summary>
            public void pushBackLine(string messagevector, string msg, int tag)
                {
                m_ts.fnMessageVector_pushBackLine(messagevector, msg, tag);
                }

            /// <summary>
            /// Push a line onto the front of the vector.
            ///    @param msg Text that makes up the message
            ///    @param tag Numerical value associated with this message, useful for searching.
            ///    @tsexample
            ///    // Add the message...
            ///    HudMessageVector.pushFrontLine(\"Hello World\", 0);
            ///    @endtsexample)
            /// 
            /// </summary>
            public void pushFrontLine(string messagevector, string msg, int tag)
                {
                m_ts.fnMessageVector_pushFrontLine(messagevector, msg, tag);
                }
            }

        #endregion

        #region Nested type: MissionAreaObject

        /// <summary>
        /// 
        /// </summary>
        public class MissionAreaObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public MissionAreaObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Returns 4 fields: starting x, starting y, extents x, extents y.)
            /// 
            /// </summary>
            public string getArea(string missionarea)
                {
                return m_ts.fnMissionArea_getArea(missionarea);
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Force trigger an inspectPostApply. This will transmit 
            ///                    material and other fields ( not including nodes ) to client objects.
            ///                    )
            /// 
            /// </summary>
            public void postApply(string missionarea)
                {
                m_ts.fnMissionArea_postApply(missionarea);
                }

            /// <summary>
            /// @brief - Defines the size of the MissionArea
            /// 			  param x Starting X coordinate position for MissionArea
            /// 			  param y Starting Y coordinate position for MissionArea
            /// 			  param width New width of the MissionArea
            /// 			  param height New height of the MissionArea
            ///            @note Only the server object may be set.
            /// 			  )
            /// 
            /// </summary>
            public void setArea(string missionarea, int x, int y, int width, int height)
                {
                m_ts.fnMissionArea_setArea(missionarea, x, y, width, height);
                }
            }

        #endregion

        #region Nested type: NetConnectionObject

        /// <summary>
        /// 
        /// </summary>
        public class NetConnectionObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public NetConnectionObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Ensures that all configured packet rates and sizes meet minimum requirements.
            /// 
            ///    This method is normally only called when a NetConnection class is first constructed.  It need 
            ///    only be manually called if the global variables that set the packet rate or size have changed.
            /// 
            ///    @note If @$pref::Net::PacketRateToServer, @$pref::Net::PacketRateToClient or @$pref::Net::PacketSize 
            ///    have been changed since a NetConnection has been created, this method must be called on 
            ///    all connections for them to follow the new rates or size.)
            /// 
            /// </summary>
            public void checkMaxRate(string netconnection)
                {
                m_ts.fnNetConnection_checkMaxRate(netconnection);
                }

            /// <summary>
            /// @brief On the server, resets the connection to indicate that motion spline paths have not been transmitted.
            /// 
            ///    Typically when a mission has ended on the server, all connected clients are informed of this change 
            ///    and their connections are reset back to a starting state.  This method resets a connection on the 
            ///    server to indicate that motion spline paths have not been transmitted.
            /// 
            ///    @tsexample
            ///       // Inform the clients
            ///       for (%clientIndex = 0; %clientIndex  ClientGroup.getCount(); %clientIndex++)
            ///       {
            ///          // clear ghosts and paths from all clients
            ///          %cl = ClientGroup.getObject(%clientIndex);
            ///          %cl.endMission();
            ///          %cl.resetGhosting();
            ///          %cl.clearPaths();
            ///       }
            ///    @endtsexample
            ///    
            ///    @see transmitPaths()
            ///    @see Path)
            /// 
            /// </summary>
            public void clearPaths(string netconnection)
                {
                m_ts.fnNetConnection_clearPaths(netconnection);
                }

            /// <summary>
            /// @brief Connects to the remote address.
            /// 
            ///    Attempts to connect with another NetConnection on the given address.  Typically once 
            ///    connected, a game's information is passed along from the server to the client, followed 
            ///    by the player entering the game world.  The actual procedure is dependent on 
            ///    the NetConnection subclass that is used.  i.e. GameConnection.
            /// 
            ///    @param remoteAddress The address to connect to in the form of IP:address>:port 
            ///    although the i>IP:/i> portion is optional.  The i>address/i> portion may be in the form 
            ///    of w.x.y.z or as a host name, in which case a DNS lookup will be performed.  You may also 
            ///    substitue the word i>broadcast/i> for the address to broadcast the connect request over 
            ///    the local subnet.
            /// 
            ///    @see NetConnection::connectLocal() to connect to a server running within the same process 
            ///    as the client.
            ///    )
            /// 
            /// </summary>
            public void connect(string netconnection, string remoteAddress)
                {
                m_ts.fnNetConnection_connect(netconnection, remoteAddress);
                }

            /// <summary>
            /// @brief Connects with the server that is running within the same process as the client.
            /// 
            ///    @returns An error text message upon failure, or an empty string when successful.
            /// 
            ///    @see See @ref local_connections for a description of local connections and their use.  See 
            ///    NetConnection::connect() to connect to a server running in another process (on the same machine or not).)
            /// 
            /// </summary>
            public string connectLocal(string netconnection)
                {
                return m_ts.fnNetConnection_connectLocal(netconnection);
                }

            /// <summary>
            /// @brief Returns the far end network address for the connection.
            /// 
            ///    The address will be in one of the following forms:
            ///    - b>IP:Broadcast:port>/b> for broadcast type addresses
            ///    - b>IP:address>:port>/b> for IP addresses
            ///    - b>local/b> when connected locally (server and client running in same process)
            /// 
            /// </summary>
            public string getAddress(string netconnection)
                {
                return m_ts.fnNetConnection_getAddress(netconnection);
                }

            /// <summary>
            /// @brief On server or client, convert a real id to the ghost id for this connection.
            /// 
            ///    Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use 
            ///    this method on the server or client to discover an object's ghost ID based on its real SimObject ID.
            /// 
            ///    @param realID The real SimObject ID of the object.
            ///    @returns The ghost ID of the object for this connection, or -1 if it could not be resolved.
            /// 
            ///    @see @ref ghosting_scoping for a description of the ghosting system.)
            /// 
            /// </summary>
            public int getGhostID(string netconnection, int realID)
                {
                return m_ts.fnNetConnection_getGhostID(netconnection, realID);
                }

            /// <summary>
            /// @brief Provides the number of active ghosts on the connection.
            ///    @returns The number of active ghosts.
            ///    @see @ref ghosting_scoping for a description of the ghosting system.)
            /// 
            /// </summary>
            public int getGhostsActive(string netconnection)
                {
                return m_ts.fnNetConnection_getGhostsActive(netconnection);
                }

            /// <summary>
            /// @brief Returns the percentage of packets lost per tick.
            /// 
            ///    @note This method is not yet hooked up.)
            /// 
            /// </summary>
            public int getPacketLoss(string netconnection)
                {
                return m_ts.fnNetConnection_getPacketLoss(netconnection);
                }

            /// <summary>
            /// @brief Returns the average round trip time (in ms) for the connection.
            /// 
            ///    The round trip time is recalculated every time a notify packet is received.  Notify 
            ///    packets are used to information the connection that the far end successfully received 
            ///    the sent packet.)
            /// 
            /// </summary>
            public int getPing(string netconnection)
                {
                return m_ts.fnNetConnection_getPing(netconnection);
                }

            /// <summary>
            /// @brief On the client, convert a ghost ID from this connection to a real SimObject ID.
            /// 
            ///    Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use 
            ///    this method on the client to discover an object's local SimObject ID when you only have a 
            ///    ghost ID.
            /// 
            ///    @param ghostID The ghost ID of the object as sent by the server.
            ///    @returns The SimObject ID of the object, or 0 if it could not be resolved.
            /// 
            ///    @tsexample
            ///       %object = ServerConnection.resolveGhostID( %ghostId );
            ///    @endtsexample
            /// 
            ///    @see @ref ghosting_scoping for a description of the ghosting system.)
            /// 
            /// </summary>
            public int resolveGhostID(string netconnection, int ghostID)
                {
                return m_ts.fnNetConnection_resolveGhostID(netconnection, ghostID);
                }

            /// <summary>
            /// @brief On the server, convert a ghost ID from this connection to a real SimObject ID.
            /// 
            ///    Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use 
            ///    this method on the server to discover an object's local SimObject ID when you only have a 
            ///    ghost ID.
            /// 
            ///    @param ghostID The ghost ID of the object as sent by the server.
            ///    @returns The SimObject ID of the object, or 0 if it could not be resolved.
            /// 
            ///    @tsexample
            ///       %object = %client.resolveObjectFromGhostIndex( %ghostId );
            ///    @endtsexample
            /// 
            ///    @see @ref ghosting_scoping for a description of the ghosting system.)
            /// 
            /// </summary>
            public int resolveObjectFromGhostIndex(string netconnection, int ghostID)
                {
                return m_ts.fnNetConnection_resolveObjectFromGhostIndex(netconnection, ghostID);
                }

            /// <summary>
            /// @brief Simulate network issues on the connection for testing.
            /// 
            ///    @param packetLoss The fraction of packets that will be lost.  Ranges from 0.0 (no loss) to 1.0 (complete loss)
            ///    @param delay Delays packets being transmitted by simulating a particular ping.  This is an absolute 
            ///    integer, measured in ms.)
            /// 
            /// </summary>
            public void setSimulatedNetParams(string netconnection, float packetLoss, int delay)
                {
                m_ts.fnNetConnection_setSimulatedNetParams(netconnection, packetLoss, delay);
                }

            /// <summary>
            /// @brief Sent by the server during phase 2 of the mission download to update motion spline paths.
            /// 
            ///    The server transmits all spline motion paths that are within the mission (Path) separate from 
            ///    other objects.  This is due to the potentially large number of nodes within each path, which may 
            ///    saturate a packet sent to the client.  By managing this step separately, Torque has finer control 
            ///    over how packets are organised vs. doing it during the ghosting stage.
            /// 
            ///    Internally a PathManager is used to track all paths defined within a mission on the server, and each 
            ///    one is transmitted using a PathManagerEvent.  The client side collects these events and builds the 
            ///    given paths within its own PathManager.  This is typically done during the standard mission start 
            ///    phase 2 when following Torque's example mission startup sequence.
            /// 
            ///    When a mission is ended, all paths need to be cleared from their respective path managers.
            /// 
            ///    @tsexample
            ///    function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
            ///    {
            ///       // Make sure to ignore calls from a previous mission load
            ///       if (%seq != $missionSequence || !$MissionRunning)
            ///          return;
            ///       if (%client.currentPhase != 1.5)
            ///          return;
            ///       %client.currentPhase = 2;
            ///    
            ///       // Set the player datablock choice
            ///       %client.playerDB = %playerDB;
            ///    
            ///       // Update mission paths (SimPath), this needs to get there before the objects.
            ///       %client.transmitPaths();
            ///    
            ///       // Start ghosting objects to the client
            ///       %client.activateGhosting();
            ///    }
            ///    @endtsexample
            ///    
            ///    @see clearPaths()
            ///    @see Path)
            /// 
            /// </summary>
            public void transmitPaths(string netconnection)
                {
                m_ts.fnNetConnection_transmitPaths(netconnection);
                }
            }

        #endregion

        #region Nested type: NetObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class NetObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public NetObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Undo the effects of a scopeToClient() call.
            /// 
            ///    @param client The connection to remove this object's scoping from 
            ///    
            ///    @see scopeToClient())
            /// 
            /// </summary>
            public void clearScopeToClient(string netobject, string client)
                {
                m_ts.fnNetObject_clearScopeToClient(netobject, client);
                }

            /// <summary>
            /// @brief Returns a pointer to the client object when on a local connection.
            /// 
            ///    Short-Circuit-Networking: this is only valid for a local-client / singleplayer situation.
            /// 
            ///    @returns the SimObject ID of the client object.
            /// 
            ///    @tsexample
            ///       // Psuedo-code, some values left out for this example
            ///       %node = new ParticleEmitterNode(){};
            ///       %clientObject = %node.getClientObject();
            ///       if(isObject(%clientObject)
            ///       	%clientObject.setTransform(\"0 0 0\");
            ///    @endtsexample
            ///    
            ///    @see @ref local_connections)
            /// 
            /// </summary>
            public int getClientObject(string netobject)
                {
                return m_ts.fnNetObject_getClientObject(netobject);
                }

            /// <summary>
            /// @brief Get the ghost index of this object from the server.
            /// 
            ///    @returns The ghost ID of this NetObject on the server
            /// 
            ///    @tsexample
            ///       %ghostID = LocalClientConnection.getGhostId( %serverObject );
            ///    @endtsexample)
            /// 
            /// </summary>
            public int getGhostID(string netobject)
                {
                return m_ts.fnNetObject_getGhostID(netobject);
                }

            /// <summary>
            /// @brief Returns a pointer to the client object when on a local connection.
            /// 
            ///    Short-Circuit-Netorking: this is only valid for a local-client / singleplayer situation.
            ///    
            ///    @returns The SimObject ID of the server object.
            ///    @tsexample
            ///       // Psuedo-code, some values left out for this example
            ///       %node = new ParticleEmitterNode(){};
            ///       %serverObject = %node.getServerObject();
            ///       if(isObject(%serverObject)
            ///       	%serverObject.setTransform(\"0 0 0\");
            ///    @endtsexample
            ///    
            ///    @see @ref local_connections)
            /// 
            /// </summary>
            public int getServerObject(string netobject)
                {
                return m_ts.fnNetObject_getServerObject(netobject);
                }

            /// <summary>
            /// @brief Called to check if an object resides on the clientside.
            ///    @return True if the object resides on the client, false otherwise.)
            /// 
            /// </summary>
            public bool isClientObject(string netobject)
                {
                return m_ts.fnNetObject_isClientObject(netobject);
                }

            /// <summary>
            /// @brief Checks if an object resides on the server.
            ///    @return True if the object resides on the server, false otherwise.)
            /// 
            /// </summary>
            public bool isServerObject(string netobject)
                {
                return m_ts.fnNetObject_isServerObject(netobject);
                }

            /// <summary>
            /// @brief Cause the NetObject to be forced as scoped on the specified NetConnection.
            /// 
            ///    @param client The connection this object will always be scoped to
            /// 
            ///    @tsexample
            ///       // Called to create new cameras in TorqueScript
            ///       // %this - The active GameConnection
            ///       // %spawnPoint - The spawn point location where we creat the camera
            ///       function GameConnection::spawnCamera(%this, %spawnPoint)
            ///       {
            ///       	// If this connection's camera exists
            ///       	if(isObject(%this.camera))
            ///       	{
            ///       		// Add it to the mission group to be cleaned up later
            ///       		MissionCleanup.add( %this.camera );
            ///       		// Force it to scope to the client side
            ///       		%this.camera.scopeToClient(%this);
            ///       	}
            ///       }
            ///    @endtsexample
            ///    
            ///    @see clearScopeToClient())
            /// 
            /// </summary>
            public void scopeToClient(string netobject, string client)
                {
                m_ts.fnNetObject_scopeToClient(netobject, client);
                }

            /// <summary>
            /// @brief Always scope this object on all connections.
            /// 
            ///    The object is marked as ScopeAlways and is immediately ghosted to 
            ///    all active connections.  This function has no effect if the object 
            ///    is not marked as Ghostable.)
            /// 
            /// </summary>
            public void setScopeAlways(string netobject)
                {
                m_ts.fnNetObject_setScopeAlways(netobject);
                }
            }

        #endregion

        #region Nested type: ParticleDataObject

        /// <summary>
        /// 
        /// </summary>
        public class ParticleDataObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ParticleDataObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Reloads this particle.
            ///    @tsexample
            ///    // Get the editor's current particle
            ///    %particle = PE_ParticleEditor.currParticle
            ///    // Change a particle value
            ///    %particle.setFieldValue( %propertyField, %value );
            ///    // Reload it
            ///    %particle.reload();
            ///    @endtsexample )
            /// 
            /// </summary>
            public void reload(string particledata)
                {
                m_ts.fnParticleData_reload(particledata);
                }
            }

        #endregion

        #region Nested type: ParticleEmitterDataObject

        /// <summary>
        /// 
        /// </summary>
        public class ParticleEmitterDataObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ParticleEmitterDataObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Reloads the ParticleData datablocks and other fields used by this emitter.
            ///    @tsexample
            ///    // Get the editor's current particle emitter
            ///    %emitter = PE_EmitterEditor.currEmitter
            ///    // Change a field value
            ///    %emitter.setFieldValue( %propertyField, %value );
            ///    // Reload this emitter
            ///    %emitter.reload();
            ///    @endtsexample)
            /// 
            /// </summary>
            public void reload(string particleemitterdata)
                {
                m_ts.fnParticleEmitterData_reload(particleemitterdata);
                }
            }

        #endregion

        #region Nested type: ParticleEmitterNodeObject

        /// <summary>
        /// 
        /// </summary>
        public class ParticleEmitterNodeObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ParticleEmitterNodeObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Turns the emitter on or off.
            ///    @param active New emitter state )
            /// 
            /// </summary>
            public void setActive(string particleemitternode, bool active)
                {
                m_ts.fnParticleEmitterNode_setActive(particleemitternode, active);
                }

            /// <summary>
            /// Assigns the datablock for this emitter node.
            ///    @param emitterDatablock ParticleEmitterData datablock to assign
            ///    @tsexample
            ///    // Assign a new emitter datablock
            ///    %emitter.setEmitterDatablock( %emitterDatablock );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void setEmitterDataBlock(string particleemitternode, string emitterDatablock)
                {
                m_ts.fnParticleEmitterNode_setEmitterDataBlock(particleemitternode, emitterDatablock);
                }
            }

        #endregion

        #region Nested type: PathCameraObject

        /// <summary>
        /// 
        /// </summary>
        public class PathCameraObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PathCameraObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Removes the knot at the front of the camera's path.
            /// 													@tsexample
            /// 														// Remove the first knot in the camera's path.
            /// 														%pathCamera.popFront();
            /// 													@endtsexample)
            /// 
            /// </summary>
            public void popFront(string pathcamera)
                {
                m_ts.fnPathCamera_popFront(pathcamera);
                }

            /// <summary>
            /// Normal, Linear), 
            /// 											      @brief Adds a new knot to the back of a path camera's path.
            /// 													@param transform Transform for the new knot.  In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform()
            /// 													@param speed Speed setting for this knot.
            /// 													@param type Knot type (Normal, Position Only, Kink).
            /// 													@param path %Path type (Linear, Spline).
            /// 													@tsexample
            /// 														// Transform vector for new knot. (Pos_X Pos_Y Pos_Z Rot_X Rot_Y Rot_Z Angle)
            /// 														%transform = \"15.0 5.0 5.0 1.4 1.0 0.2 1.0\"
            /// 														// Speed setting for knot.
            /// 														%speed = \"1.0\"
            /// 														// Knot type. (Normal, Position Only, Kink)
            /// 														%type = \"Normal\";
            /// 														// Path Type. (Linear, Spline)
            /// 														%path = \"Linear\";
            /// 														// Inform the path camera to add a new knot to the back of its path
            /// 														%pathCamera.pushBack(%transform,%speed,%type,%path);
            /// 													@endtsexample)
            /// 
            /// </summary>
            public void pushBack(string pathcamera, TransformF transform, float speed, string type, string path)
                {
                m_ts.fnPathCamera_pushBack(pathcamera, transform.AsString(), speed, type, path);
                }

            /// <summary>
            /// Normal, Linear), 
            /// 											      @brief Adds a new knot to the front of a path camera's path.
            /// 													@param transform Transform for the new knot. In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform()
            /// 													@param speed Speed setting for this knot.
            /// 													@param type Knot type (Normal, Position Only, Kink).
            /// 													@param path %Path type (Linear, Spline).
            /// 													@tsexample
            /// 														// Transform vector for new knot. (Pos_X,Pos_Y,Pos_Z,Rot_X,Rot_Y,Rot_Z,Angle)
            /// 														%transform = \"15.0 5.0 5.0 1.4 1.0 0.2 1.0\"
            /// 														// Speed setting for knot.
            /// 														%speed = \"1.0\";
            /// 														// Knot type. (Normal, Position Only, Kink)
            /// 														%type = \"Normal\";
            /// 														// Path Type. (Linear, Spline)
            /// 														%path = \"Linear\";
            /// 														// Inform the path camera to add a new knot to the front of its path
            /// 														%pathCamera.pushFront(%transform, %speed, %type, %path);
            /// 													@endtsexample)
            /// 
            /// </summary>
            public void pushFront(string pathcamera, TransformF transform, float speed, string type, string path)
                {
                m_ts.fnPathCamera_pushFront(pathcamera, transform.AsString(), speed, type, path);
                }

            /// <summary>
            /// @brief Clear the camera's path and set the camera's current transform as the start of the new path.
            ///                                        What specifically occurs is a new knot is created from the camera's current transform.  Then the current path 
            ///                                        is cleared and the new knot is pushed onto the path.  Any previous target is cleared and the camera's movement 
            ///                                        state is set to Forward.  The camera is now ready for a new path to be defined.
            /// 													@param speed Speed for the camera to move along its path after being reset.
            /// 													@tsexample
            /// 														//Determine the new movement speed of this camera. If not set, the speed will default to 1.0.
            /// 														%speed = \"0.50\";
            /// 														// Inform the path camera to start a new path at
            ///                                           // the camera's current position, and set the new 
            ///                                           // path's speed value.
            /// 														%pathCamera.reset(%speed);
            ///                                        @endtsexample)
            /// 
            /// </summary>
            public void reset(string pathcamera, float speed)
                {
                m_ts.fnPathCamera_reset(pathcamera, speed);
                }

            /// <summary>
            /// Set the current position of the camera along the path.
            /// 													@param position Position along the path, from 0.0 (path start) - 1.0 (path end), to place the camera.
            /// 													@tsexample
            ///                                           // Set the camera on a position along its path from 0.0 - 1.0.
            /// 														%position = \"0.35\";
            /// 														// Force the pathCamera to its new position along the path.
            /// 														%pathCamera.setPosition(%position);
            /// 													@endtsexample)
            /// 
            /// </summary>
            public void setPosition(string pathcamera, float position)
                {
                m_ts.fnPathCamera_setPosition(pathcamera, position);
                }

            /// <summary>
            /// forward), Set the movement state for this path camera.
            /// 													@param newState New movement state type for this camera. Forward, Backward or Stop.
            /// 													@tsexample
            /// 														// Set the state type (forward, backward, stop).
            ///                                           // In this example, the camera will travel from the first node
            ///                                           // to the last node (or target if given with setTarget())
            /// 														%state = \"forward\";
            /// 														// Inform the pathCamera to change its movement state to the defined value.
            /// 														%pathCamera.setState(%state);
            /// 													@endtsexample)
            /// 
            /// </summary>
            public void setState(string pathcamera, string newState)
                {
                m_ts.fnPathCamera_setState(pathcamera, newState);
                }

            /// <summary>
            /// @brief Set the movement target for this camera along its path.
            ///                                        The camera will attempt to move along the path to the given target in the direction provided 
            ///                                        by setState() (the default is forwards).  Once the camera moves past this target it will come 
            ///                                        to a stop, and the target state will be cleared.
            /// 													@param position Target position, between 0.0 (path start) and 1.0 (path end), for the camera to move to along its path.
            /// 													@tsexample
            ///                                           // Set the position target, between 0.0 (path start) and 1.0 (path end), for this camera to move to.
            /// 														%position = \"0.50\";
            /// 														// Inform the pathCamera of the new target position it will move to.
            /// 														%pathCamera.setTarget(%position);
            /// 													@endtsexample)
            /// 
            /// </summary>
            public void setTarget(string pathcamera, float position)
                {
                m_ts.fnPathCamera_setTarget(pathcamera, position);
                }
            }

        #endregion

        #region Nested type: PathedInteriorObject

        /// <summary>
        /// 
        /// </summary>
        public class PathedInteriorObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PathedInteriorObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (PathedInterior, setPathPosition, void, 3, 3, )
            /// 
            /// </summary>
            public void setPathPosition(string pathedinterior, string a2 = "")
                {
                m_ts.fnPathedInterior_setPathPosition(pathedinterior, a2);
                }

            /// <summary>
            /// (PathedInterior, setTargetPosition, void, 3, 3, )
            /// 
            /// </summary>
            public void setTargetPosition(string pathedinterior, string a2 = "")
                {
                m_ts.fnPathedInterior_setTargetPosition(pathedinterior, a2);
                }
            }

        #endregion

        #region Nested type: PersistenceManagerObject

        /// <summary>
        /// 
        /// </summary>
        public class PersistenceManagerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PersistenceManagerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( PersistenceManager, clearAll, void, 2, 2, ()
            ///               Clears all the tracked objects without saving them. )
            /// 
            /// </summary>
            public void clearAll(string persistencemanager = "")
                {
                m_ts.fnPersistenceManager_clearAll(persistencemanager);
                }

            /// <summary>
            /// ( PersistenceManager, deleteObjectsFromFile, void, 3, 3, ( fileName )
            ///               Delete all of the objects that are created from the given file. )
            /// 
            /// </summary>
            public void deleteObjectsFromFile(string persistencemanager, string a2 = "")
                {
                m_ts.fnPersistenceManager_deleteObjectsFromFile(persistencemanager, a2);
                }

            /// <summary>
            /// ( PersistenceManager, getDirtyObject, S32, 3, 3, ( index )
            ///               Returns the ith dirty object. )
            /// 
            /// </summary>
            public int getDirtyObject(string persistencemanager, string a2 = "")
                {
                return m_ts.fnPersistenceManager_getDirtyObject(persistencemanager, a2);
                }

            /// <summary>
            /// ( PersistenceManager, getDirtyObjectCount, S32, 2, 2, ()
            ///               Returns the number of dirty objects. )
            /// 
            /// </summary>
            public int getDirtyObjectCount(string persistencemanager = "")
                {
                return m_ts.fnPersistenceManager_getDirtyObjectCount(persistencemanager);
                }

            /// <summary>
            /// ( PersistenceManager, hasDirty, bool, 2, 2, ()
            ///               Returns true if the manager has dirty objects to save. )
            /// 
            /// </summary>
            public bool hasDirty(string persistencemanager = "")
                {
                return m_ts.fnPersistenceManager_hasDirty(persistencemanager);
                }

            /// <summary>
            /// ( PersistenceManager, isDirty, bool, 3, 3, (SimObject object)
            ///               Returns true if the SimObject is on the dirty list.)
            /// 
            /// </summary>
            public bool isDirty(string persistencemanager, string a2 = "")
                {
                return m_ts.fnPersistenceManager_isDirty(persistencemanager, a2);
                }

            /// <summary>
            /// ( PersistenceManager, listDirty, void, 2, 2, ()
            ///               Prints the dirty list to the console.)
            /// 
            /// </summary>
            public void listDirty(string persistencemanager = "")
                {
                m_ts.fnPersistenceManager_listDirty(persistencemanager);
                }

            /// <summary>
            /// ( PersistenceManager, removeDirty, void, 3, 3, (SimObject object)
            ///               Remove a SimObject from the dirty list.)
            /// 
            /// </summary>
            public void removeDirty(string persistencemanager, string a2 = "")
                {
                m_ts.fnPersistenceManager_removeDirty(persistencemanager, a2);
                }

            /// <summary>
            /// ( PersistenceManager, removeField, void, 4, 4, (SimObject object, string fieldName)
            ///               Remove a specific field from an object declaration.)
            /// 
            /// </summary>
            public void removeField(string persistencemanager, string a2, string a3 = "")
                {
                m_ts.fnPersistenceManager_removeField(persistencemanager, a2, a3);
                }

            /// <summary>
            /// ( PersistenceManager, removeObjectFromFile, void, 3, 4, (SimObject object, [filename])
            ///               Remove an existing SimObject from a file (can optionally specify a different file than \
            ///                the one it was created in.)
            /// 
            /// </summary>
            public void removeObjectFromFile(string persistencemanager, string a2 = "", string a3 = "")
                {
                m_ts.fnPersistenceManager_removeObjectFromFile(persistencemanager, a2, a3);
                }

            /// <summary>
            /// ( PersistenceManager, saveDirty, bool, 2, 2, ()
            ///               Saves all of the SimObject's on the dirty list to their respective files.)
            /// 
            /// </summary>
            public bool saveDirty(string persistencemanager = "")
                {
                return m_ts.fnPersistenceManager_saveDirty(persistencemanager);
                }

            /// <summary>
            /// ( PersistenceManager, saveDirtyObject, bool, 3, 3, (SimObject object)
            ///               Save a dirty SimObject to it's file.)
            /// 
            /// </summary>
            public bool saveDirtyObject(string persistencemanager, string a2 = "")
                {
                return m_ts.fnPersistenceManager_saveDirtyObject(persistencemanager, a2);
                }

            /// <summary>
            /// ( PersistenceManager, setDirty, void, 3, 4, (SimObject object, [filename])
            ///               Mark an existing SimObject as dirty (will be written out when saveDirty() is called).)
            /// 
            /// </summary>
            public void setDirty(string persistencemanager, string a2 = "", string a3 = "")
                {
                m_ts.fnPersistenceManager_setDirty(persistencemanager, a2, a3);
                }
            }

        #endregion

        #region Nested type: PhysicalZoneObject

        /// <summary>
        /// 
        /// </summary>
        public class PhysicalZoneObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PhysicalZoneObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Activate the physical zone's effects.
            /// 													@tsexample
            /// 														// Activate effects for a specific physical zone.
            /// 														%thisPhysicalZone.activate();
            /// 													@endtsexample
            /// 													@ingroup Datablocks
            /// 				  )
            /// 
            /// </summary>
            public void activate(string physicalzone)
                {
                m_ts.fnPhysicalZone_activate(physicalzone);
                }

            /// <summary>
            /// Deactivate the physical zone's effects.
            /// 													@tsexample
            /// 														// Deactivate effects for a specific physical zone.
            /// 														%thisPhysicalZone.deactivate();
            /// 													@endtsexample
            /// 													@ingroup Datablocks
            /// 				  )
            /// 
            /// </summary>
            public void deactivate(string physicalzone)
                {
                m_ts.fnPhysicalZone_deactivate(physicalzone);
                }
            }

        #endregion

        #region Nested type: PhysicsDebrisDataObject

        /// <summary>
        /// 
        /// </summary>
        public class PhysicsDebrisDataObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PhysicsDebrisDataObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( PhysicsDebrisData, preload, void, 2, 2, 
            ///    @brief Loads some information to have readily available at simulation time.
            ///    Forces generation of shaders, materials, and other data used by the %PhysicsDebris object. 
            ///    This function should be used while a level is loading in order to shorten 
            ///    the amount of time to create a PhysicsDebris in game.)
            /// 
            /// </summary>
            public void preload(string physicsdebrisdata = "")
                {
                m_ts.fnPhysicsDebrisData_preload(physicsdebrisdata);
                }
            }

        #endregion

        #region Nested type: PhysicsForceObject

        /// <summary>
        /// 
        /// </summary>
        public class PhysicsForceObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PhysicsForceObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Attempts to associate the PhysicsForce with a PhysicsBody.
            ///    Performs a physics ray cast of the provided length and direction. The %PhysicsForce  
            ///    will attach itself to the first dynamic PhysicsBody the ray collides with. 
            ///    On every tick, the attached body will be attracted towards the position of the %PhysicsForce.
            ///    A %PhysicsForce can only be attached to one body at a time.
            ///    @note To determine if an %attach was successful, check isAttached() immediately after 
            ///    calling this function.n)
            /// 
            /// </summary>
            public void attach(string physicsforce, Point3F start, Point3F direction, float maxDist)
                {
                m_ts.fnPhysicsForce_attach(physicsforce, start.AsString(), direction.AsString(), maxDist);
                }

            /// <summary>
            /// @brief Disassociates the PhysicsForce from any attached PhysicsBody.
            ///    @param force Optional force to apply to the attached PhysicsBody 
            ///    before detaching.
            ///    @note Has no effect if the %PhysicsForce is not attached to anything.)
            /// 
            /// </summary>
            public void detach(string physicsforce, Point3F force)
                {
                m_ts.fnPhysicsForce_detach(physicsforce, force.AsString());
                }

            /// <summary>
            /// @brief Returns true if the %PhysicsForce is currently attached to an object.
            ///    @see PhysicsForce::attach())
            /// 
            /// </summary>
            public bool isAttached(string physicsforce)
                {
                return m_ts.fnPhysicsForce_isAttached(physicsforce);
                }
            }

        #endregion

        #region Nested type: PhysicsShapeObject

        /// <summary>
        /// 
        /// </summary>
        public class PhysicsShapeObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PhysicsShapeObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Disables rendering and physical simulation.
            ///    Calling destroy() will also spawn any explosions, debris, and/or destroyedShape 
            ///    defined for it, as well as remove it from the scene graph.
            ///    Destroyed objects are only created on the server. Ghosting will later update the client.
            ///    @note This does not actually delete the PhysicsShape. )
            /// 
            /// </summary>
            public void destroy(string physicsshape)
                {
                m_ts.fnPhysicsShape_destroy(physicsshape);
                }

            /// <summary>
            /// @brief Returns if a PhysicsShape has been destroyed or not. )
            /// 
            /// </summary>
            public bool isDestroyed(string physicsshape)
                {
                return m_ts.fnPhysicsShape_isDestroyed(physicsshape);
                }

            /// <summary>
            /// @brief Restores the shape to its state before being destroyed.
            ///    Re-enables rendering and physical simulation on the object and 
            ///    adds it to the client's scene graph. 
            ///    Has no effect if the shape is not destroyed.)
            /// 
            /// </summary>
            public void restore(string physicsshape)
                {
                m_ts.fnPhysicsShape_restore(physicsshape);
                }
            }

        #endregion

        #region Nested type: PlayerObject

        /// <summary>
        /// 
        /// </summary>
        public class PlayerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PlayerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Allow all poses a chance to occur.
            ///    This method resets any poses that have manually been blocked from occuring.  
            ///    This includes the regular pose states such as sprinting, crouch, being prone 
            ///    and swimming.  It also includes being able to jump and jet jump.  While this 
            ///    is allowing these poses to occur it doesn't mean that they all can due to other 
            ///    conditions.  We're just not manually blocking them from being allowed.
            ///    @see allowJumping()
            ///    @see allowJetJumping()
            ///    @see allowSprinting()
            ///    @see allowCrouching()
            ///    @see allowProne()
            ///    @see allowSwimming() )
            /// 
            /// </summary>
            public void allowAllPoses(string player)
                {
                m_ts.fnPlayer_allowAllPoses(player);
                }

            /// <summary>
            /// @brief Set if the Player is allowed to crouch.
            ///    The default is to allow crouching unless there are other environmental concerns 
            ///    that prevent it.  This method is mainly used to explicitly disallow crouching 
            ///    at any time.
            ///    @param state Set to true to allow crouching, false to disable it.
            ///    @see allowAllPoses() )
            /// 
            /// </summary>
            public void allowCrouching(string player, bool state)
                {
                m_ts.fnPlayer_allowCrouching(player, state);
                }

            /// <summary>
            /// @brief Set if the Player is allowed to jet jump.
            ///    The default is to allow jet jumping unless there are other environmental concerns 
            ///    that prevent it.  This method is mainly used to explicitly disallow jet jumping 
            ///    at any time.
            ///    @param state Set to true to allow jet jumping, false to disable it.
            ///    @see allowAllPoses() )
            /// 
            /// </summary>
            public void allowJetJumping(string player, bool state)
                {
                m_ts.fnPlayer_allowJetJumping(player, state);
                }

            /// <summary>
            /// @brief Set if the Player is allowed to jump.
            ///    The default is to allow jumping unless there are other environmental concerns 
            ///    that prevent it.  This method is mainly used to explicitly disallow jumping 
            ///    at any time.
            ///    @param state Set to true to allow jumping, false to disable it.
            ///    @see allowAllPoses() )
            /// 
            /// </summary>
            public void allowJumping(string player, bool state)
                {
                m_ts.fnPlayer_allowJumping(player, state);
                }

            /// <summary>
            /// @brief Set if the Player is allowed to go prone.
            ///    The default is to allow being prone unless there are other environmental concerns 
            ///    that prevent it.  This method is mainly used to explicitly disallow going prone 
            ///    at any time.
            ///    @param state Set to true to allow being prone, false to disable it.
            ///    @see allowAllPoses() )
            /// 
            /// </summary>
            public void allowProne(string player, bool state)
                {
                m_ts.fnPlayer_allowProne(player, state);
                }

            /// <summary>
            /// @brief Set if the Player is allowed to sprint.
            ///    The default is to allow sprinting unless there are other environmental concerns 
            ///    that prevent it.  This method is mainly used to explicitly disallow sprinting 
            ///    at any time.
            ///    @param state Set to true to allow sprinting, false to disable it.
            ///    @see allowAllPoses() )
            /// 
            /// </summary>
            public void allowSprinting(string player, bool state)
                {
                m_ts.fnPlayer_allowSprinting(player, state);
                }

            /// <summary>
            /// @brief Set if the Player is allowed to swim.
            ///    The default is to allow swimming unless there are other environmental concerns 
            ///    that prevent it.  This method is mainly used to explicitly disallow swimming 
            ///    at any time.
            ///    @param state Set to true to allow swimming, false to disable it.
            ///    @see allowAllPoses() )
            /// 
            /// </summary>
            public void allowSwimming(string player, bool state)
                {
                m_ts.fnPlayer_allowSwimming(player, state);
                }

            /// <summary>
            /// @brief Check if it is safe to dismount at this position.
            /// 
            ///    Internally this method casts a ray from oldPos to pos to determine if it hits the 
            ///    terrain, an interior object, a water object, another player, a static shape, 
            ///    a vehicle (exluding the one currently mounted), or physical zone.  If this ray 
            ///    is in the clear, then the player's bounding box is also checked for a collision at 
            ///    the pos position.  If this displaced bounding box is also in the clear, then 
            ///    checkDismountPoint() returns true.
            /// 
            ///    @param oldPos The player's current position
            ///    @param pos The dismount position to check
            ///    @return True if the dismount position is clear, false if not
            ///    
            ///    @note The player must be already mounted for this method to not assert.)
            /// 
            /// </summary>
            public bool checkDismountPoint(string player, Point3F oldPos, Point3F pos)
                {
                return m_ts.fnPlayer_checkDismountPoint(player, oldPos.AsString(), pos.AsString());
                }

            /// <summary>
            /// @brief Clears the player's current control object.
            ///    Returns control to the player. This internally calls 
            ///    Player::setControlObject(0).
            ///    @tsexample
            /// 		%player.clearControlObject();
            ///       echo(%player.getControlObject()); //-- Returns 0, player assumes control
            ///       %player.setControlObject(%vehicle);
            ///       echo(%player.getControlObject()); //-- Returns %vehicle, player controls the vehicle now.
            /// 	@endtsexample
            ///    @note If the player does not have a control object, the player will receive all moves 
            ///    from its GameConnection.  If you're looking to remove control from the player itself 
            ///    (i.e. stop sending moves to the player) use GameConnection::setControlObject() to transfer 
            ///    control to another object, such as a camera.
            ///    @see setControlObject()
            ///    @see getControlObject()
            ///    @see GameConnection::setControlObject())
            /// 
            /// </summary>
            public void clearControlObject(string player)
                {
                m_ts.fnPlayer_clearControlObject(player);
                }

            /// <summary>
            /// @brief Get the current object we are controlling.
            ///    @return ID of the ShapeBase object we control, or 0 if not controlling an 
            ///    object.
            ///    @see setControlObject()
            ///    @see clearControlObject())
            /// 
            /// </summary>
            public int getControlObject(string player)
                {
                return m_ts.fnPlayer_getControlObject(player);
                }

            /// <summary>
            /// @brief Get the named damage location and modifier for a given world position.
            /// 
            ///    the Player object can simulate different hit locations based on a pre-defined set 
            ///    of PlayerData defined percentages.  These hit percentages divide up the Player's 
            ///    bounding box into different regions.  The diagram below demonstrates how the various 
            ///    PlayerData properties split up the bounding volume:
            /// 
            ///    img src=\"images/player_damageloc.png\">
            /// 
            ///    While you may pass in any world position and getDamageLocation() will provide a best-fit 
            ///    location, you should be aware that this can produce some interesting results.  For example, 
            ///    any position that is above PlayerData::boxHeadPercentage will be considered a 'head' hit, even 
            ///    if the world position is high in the sky.  Therefore it may be wise to keep the passed in point 
            ///    to somewhere on the surface of, or within, the Player's bounding volume.
            /// 
            ///    @note This method will not return an accurate location when the player is 
            ///    prone or swimming.
            /// 
            ///    @param pos A world position for which to retrieve a body region on this player.
            /// 
            ///    @return a string containing two words (space separated strings), where the 
            ///    first is a location and the second is a modifier.
            /// 
            ///    Posible locations:ul>
            ///    li>head/li>
            ///    li>torso/li>
            ///    li>legs/li>/ul>
            /// 
            ///    Head modifiers:ul>
            ///    li>left_back/li>
            ///    li>middle_back/li>
            ///    li>right_back/li>
            ///    li>left_middle/li>
            ///    li>middle_middle/li>
            ///    li>right_middle/li>
            ///    li>left_front/li>
            ///    li>middle_front/li>
            ///    li>right_front/li>/ul>
            /// 
            ///    Legs/Torso modifiers:ul>
            ///    li>front_left/li>
            ///    li>front_right/li>
            ///    li>back_left/li>
            ///    li>back_right/li>/ul>
            /// 
            ///    @see PlayerData::boxHeadPercentage
            ///    @see PlayerData::boxHeadFrontPercentage
            ///    @see PlayerData::boxHeadBackPercentage
            ///    @see PlayerData::boxHeadLeftPercentage
            ///    @see PlayerData::boxHeadRightPercentage
            ///    @see PlayerData::boxTorsoPercentage
            ///    )
            /// 
            /// </summary>
            public string getDamageLocation(string player, Point3F pos)
                {
                return m_ts.fnPlayer_getDamageLocation(player, pos.AsString());
                }

            /// <summary>
            /// @brief Get the number of death animations available to this player.
            ///    Death animations are assumed to be named death1-N using consecutive indices. )
            /// 
            /// </summary>
            public int getNumDeathAnimations(string player)
                {
                return m_ts.fnPlayer_getNumDeathAnimations(player);
                }

            /// <summary>
            /// @brief Get the name of the player's current pose.
            /// 
            ///    The pose is one of the following:ul>
            ///    li>Stand - Standard movement pose./li>
            ///    li>Sprint - Sprinting pose./li>
            ///    li>Crouch - Crouch pose./li>
            ///    li>Prone - Prone pose./li>
            ///    li>Swim - Swimming pose./li>/ul>
            /// 
            ///    @return The current pose; one of: \"Stand\", \"Sprint\", \"Crouch\", \"Prone\", \"Swim\" )
            /// 
            /// </summary>
            public string getPose(string player)
                {
                return m_ts.fnPlayer_getPose(player);
                }

            /// <summary>
            /// @brief Get the name of the player's current state.
            /// 
            ///    The state is one of the following:ul>
            ///    li>Dead - The Player is dead./li>
            ///    li>Mounted - The Player is mounted to an object such as a vehicle./li>
            ///    li>Move - The Player is free to move.  The usual state./li>
            ///    li>Recover - The Player is recovering from a fall.  See PlayerData::recoverDelay./li>/ul>
            /// 
            ///    @return The current state; one of: \"Dead\", \"Mounted\", \"Move\", \"Recover\" )
            /// 
            /// </summary>
            public string getState(string player)
                {
                return m_ts.fnPlayer_getState(player);
                }

            /// <summary>
            /// @brief Set the main action sequence to play for this player.
            ///    @param name Name of the action sequence to set
            ///    @param hold Set to false to get a callback on the datablock when the sequence ends (PlayerData::animationDone()).  
            ///    When set to true no callback is made.
            ///    @param fsp True if first person and none of the spine nodes in the shape should animate.  False will allow the shape's 
            ///    spine nodes to animate.
            ///    @return True if succesful, false if failed
            ///    
            ///    @note The spine nodes for the Player's shape are named as follows:ul>
            ///    li>Bip01 Pelvis/li>
            ///    li>Bip01 Spine/li>
            ///    li>Bip01 Spine1/li>
            ///    li>Bip01 Spine2/li>
            ///    li>Bip01 Neck/li>
            ///    li>Bip01 Head/li>/ul>
            ///    
            ///    You cannot use setActionThread() to have the Player play one of the motion 
            ///    determined action animation sequences.  These sequences are chosen based on how 
            ///    the Player moves and the Player's current pose.  The names of these sequences are:ul>
            ///    li>root/li>
            ///    li>run/li>
            ///    li>side/li>
            ///    li>side_right/li>
            ///    li>crouch_root/li>
            ///    li>crouch_forward/li>
            ///    li>crouch_backward/li>
            ///    li>crouch_side/li>
            ///    li>crouch_right/li>
            ///    li>prone_root/li>
            ///    li>prone_forward/li>
            ///    li>prone_backward/li>
            ///    li>swim_root/li>
            ///    li>swim_forward/li>
            ///    li>swim_backward/li>
            ///    li>swim_left/li>
            ///    li>swim_right/li>
            ///    li>fall/li>
            ///    li>jump/li>
            ///    li>standjump/li>
            ///    li>land/li>
            ///    li>jet/li>/ul>
            ///    
            ///    If the player moves in any direction then the animation sequence set using this 
            ///    method will be cancelled and the chosen mation-based sequence will take over.  This makes 
            ///    great for times when the Player cannot move, such as when mounted, or when it doesn't matter 
            ///    if the action sequence changes, such as waving and saluting.
            ///    
            ///    @tsexample
            ///       // Place the player in a sitting position after being mounted
            ///       %player.setActionThread( \"sitting\", true, true );
            /// 	@endtsexample)
            /// 
            /// </summary>
            public bool setActionThread(string player, string name, bool hold, bool fsp)
                {
                return m_ts.fnPlayer_setActionThread(player, name, hold, fsp);
                }

            /// <summary>
            /// @brief Set the sequence that controls the player's arms (dynamically adjusted 
            ///    to match look direction).
            ///    @param name Name of the sequence to play on the player's arms.
            ///    @return true if successful, false if failed.
            ///    @note By default the 'look' sequence is used, if available.)
            /// 
            /// </summary>
            public bool setArmThread(string player, string name)
                {
                return m_ts.fnPlayer_setArmThread(player, name);
                }

            /// <summary>
            /// @brief Set the object to be controlled by this player
            /// 
            ///    It is possible to have the moves sent to the Player object from the 
            ///    GameConnection to be passed along to another object.  This happens, for example 
            ///    when a player is mounted to a vehicle.  The move commands pass through the Player 
            ///    and on to the vehicle (while the player remains stationary within the vehicle).  
            ///    With setControlObject() you can have the Player pass along its moves to any object.  
            ///    One possible use is for a player to move a remote controlled vehicle.  In this case 
            ///    the player does not mount the vehicle directly, but still wants to be able to control it.
            /// 
            ///    @param obj Object to control with this player
            ///    @return True if the object is valid, false if not
            /// 
            ///    @see getControlObject()
            ///    @see clearControlObject()
            ///    @see GameConnection::setControlObject())
            /// 
            /// </summary>
            public bool setControlObject(string player, string obj)
                {
                return m_ts.fnPlayer_setControlObject(player, obj);
                }
            }

        #endregion

        #region Nested type: PopupMenuObject

        /// <summary>
        /// 
        /// </summary>
        public class PopupMenuObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PopupMenuObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (PopupMenu, attachToMenuBar, void, 5, 5, (GuiCanvas, pos, title))
            /// 
            /// </summary>
            public void attachToMenuBar(string popupmenu, string a2, string a3, string a4 = "")
                {
                m_ts.fnPopupMenu_attachToMenuBar(popupmenu, a2, a3, a4);
                }

            /// <summary>
            /// (PopupMenu, checkItem, void, 4, 4, (pos, checked))
            /// 
            /// </summary>
            public void checkItem(string popupmenu, string a2, string a3 = "")
                {
                m_ts.fnPopupMenu_checkItem(popupmenu, a2, a3);
                }

            /// <summary>
            /// (PopupMenu, checkRadioItem, void, 5, 5, (firstPos, lastPos, checkPos))
            /// 
            /// </summary>
            public void checkRadioItem(string popupmenu, string a2, string a3, string a4 = "")
                {
                m_ts.fnPopupMenu_checkRadioItem(popupmenu, a2, a3, a4);
                }

            /// <summary>
            /// (PopupMenu, enableItem, void, 4, 4, (pos, enabled))
            /// 
            /// </summary>
            public void enableItem(string popupmenu, string a2, string a3 = "")
                {
                m_ts.fnPopupMenu_enableItem(popupmenu, a2, a3);
                }

            /// <summary>
            /// (PopupMenu, getItemCount, S32, 2, 2, ())
            /// 
            /// </summary>
            public int getItemCount(string popupmenu = "")
                {
                return m_ts.fnPopupMenu_getItemCount(popupmenu);
                }

            /// <summary>
            /// (PopupMenu, insertItem, S32, 3, 5, (pos[, title][, accelerator]))
            /// 
            /// </summary>
            public int insertItem(string popupmenu, string a2 = "", string a3 = "", string a4 = "")
                {
                return m_ts.fnPopupMenu_insertItem(popupmenu, a2, a3, a4);
                }

            /// <summary>
            /// (PopupMenu, insertSubMenu, S32, 5, 5, (pos, title, subMenu))
            /// 
            /// </summary>
            public int insertSubMenu(string popupmenu, string a2, string a3, string a4 = "")
                {
                return m_ts.fnPopupMenu_insertSubMenu(popupmenu, a2, a3, a4);
                }

            /// <summary>
            /// (PopupMenu, isItemChecked, bool, 3, 3, (pos))
            /// 
            /// </summary>
            public bool isItemChecked(string popupmenu, string a2 = "")
                {
                return m_ts.fnPopupMenu_isItemChecked(popupmenu, a2);
                }

            /// <summary>
            /// (PopupMenu, removeFromMenuBar, void, 2, 2, ())
            /// 
            /// </summary>
            public void removeFromMenuBar(string popupmenu = "")
                {
                m_ts.fnPopupMenu_removeFromMenuBar(popupmenu);
                }

            /// <summary>
            /// (PopupMenu, removeItem, void, 3, 3, (pos))
            /// 
            /// </summary>
            public void removeItem(string popupmenu, string a2 = "")
                {
                m_ts.fnPopupMenu_removeItem(popupmenu, a2);
                }

            /// <summary>
            /// (PopupMenu, setItem, bool, 4, 5, (pos, title[, accelerator]))
            /// 
            /// </summary>
            public bool setItem(string popupmenu, string a2, string a3 = "", string a4 = "")
                {
                return m_ts.fnPopupMenu_setItem(popupmenu, a2, a3, a4);
                }

            /// <summary>
            /// (PopupMenu, showPopup, void, 3, 5, (Canvas,[x, y]))
            /// 
            /// </summary>
            public void showPopup(string popupmenu, string a2 = "", string a3 = "", string a4 = "")
                {
                m_ts.fnPopupMenu_showPopup(popupmenu, a2, a3, a4);
                }
            }

        #endregion

        #region Nested type: PortalObject

        /// <summary>
        /// 
        /// </summary>
        public class PortalObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PortalObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Test whether the portal connects interior zones to the outdoor zone.
            ///    @return True if the portal is an exterior portal. )
            /// 
            /// </summary>
            public bool isExteriorPortal(string portal)
                {
                return m_ts.fnPortal_isExteriorPortal(portal);
                }

            /// <summary>
            /// Test whether the portal connects interior zones only.
            ///    @return True if the portal is an interior portal. )
            /// 
            /// </summary>
            public bool isInteriorPortal(string portal)
                {
                return m_ts.fnPortal_isInteriorPortal(portal);
                }
            }

        #endregion

        #region Nested type: PostEffectObject

        /// <summary>
        /// 
        /// </summary>
        public class PostEffectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PostEffectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Remove all shader macros. )
            /// 
            /// </summary>
            public void clearShaderMacros(string posteffect)
                {
                m_ts.fnPostEffect_clearShaderMacros(posteffect);
                }

            /// <summary>
            /// Disables the effect. )
            /// 
            /// </summary>
            public void disable(string posteffect)
                {
                m_ts.fnPostEffect_disable(posteffect);
                }

            /// <summary>
            /// Dumps this PostEffect shader's disassembly to a temporary text file.
            ///    @return Full path to the dumped file or an empty string if failed. )
            /// 
            /// </summary>
            public string dumpShaderDisassembly(string posteffect)
                {
                return m_ts.fnPostEffect_dumpShaderDisassembly(posteffect);
                }

            /// <summary>
            /// Enables the effect. )
            /// 
            /// </summary>
            public void enable(string posteffect)
                {
                m_ts.fnPostEffect_enable(posteffect);
                }

            /// <summary>
            /// @return Width over height of the backbuffer. )
            /// 
            /// </summary>
            public float getAspectRatio(string posteffect)
                {
                return m_ts.fnPostEffect_getAspectRatio(posteffect);
                }

            /// <summary>
            /// @return True if the effect is enabled. )
            /// 
            /// </summary>
            public bool GetEnabled(string posteffect)
                {
                return m_ts.fnPostEffect_GetEnabled(posteffect);
                }

            /// <summary>
            /// Reloads the effect shader and textures. )
            /// 
            /// </summary>
            public void reload(string posteffect)
                {
                m_ts.fnPostEffect_reload(posteffect);
                }

            /// <summary>
            /// Remove a shader macro. This will usually be called within the preProcess callback.
            ///    @param key Macro to remove. )
            /// 
            /// </summary>
            public void removeShaderMacro(string posteffect, string key)
                {
                m_ts.fnPostEffect_removeShaderMacro(posteffect, key);
                }

            /// <summary>
            /// Sets the value of a uniform defined in the shader. This will usually 
            ///    be called within the setShaderConsts callback. Array type constants are 
            ///    not supported.    
            ///    @param name Name of the constanst, prefixed with '$'. 
            ///    @param value Value to set, space seperate values with more than one element.
            ///    @tsexample
            ///    function MyPfx::setShaderConsts( %this )
            ///    {
            ///       // example float4 uniform
            ///       %this.setShaderConst( \"$colorMod\", \"1.0 0.9 1.0 1.0\" );
            ///       // example float1 uniform
            ///       %this.setShaderConst( \"$strength\", \"3.0\" );
            ///       // example integer uniform
            ///       %this.setShaderConst( \"$loops\", \"5\" );
            ///    }
            ///    @endtsexample )   
            /// 
            /// </summary>
            public void setShaderConst(string posteffect, string name, string value)
                {
                m_ts.fnPostEffect_setShaderConst(posteffect, name, value);
                }

            /// <summary>
            ///  ),
            ///    Adds a macro to the effect's shader or sets an existing one's value. 
            ///    This will usually be called within the onAdd or preProcess callback.
            ///    @param key lval of the macro.
            ///    @param value rval of the macro, or may be empty.
            ///    @tsexample
            ///    function MyPfx::onAdd( %this )
            ///    {
            ///       %this.setShaderMacro( \"NUM_SAMPLES\", \"10\" );
            ///       %this.setShaderMacro( \"HIGH_QUALITY_MODE\" );
            ///       
            ///       // In the shader looks like... 
            ///       // #define NUM_SAMPLES 10
            ///       // #define HIGH_QUALITY_MODE
            ///    }
            ///    @endtsexample )
            /// 
            /// </summary>
            public void setShaderMacro(string posteffect, string key, string value)
                {
                m_ts.fnPostEffect_setShaderMacro(posteffect, key, value);
                }

            /// <summary>
            /// This is used to set the texture file and load the texture on a running effect. 
            ///    If the texture file is not different from the current file nothing is changed.  If 
            ///    the texture cannot be found a null texture is assigned.    
            ///    @param index The texture stage index. 
            ///    @param filePath The file name of the texture to set. )
            /// 
            /// </summary>
            public void setTexture(string posteffect, int index, string filePath)
                {
                m_ts.fnPostEffect_setTexture(posteffect, index, filePath);
                }

            /// <summary>
            /// Toggles the effect between enabled / disabled.
            ///    @return True if effect is enabled. )
            /// 
            /// </summary>
            public bool toggle(string posteffect)
                {
                return m_ts.fnPostEffect_toggle(posteffect);
                }
            }

        #endregion

        #region Nested type: PrecipitationObject

        /// <summary>
        /// 
        /// </summary>
        public class PrecipitationObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public PrecipitationObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Smoothly change the maximum number of drops in the effect (from current 
            ///    value to #numDrops * @a percentage).
            ///    This method can be used to simulate a storm building or fading in intensity 
            ///    as the number of drops in the Precipitation box changes.
            ///    @param percentage New maximum number of drops value (as a percentage of 
            ///    #numDrops). Valid range is 0-1.
            ///    @param seconds Length of time (in seconds) over which to increase the drops 
            ///    percentage value. Set to 0 to change instantly.
            ///    @tsexample
            ///    %percentage = 0.5;  // The percentage, from 0 to 1, of the maximum drops to display
            ///    %seconds = 5.0;     // The length of time over which to make the change.
            ///    %precipitation.modifyStorm( %percentage, %seconds );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void modifyStorm(string precipitation, float percentage, float seconds)
                {
                m_ts.fnPrecipitation_modifyStorm(precipitation, percentage, seconds);
                }

            /// <summary>
            /// Sets the maximum number of drops in the effect, as a percentage of #numDrops.
            ///    The change occurs instantly (use modifyStorm() to change the number of drops 
            ///    over a period of time.
            ///    @param percentage New maximum number of drops value (as a percentage of 
            ///    #numDrops). Valid range is 0-1.
            ///    @tsexample
            ///    %percentage = 0.5;  // The percentage, from 0 to 1, of the maximum drops to display
            ///    %precipitation.setPercentage( %percentage );
            ///    @endtsexample
            ///    @see modifyStorm )
            /// 
            /// </summary>
            public void setPercentage(string precipitation, float percentage)
                {
                m_ts.fnPrecipitation_setPercentage(precipitation, percentage);
                }

            /// <summary>
            /// Smoothly change the turbulence parameters over a period of time.
            ///    @param max New #maxTurbulence value. Set to 0 to disable turbulence.
            ///    @param speed New #turbulenceSpeed value.
            ///    @param seconds Length of time (in seconds) over which to interpolate the 
            ///    turbulence settings. Set to 0 to change instantly.
            ///    @tsexample
            ///    %turbulence = 0.5;     // Set the new turbulence value. Set to 0 to disable turbulence.
            ///    %speed = 5.0;          // The new speed of the turbulance effect.
            ///    %seconds = 5.0;        // The length of time over which to make the change.
            ///    %precipitation.setTurbulence( %turbulence, %speed, %seconds );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void setTurbulence(string precipitation, float max, float speed, float seconds)
                {
                m_ts.fnPrecipitation_setTurbulence(precipitation, max, speed, seconds);
                }
            }

        #endregion

        #region Nested type: ProjectileObject

        /// <summary>
        /// 
        /// </summary>
        public class ProjectileObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ProjectileObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Updates the projectile's positional and collision information.
            ///                                        This function will first delete the projectile if it is a server object and is outside it's ProjectileData::lifetime. 
            ///                                        Also responsible for applying gravity, determining collisions, triggering explosions, 
            ///                                        emitting trail particles, and calculating bounces if necessary.
            /// 									            @param seconds Amount of time, in seconds since the simulation's start, to advance.
            /// 									            @tsexample
            /// 									               // Tell the projectile to process a simulation event, and provide the amount of time
            /// 										            // that has passed since the simulation began.
            /// 										            %seconds = 2.0;
            /// 										            %projectile.presimulate(%seconds);
            /// 									            @endtsexample
            ///                                        @note This function is not called if the SimObject::hidden is true.)
            /// 
            /// </summary>
            public void presimulate(string projectile, float seconds)
                {
                m_ts.fnProjectile_presimulate(projectile, seconds);
                }
            }

        #endregion

        #region Nested type: ProximityMineObject

        /// <summary>
        /// 
        /// </summary>
        public class ProximityMineObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ProximityMineObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Manually cause the mine to explode.)
            /// 
            /// </summary>
            public void explode(string proximitymine)
                {
                m_ts.fnProximityMine_explode(proximitymine);
                }
            }

        #endregion

        #region Nested type: RenderBinManagerObject

        /// <summary>
        /// 
        /// </summary>
        public class RenderBinManagerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public RenderBinManagerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Returns the bin type string. )
            /// 
            /// </summary>
            public string getBinType(string renderbinmanager)
                {
                return m_ts.fnRenderBinManager_getBinType(renderbinmanager);
                }
            }

        #endregion

        #region Nested type: RenderMeshExampleObject

        /// <summary>
        /// 
        /// </summary>
        public class RenderMeshExampleObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public RenderMeshExampleObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// A utility method for forcing a network update.)
            /// 
            /// </summary>
            public void postApply(string rendermeshexample)
                {
                m_ts.fnRenderMeshExample_postApply(rendermeshexample);
                }
            }

        #endregion

        #region Nested type: RenderPassManagerObject

        /// <summary>
        /// 
        /// </summary>
        public class RenderPassManagerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public RenderPassManagerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Add as a render bin manager to the pass. )
            /// 
            /// </summary>
            public void addManager(string renderpassmanager, string renderBin)
                {
                m_ts.fnRenderPassManager_addManager(renderpassmanager, renderBin);
                }

            /// <summary>
            /// Returns the render bin manager at the index or null if the index is out of range. )
            /// 
            /// </summary>
            public string getManager(string renderpassmanager, int index)
                {
                return m_ts.fnRenderPassManager_getManager(renderpassmanager, index);
                }

            /// <summary>
            /// Returns the total number of bin managers. )
            /// 
            /// </summary>
            public int getManagerCount(string renderpassmanager)
                {
                return m_ts.fnRenderPassManager_getManagerCount(renderpassmanager);
                }

            /// <summary>
            /// Removes a render bin manager. )
            /// 
            /// </summary>
            public void removeManager(string renderpassmanager, string renderBin)
                {
                m_ts.fnRenderPassManager_removeManager(renderpassmanager, renderBin);
                }
            }

        #endregion

        #region Nested type: RenderPassStateTokenObject

        /// <summary>
        /// 
        /// </summary>
        public class RenderPassStateTokenObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public RenderPassStateTokenObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Disables the token.)
            /// 
            /// </summary>
            public void disable(string renderpassstatetoken)
                {
                m_ts.fnRenderPassStateToken_disable(renderpassstatetoken);
                }

            /// <summary>
            /// @brief Enables the token. )
            /// 
            /// </summary>
            public void enable(string renderpassstatetoken)
                {
                m_ts.fnRenderPassStateToken_enable(renderpassstatetoken);
                }

            /// <summary>
            /// @brief Toggles the token from enabled to disabled or vice versa. )
            /// 
            /// </summary>
            public void toggle(string renderpassstatetoken)
                {
                m_ts.fnRenderPassStateToken_toggle(renderpassstatetoken);
                }
            }

        #endregion

        #region Nested type: RigidShapeObject

        /// <summary>
        /// 
        /// </summary>
        public class RigidShapeObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public RigidShapeObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Enables or disables the physics simulation on the RigidShape object.
            ///    @param isFrozen Boolean frozen state to set the object.
            ///    @tsexample
            ///    // Define the frozen state.
            ///    %isFrozen = \"true\";
            ///    // Inform the object of the defined frozen state
            ///    %thisRigidShape.freezeSim(%isFrozen);
            ///    @endtsexample
            ///    @see ShapeBaseData)
            /// 
            /// </summary>
            public void freezeSim(string rigidshape, bool isFrozen)
                {
                m_ts.fnRigidShape_freezeSim(rigidshape, isFrozen);
                }

            /// <summary>
            /// @brief Clears physic forces from the shape and sets it at rest.
            ///    @tsexample
            ///    // Inform the RigidShape object to reset.
            ///    %thisRigidShape.reset();
            ///    @endtsexample
            ///    @see ShapeBaseData)
            /// 
            /// </summary>
            public void reset(string rigidshape)
                {
                m_ts.fnRigidShape_reset(rigidshape);
                }
            }

        #endregion

        #region Nested type: RiverObject

        /// <summary>
        /// 
        /// </summary>
        public class RiverObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public RiverObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Force River to recreate its geometry.
            ///                    )
            /// 
            /// </summary>
            public void regenerate(string river)
                {
                m_ts.fnRiver_regenerate(river);
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    BatchSize is not currently used.
            ///                    )
            /// 
            /// </summary>
            public void setBatchSize(string river, float meters)
                {
                m_ts.fnRiver_setBatchSize(river, meters);
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    @see SubdivideLength field.
            ///                    )
            /// 
            /// </summary>
            public void setMaxDivisionSize(string river, float meters)
                {
                m_ts.fnRiver_setMaxDivisionSize(river, meters);
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    @see SegmentLength field.
            ///                    )
            /// 
            /// </summary>
            public void setMetersPerSegment(string river, float meters)
                {
                m_ts.fnRiver_setMetersPerSegment(river, meters);
                }

            /// <summary>
            /// Intended as a helper to developers and editor scripts.
            ///                    Sets the depth in meters of a particular node.
            ///                    )
            /// 
            /// </summary>
            public void setNodeDepth(string river, int idx, float meters)
                {
                m_ts.fnRiver_setNodeDepth(river, idx, meters);
                }
            }

        #endregion

        #region Nested type: SFXControllerObject

        /// <summary>
        /// 
        /// </summary>
        public class SFXControllerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SFXControllerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get the index of the playlist slot currently processed by the controller.
            ///    @return The slot index currently being played.
            ///    @see SFXPlayList )
            /// 
            /// </summary>
            public int getCurrentSlot(string sfxcontroller)
                {
                return m_ts.fnSFXController_getCurrentSlot(sfxcontroller);
                }

            /// <summary>
            /// Set the index of the playlist slot to play by the controller.  This can be used to seek in the playlist.
            ///    @param index Index of the playlist slot. )
            /// 
            /// </summary>
            public void setCurrentSlot(string sfxcontroller, int index)
                {
                m_ts.fnSFXController_setCurrentSlot(sfxcontroller, index);
                }
            }

        #endregion

        #region Nested type: SFXEmitterObject

        /// <summary>
        /// 
        /// </summary>
        public class SFXEmitterObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SFXEmitterObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get the sound source object from the emitter.
            ///    @return The sound source used by the emitter or null.
            ///    @note This method will return null when called on the server-side SFXEmitter object.  Only client-side ghosts 
            ///       actually hold on to %SFXSources. )
            /// 
            /// </summary>
            public string getSource(string sfxemitter)
                {
                return m_ts.fnSFXEmitter_getSource(sfxemitter);
                }

            /// <summary>
            /// Manually start playback of the emitter's sound.
            ///    If this is called on the server-side object, the play command will be related to all client-side ghosts. )
            /// 
            /// </summary>
            public void play(string sfxemitter)
                {
                m_ts.fnSFXEmitter_play(sfxemitter);
                }

            /// <summary>
            /// Manually stop playback of the emitter's sound.
            ///    If this is called on the server-side object, the stop command will be related to all client-side ghosts. )
            /// 
            /// </summary>
            public void stop(string sfxemitter)
                {
                m_ts.fnSFXEmitter_stop(sfxemitter);
                }
            }

        #endregion

        #region Nested type: SFXParameterObject

        /// <summary>
        /// 
        /// </summary>
        public class SFXParameterObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SFXParameterObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get the name of the parameter.
            ///    @return The paramete name. )
            /// 
            /// </summary>
            public string getParameterName(string sfxparameter)
                {
                return m_ts.fnSFXParameter_getParameterName(sfxparameter);
                }

            /// <summary>
            /// Reset the parameter's value to its default.
            ///    @see SFXParameter::defaultValue )
            /// 
            /// </summary>
            public void reset(string sfxparameter)
                {
                m_ts.fnSFXParameter_reset(sfxparameter);
                }
            }

        #endregion

        #region Nested type: SFXProfileObject

        /// <summary>
        /// 
        /// </summary>
        public class SFXProfileObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SFXProfileObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Return the length of the sound data in seconds.
            ///    @return The length of the sound data in seconds or 0 if the sound referenced by the profile could not be found. )
            /// 
            /// </summary>
            public float getSoundDuration(string sfxprofile)
                {
                return m_ts.fnSFXProfile_getSoundDuration(sfxprofile);
                }
            }

        #endregion

        #region Nested type: SFXSoundObject

        /// <summary>
        /// 
        /// </summary>
        public class SFXSoundObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SFXSoundObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get the total play time (in seconds) of the sound data attached to the sound.
            ///    @return 
            ///    @note Be aware that for looped sounds, this will not return the total playback time of the sound. )
            /// 
            /// </summary>
            public float getDuration(string sfxsound)
                {
                return m_ts.fnSFXSound_getDuration(sfxsound);
                }

            /// <summary>
            /// Get the current playback position in seconds.
            ///    @return The current play cursor offset. )
            /// 
            /// </summary>
            public float getPosition(string sfxsound)
                {
                return m_ts.fnSFXSound_getPosition(sfxsound);
                }

            /// <summary>
            /// Test whether the sound data associated with the sound has been fully loaded and is ready for playback.
            ///    For streamed sounds, this will be false during playback when the stream queue for the sound is starved and 
            ///    waiting for data.  For buffered sounds, only an initial loading phase will potentially cause isReady to 
            ///    return false.
            ///    @return True if the sound is ready for playback. )
            /// 
            /// </summary>
            public bool isReady(string sfxsound)
                {
                return m_ts.fnSFXSound_isReady(sfxsound);
                }

            /// <summary>
            /// Set the current playback position in seconds.
            ///    If the source is currently playing, playback will jump to the new position.  If playback is stopped or paused, 
            ///    playback will resume at the given position when play() is called.
            ///    @param position The new position of the play cursor (in seconds). )
            /// 
            /// </summary>
            public void setPosition(string sfxsound, float position)
                {
                m_ts.fnSFXSound_setPosition(sfxsound, position);
                }
            }

        #endregion

        #region Nested type: SFXSourceObject

        /// <summary>
        /// 
        /// </summary>
        public class SFXSourceObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SFXSourceObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Add a notification marker called @a name at @a pos seconds of playback.
            ///    @param name Symbolic name for the marker that will be passed to the onMarkerPassed() callback.
            ///    @param pos Playback position in seconds when the notification should trigger.  Note that this is a soft limit and there 
            ///       may be a delay between the play cursor actually passing the position and the callback being triggered.
            ///    @note For looped sounds, the marker will trigger on each iteration.
            ///    @tsexample
            ///    // Create a new source.
            ///    $source = sfxCreateSource( AudioMusicLoop2D, \"art/sound/backgroundMusic\" );
            ///    
            ///    // Assign a class to the source.
            ///    $source.class = \"BackgroundMusic\";
            ///    
            ///    // Add a playback marker at one minute into playback.
            ///    $source.addMarker( \"first\", 60 );
            ///    
            ///    // Define the callback function.  This function will be called when the playback position passes the one minute mark.
            ///    function BackgroundMusic::onMarkerPassed( %this, %markerName )
            ///    {
            ///       if( %markerName $= \"first\" )
            ///          echo( \"Playback has passed the 60 seconds mark.\" );
            ///    }
            ///    
            ///    // Play the sound.
            ///    $source.play();
            ///    @endtsexample )
            /// 
            /// </summary>
            public void addMarker(string sfxsource, string name, float pos)
                {
                m_ts.fnSFXSource_addMarker(sfxsource, name, pos);
                }

            /// <summary>
            /// Attach @a parameter to the source,
            ///    Once attached, the source will react to value changes of the given @a parameter.  Attaching a parameter 
            ///    will also trigger an initial read-out of the parameter's current value.
            ///    @param parameter The parameter to attach to the source. )
            /// 
            /// </summary>
            public void addParameter(string sfxsource, string parameter)
                {
                m_ts.fnSFXSource_addParameter(sfxsource, parameter);
                }

            /// <summary>
            /// Get the final effective volume level of the source.
            ///    This method returns the volume level as it is after source group volume modulation, fades, and distance-based 
            ///    volume attenuation have been applied to the base volume level.
            ///    @return The effective volume of the source.
            ///    @ref SFXSource_volume )
            /// 
            /// </summary>
            public float getAttenuatedVolume(string sfxsource)
                {
                return m_ts.fnSFXSource_getAttenuatedVolume(sfxsource);
                }

            /// <summary>
            /// Get the fade-in time set on the source.
            ///    This will initially be SFXDescription::fadeInTime.
            ///    @return The fade-in time set on the source in seconds.
            ///    @see SFXDescription::fadeInTime
            ///    @ref SFXSource_fades )
            /// 
            /// </summary>
            public float getFadeInTime(string sfxsource)
                {
                return m_ts.fnSFXSource_getFadeInTime(sfxsource);
                }

            /// <summary>
            /// Get the fade-out time set on the source.
            ///    This will initially be SFXDescription::fadeOutTime.
            ///    @return The fade-out time set on the source in seconds.
            ///    @see SFXDescription::fadeOutTime
            ///    @ref SFXSource_fades )
            /// 
            /// </summary>
            public float getFadeOutTime(string sfxsource)
                {
                return m_ts.fnSFXSource_getFadeOutTime(sfxsource);
                }

            /// <summary>
            /// Get the parameter at the given index.
            ///    @param index Index of the parameter to fetch.  Must be 0=index=getParameterCount().
            ///    @return The parameter at the given @a index or null if @a index is out of range.
            ///    @tsexample
            ///       // Print the name ofo each parameter attached to %source.
            ///       %numParams = %source.getParameterCount();
            ///       for( %i = 0; %i  %numParams; %i ++ )
            ///          echo( %source.getParameter( %i ).getParameterName() );
            ///    @endtsexample
            ///    @see getParameterCount )
            /// 
            /// </summary>
            public string getParameter(string sfxsource, int index)
                {
                return m_ts.fnSFXSource_getParameter(sfxsource, index);
                }

            /// <summary>
            /// Get the number of SFXParameters that are attached to the source.
            ///    @return The number of parameters attached to the source.
            ///    @tsexample
            ///       // Print the name ofo each parameter attached to %source.
            ///       %numParams = %source.getParameterCount();
            ///       for( %i = 0; %i  %numParams; %i ++ )
            ///          echo( %source.getParameter( %i ).getParameterName() );
            ///    @endtsexample
            ///    @see getParameter
            ///    @see addParameter )
            /// 
            /// </summary>
            public int getParameterCount(string sfxsource)
                {
                return m_ts.fnSFXSource_getParameterCount(sfxsource);
                }

            /// <summary>
            /// Get the pitch scale of the source.
            ///    Pitch determines the playback speed of the source (default: 1).
            ///    @return The current pitch scale factor of the source.
            ///    @see setPitch
            ///    @see SFXDescription::pitch )
            /// 
            /// </summary>
            public float getPitch(string sfxsource)
                {
                return m_ts.fnSFXSource_getPitch(sfxsource);
                }

            /// <summary>
            /// Get the current playback status.
            ///    @return Te current playback status )
            /// 
            /// </summary>
            public SFXStatus getStatus(string sfxsource)
                {
                return (SFXStatus) (m_ts.fnSFXSource_getStatus(sfxsource));
                }

            /// <summary>
            /// Get the current base volume level of the source.
            ///    This is not the final effective volume that the source is playing at but rather the starting 
            ///    volume level before source group modulation, fades, or distance-based volume attenuation are applied.
            ///    @return The current base volume level.
            ///    @see setVolume
            ///    @see SFXDescription::volume
            ///    @ref SFXSource_volume )
            /// 
            /// </summary>
            public float getVolume(string sfxsource)
                {
                return m_ts.fnSFXSource_getVolume(sfxsource);
                }

            /// <summary>
            /// Test whether the source is currently paused.
            ///    @return True if the source is in paused state, false otherwise.
            ///    @see pause
            ///    @see getStatus
            ///    @see SFXStatus )
            /// 
            /// </summary>
            public bool isPaused(string sfxsource)
                {
                return m_ts.fnSFXSource_isPaused(sfxsource);
                }

            /// <summary>
            /// Test whether the source is currently playing.
            ///    @return True if the source is in playing state, false otherwise.
            ///    @see play
            ///    @see getStatus
            ///    @see SFXStatus )
            /// 
            /// </summary>
            public bool isPlaying(string sfxsource)
                {
                return m_ts.fnSFXSource_isPlaying(sfxsource);
                }

            /// <summary>
            /// Test whether the source is currently stopped.
            ///    @return True if the source is in stopped state, false otherwise.
            ///    @see stop
            ///    @see getStatus
            ///    @see SFXStatus )
            /// 
            /// </summary>
            public bool isStopped(string sfxsource)
                {
                return m_ts.fnSFXSource_isStopped(sfxsource);
                }

            /// <summary>
            /// Pause playback of the source.
            ///    @param fadeOutTime Seconds for the sound to fade down to zero volume.  If -1, the SFXDescription::fadeOutTime 
            ///       set in the source's associated description is used.  Pass 0 to disable a fade-out effect that may be 
            ///       configured on the description.
            ///       Be aware that if a fade-out effect is used, the source will not immediately to paused state but will 
            ///       rather remain in playing state until the fade-out time has expired.. )
            /// 
            /// </summary>
            public void pause(string sfxsource, float fadeOutTime)
                {
                m_ts.fnSFXSource_pause(sfxsource, fadeOutTime);
                }

            /// <summary>
            /// Start playback of the source.
            ///    If the sound data for the source has not yet been fully loaded, there will be a delay after calling 
            ///    play and playback will start after the data has become available.
            ///    @param fadeInTime Seconds for the sound to reach full volume.  If -1, the SFXDescription::fadeInTime 
            ///       set in the source's associated description is used.  Pass 0 to disable a fade-in effect that may 
            ///       be configured on the description. )
            /// 
            /// </summary>
            public void play(string sfxsource, float fadeInTime)
                {
                m_ts.fnSFXSource_play(sfxsource, fadeInTime);
                }

            /// <summary>
            /// Detach @a parameter from the source.
            ///    Once detached, the source will no longer react to value changes of the given @a parameter.
            ///    If the parameter is not attached to the source, the method will do nothing.
            ///    @param parameter The parameter to detach from the source. )
            /// 
            /// </summary>
            public void removeParameter(string sfxsource, string parameter)
                {
                m_ts.fnSFXSource_removeParameter(sfxsource, parameter);
                }

            /// <summary>
            /// Set up the 3D volume cone for the source.
            ///    @param innerAngle Angle of the inner sound cone in degrees (@ref SFXDescription::coneInsideAngle).  Must be 0=innerAngle=360.
            ///    @param outerAngle Angle of the outer sound cone in degrees (@ref SFXDescription::coneOutsideAngle).  Must be 0=outerAngle=360.
            ///    @param outsideVolume Volume scale factor outside of outer cone (@ref SFXDescription::coneOutsideVolume).  Must be 0=outsideVolume=1.
            ///    @note This method has no effect on the source if the source is not 3D. )
            /// 
            /// </summary>
            public void setCone(string sfxsource, float innerAngle, float outerAngle, float outsideVolume)
                {
                m_ts.fnSFXSource_setCone(sfxsource, innerAngle, outerAngle, outsideVolume);
                }

            /// <summary>
            /// Set the fade time parameters of the source.
            ///    @param fadeInTime The new fade-in time in seconds.
            ///    @param fadeOutTime The new fade-out time in seconds.
            ///    @see SFXDescription::fadeInTime
            ///    @see SFXDescription::fadeOutTime
            ///    @ref SFXSource_fades )
            /// 
            /// </summary>
            public void setFadeTimes(string sfxsource, float fadeInTime, float fadeOutTime)
                {
                m_ts.fnSFXSource_setFadeTimes(sfxsource, fadeInTime, fadeOutTime);
                }

            /// <summary>
            /// Set the pitch scale of the source.
            ///    Pitch determines the playback speed of the source (default: 1).
            ///    @param pitch The new pitch scale factor.
            ///    @see getPitch
            ///    @see SFXDescription::pitch )
            /// 
            /// </summary>
            public void setPitch(string sfxsource, float pitch)
                {
                m_ts.fnSFXSource_setPitch(sfxsource, pitch);
                }

            /// <summary>
            /// ( SFXSource, setTransform, void, 3, 4,
            ///    ( vector position [, vector direction ] ) 
            ///    Set the position and orientation of a 3D sound source.
            ///    @hide )
            /// 
            /// </summary>
            public void setTransform(string sfxsource, string a2 = "", string a3 = "")
                {
                m_ts.fnSFXSource_setTransform(sfxsource, a2, a3);
                }

            /// <summary>
            /// Set the base volume level for the source.
            ///    This volume will be the starting point for source group volume modulation, fades, and distance-based 
            ///    volume attenuation.
            ///    @param volume The new base volume level for the source.  Must be 0>=volume=1.
            ///    @see getVolume
            ///    @ref SFXSource_volume )
            /// 
            /// </summary>
            public void setVolume(string sfxsource, float volume)
                {
                m_ts.fnSFXSource_setVolume(sfxsource, volume);
                }

            /// <summary>
            /// Stop playback of the source.
            ///    @param fadeOutTime Seconds for the sound to fade down to zero volume.  If -1, the SFXDescription::fadeOutTime 
            ///       set in the source's associated description is used.  Pass 0 to disable a fade-out effect that may be 
            ///       configured on the description.
            ///       Be aware that if a fade-out effect is used, the source will not immediately transtion to stopped state but 
            ///       will rather remain in playing state until the fade-out time has expired. )
            /// 
            /// </summary>
            public void stop(string sfxsource, float fadeOutTime)
                {
                m_ts.fnSFXSource_stop(sfxsource, fadeOutTime);
                }
            }

        #endregion

        #region Nested type: SFXStateObject

        /// <summary>
        /// 
        /// </summary>
        public class SFXStateObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SFXStateObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Increase the activation count on the state.
            ///    If the state isn't already active and it is not disabled, the state will be activated.
            ///    @see isActive
            ///    @see deactivate )
            /// 
            /// </summary>
            public void activate(string sfxstate)
                {
                m_ts.fnSFXState_activate(sfxstate);
                }

            /// <summary>
            /// Decrease the activation count on the state.
            ///    If the count reaches zero and the state was not disabled, the state will be deactivated.
            ///    @see isActive
            ///    @see activate )
            /// 
            /// </summary>
            public void deactivate(string sfxstate)
                {
                m_ts.fnSFXState_deactivate(sfxstate);
                }

            /// <summary>
            /// Increase the disabling count of the state.
            ///    If the state is currently active, it will be deactivated.
            ///    @see isDisabled )
            /// 
            /// </summary>
            public void disable(string sfxstate)
                {
                m_ts.fnSFXState_disable(sfxstate);
                }

            /// <summary>
            /// Decrease the disabling count of the state.
            ///    If the disabling count reaches zero while the activation count is still non-zero, 
            ///       the state will be reactivated again.
            ///    @see isDisabled )
            /// 
            /// </summary>
            public void enable(string sfxstate)
                {
                m_ts.fnSFXState_enable(sfxstate);
                }

            /// <summary>
            /// Test whether the state is currently active.
            ///    This is true when the activation count is >0 and the disabling count is =0.
            ///    @return True if the state is currently active.
            ///    @see activate )
            /// 
            /// </summary>
            public bool isActive(string sfxstate)
                {
                return m_ts.fnSFXState_isActive(sfxstate);
                }

            /// <summary>
            /// Test whether the state is currently disabled.
            ///    This is true when the disabling count of the state is non-zero.
            ///    @return True if the state is disabled.
            ///    @see disable )
            /// 
            /// </summary>
            public bool isDisabled(string sfxstate)
                {
                return m_ts.fnSFXState_isDisabled(sfxstate);
                }
            }

        #endregion

        #region Nested type: ScatterSkyObject

        /// <summary>
        /// 
        /// </summary>
        public class ScatterSkyObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ScatterSkyObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Apply a full network update of all fields to all clients.                   
            ///                   )
            /// 
            /// </summary>
            public void applyChanges(string scattersky)
                {
                m_ts.fnScatterSky_applyChanges(scattersky);
                }
            }

        #endregion

        #region Nested type: SceneObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class SceneObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SceneObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Get Euler rotation of this object.
            ///    @return the orientation of the object in the form of rotations around the 
            ///    X, Y and Z axes in degrees. )
            /// 
            /// </summary>
            public Point3F getEulerRotation(string sceneobject)
                {
                return new Point3F(m_ts.fnSceneObject_getEulerRotation(sceneobject));
                }

            /// <summary>
            /// Get the direction this object is facing.
            ///    @return a vector indicating the direction this object is facing.
            ///    @note This is the object's y axis. )
            /// 
            /// </summary>
            public Point3F getForwardVector(string sceneobject)
                {
                return new Point3F(m_ts.fnSceneObject_getForwardVector(sceneobject));
                }

            /// <summary>
            /// Get the object's inverse transform.
            ///    @return the inverse transform of the object )
            /// 
            /// </summary>
            public TransformF getInverseTransform(string sceneobject)
                {
                return new TransformF(m_ts.fnSceneObject_getInverseTransform(sceneobject));
                }

            /// <summary>
            /// Get the object mounted at a particular slot.
            ///    @param slot mount slot index to query
            ///    @return ID of the object mounted in the slot, or 0 if no object. )
            /// 
            /// </summary>
            public int getMountedObject(string sceneobject, int slot)
                {
                return m_ts.fnSceneObject_getMountedObject(sceneobject, slot);
                }

            /// <summary>
            /// Get the number of objects mounted to us.
            ///    @return the number of mounted objects. )
            /// 
            /// </summary>
            public int getMountedObjectCount(string sceneobject)
                {
                return m_ts.fnSceneObject_getMountedObjectCount(sceneobject);
                }

            /// <summary>
            /// @brief Get the mount node index of the object mounted at our given slot.
            ///    @param slot mount slot index to query
            ///    @return index of the mount node used by the object mounted in this slot. )
            /// 
            /// </summary>
            public int getMountedObjectNode(string sceneobject, int slot)
                {
                return m_ts.fnSceneObject_getMountedObjectNode(sceneobject, slot);
                }

            /// <summary>
            /// @brief Get the object mounted at our given node index.
            ///    @param node mount node index to query
            ///    @return ID of the first object mounted at the node, or 0 if none found. )
            /// 
            /// </summary>
            public int getMountNodeObject(string sceneobject, int node)
                {
                return m_ts.fnSceneObject_getMountNodeObject(sceneobject, node);
                }

            /// <summary>
            /// Get the object's bounding box (relative to the object's origin).
            ///    @return six fields, two Point3Fs, containing the min and max points of the 
            ///    objectbox. )
            /// 
            /// </summary>
            public Box3F getObjectBox(string sceneobject)
                {
                return new Box3F(m_ts.fnSceneObject_getObjectBox(sceneobject));
                }

            /// <summary>
            /// @brief Get the object we are mounted to.
            ///    @return the SimObjectID of the object we're mounted to, or 0 if not mounted. )
            /// 
            /// </summary>
            public int getObjectMount(string sceneobject)
                {
                return m_ts.fnSceneObject_getObjectMount(sceneobject);
                }

            /// <summary>
            /// Get the object's world position.
            ///    @return the current world position of the object )
            /// 
            /// </summary>
            public Point3F getPosition(string sceneobject)
                {
                return new Point3F(m_ts.fnSceneObject_getPosition(sceneobject));
                }

            /// <summary>
            /// Get the right vector of the object.
            ///    @return a vector indicating the right direction of this object.
            ///    @note This is the object's x axis. )
            /// 
            /// </summary>
            public Point3F getRightVector(string sceneobject)
                {
                return new Point3F(m_ts.fnSceneObject_getRightVector(sceneobject));
                }

            /// <summary>
            /// Get the object's scale.
            ///    @return object scale as a Point3F )
            /// 
            /// </summary>
            public Point3F getScale(string sceneobject)
                {
                return new Point3F(m_ts.fnSceneObject_getScale(sceneobject));
                }

            /// <summary>
            /// Get the object's transform.
            ///    @return the current transform of the object )
            /// 
            /// </summary>
            public TransformF getTransform(string sceneobject)
                {
                return new TransformF(m_ts.fnSceneObject_getTransform(sceneobject));
                }

            /// <summary>
            /// Return the type mask for this object.
            ///    @return The numeric type mask for the object. )
            /// 
            /// </summary>
            public int getType(string sceneobject)
                {
                return m_ts.fnSceneObject_getType(sceneobject);
                }

            /// <summary>
            /// Get the up vector of the object.
            ///    @return a vector indicating the up direction of this object.
            ///    @note This is the object's z axis. )
            /// 
            /// </summary>
            public Point3F getUpVector(string sceneobject)
                {
                return new Point3F(m_ts.fnSceneObject_getUpVector(sceneobject));
                }

            /// <summary>
            /// Get the object's world bounding box.
            ///    @return six fields, two Point3Fs, containing the min and max points of the 
            ///    worldbox. )
            /// 
            /// </summary>
            public Box3F getWorldBox(string sceneobject)
                {
                return new Box3F(m_ts.fnSceneObject_getWorldBox(sceneobject));
                }

            /// <summary>
            /// Get the center of the object's world bounding box.
            ///    @return the center of the world bounding box for this object. )
            /// 
            /// </summary>
            public Point3F getWorldBoxCenter(string sceneobject)
                {
                return new Point3F(m_ts.fnSceneObject_getWorldBoxCenter(sceneobject));
                }

            /// <summary>
            /// Check if this object has a global bounds set.
            ///    If global bounds are set to be true, then the object is assumed to have an 
            ///    infinitely large bounding box for collision and rendering purposes.
            ///    @return true if the object has a global bounds. )
            /// 
            /// </summary>
            public bool isGlobalBounds(string sceneobject)
                {
                return m_ts.fnSceneObject_isGlobalBounds(sceneobject);
                }

            /// <summary>
            /// @brief Check if we are mounted to another object.
            ///    @return true if mounted to another object, false if not mounted. )
            /// 
            /// </summary>
            public bool isMounted(string sceneobject)
                {
                return m_ts.fnSceneObject_isMounted(sceneobject);
                }

            /// <summary>
            /// @brief Mount objB to this object at the desired slot with optional transform.
            /// 
            ///    @param objB  Object to mount onto us
            ///    @param slot  Mount slot ID
            ///    @param txfm (optional) mount offset transform
            ///    @return true if successful, false if failed (objB is not valid) )
            /// 
            /// </summary>
            public bool mountObject(string sceneobject, string objB, int slot, TransformF txfm)
                {
                return m_ts.fnSceneObject_mountObject(sceneobject, objB, slot, txfm.AsString());
                }

            /// <summary>
            /// Set the object's scale.
            ///    @param scale object scale to set )
            /// 
            /// </summary>
            public void setScale(string sceneobject, Point3F scale)
                {
                m_ts.fnSceneObject_setScale(sceneobject, scale.AsString());
                }

            /// <summary>
            /// Set the object's transform (orientation and position).
            ///    @param txfm object transform to set )
            /// 
            /// </summary>
            public void setTransform(string sceneobject, TransformF txfm)
                {
                m_ts.fnSceneObject_setTransform(sceneobject, txfm.AsString());
                }

            /// <summary>
            /// Unmount us from the currently mounted object if any. )
            /// 
            /// </summary>
            public void unmount(string sceneobject)
                {
                m_ts.fnSceneObject_unmount(sceneobject);
                }

            /// <summary>
            /// @brief Unmount an object from ourselves.
            /// 
            ///    @param target object to unmount
            ///    @return true if successful, false if failed )
            /// 
            /// </summary>
            public bool unmountObject(string sceneobject, string target)
                {
                return m_ts.fnSceneObject_unmountObject(sceneobject, target);
                }
            }

        #endregion

        #region Nested type: SettingsObject

        /// <summary>
        /// 
        /// </summary>
        public class SettingsObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SettingsObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (Settings, beginGroup, void, 3, 4, settingObj.beginGroup(groupName, fromStart = false);)
            /// 
            /// </summary>
            public void beginGroup(string settings, string a2 = "", string a3 = "")
                {
                m_ts.fnSettings_beginGroup(settings, a2, a3);
                }

            /// <summary>
            /// (Settings, clearGroups, void, 2, 2, settingObj.clearGroups();)
            /// 
            /// </summary>
            public void clearGroups(string settings = "")
                {
                m_ts.fnSettings_clearGroups(settings);
                }

            /// <summary>
            /// (Settings, endGroup, void, 2, 2, settingObj.endGroup();)
            /// 
            /// </summary>
            public void endGroup(string settings = "")
                {
                m_ts.fnSettings_endGroup(settings);
                }

            /// <summary>
            /// (Settings, findFirstValue, const char*, 2, 5, settingObj.findFirstValue();)
            /// 
            /// </summary>
            public string findFirstValue(string settings = "", string a2 = "", string a3 = "", string a4 = "")
                {
                return m_ts.fnSettings_findFirstValue(settings, a2, a3, a4);
                }

            /// <summary>
            /// (Settings, findNextValue, const char*, 2, 2, settingObj.findNextValue();)
            /// 
            /// </summary>
            public string findNextValue(string settings = "")
                {
                return m_ts.fnSettings_findNextValue(settings);
                }

            /// <summary>
            /// (Settings, getCurrentGroups, const char*, 2, 2, settingObj.getCurrentGroups();)
            /// 
            /// </summary>
            public string getCurrentGroups(string settings = "")
                {
                return m_ts.fnSettings_getCurrentGroups(settings);
                }

            /// <summary>
            /// (Settings, read, bool, 2, 2, %success = settingObj.read();)
            /// 
            /// </summary>
            public bool read(string settings = "")
                {
                return m_ts.fnSettings_read(settings);
                }

            /// <summary>
            /// (Settings, remove, void, 3, 4, settingObj.remove(settingName, includeDefaults = false);)
            /// 
            /// </summary>
            public void remove(string settings, string a2 = "", string a3 = "")
                {
                m_ts.fnSettings_remove(settings, a2, a3);
                }

            /// <summary>
            /// (Settings, setDefaultValue, void, 4, 4, settingObj.setDefaultValue(settingName, value);)
            /// 
            /// </summary>
            public void setDefaultValue(string settings, string a2, string a3 = "")
                {
                m_ts.fnSettings_setDefaultValue(settings, a2, a3);
                }

            /// <summary>
            /// (Settings, setValue, void, 3, 4, settingObj.setValue(settingName, value);)
            /// 
            /// </summary>
            public void setValue(string settings, string a2 = "", string a3 = "")
                {
                m_ts.fnSettings_setValue(settings, a2, a3);
                }

            /// <summary>
            /// (Settings, value, const char*, 3, 4, settingObj.value(settingName, defaultValue);)
            /// 
            /// </summary>
            public string value(string settings, string a2 = "", string a3 = "")
                {
                return m_ts.fnSettings_value(settings, a2, a3);
                }

            /// <summary>
            /// (Settings, write, bool, 2, 2, %success = settingObj.write();)
            /// 
            /// </summary>
            public bool write(string settings = "")
                {
                return m_ts.fnSettings_write(settings);
                }
            }

        #endregion

        #region Nested type: ShaderDataObject

        /// <summary>
        /// 
        /// </summary>
        public class ShaderDataObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ShaderDataObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Rebuilds all the vertex and pixel shader instances created from this ShaderData.
            /// 
            /// 				   @tsexample
            /// 				   // Rebuild the shader instances from ShaderData CloudLayerShader
            /// 				   CloudLayerShader.reload();
            /// 				   @endtsexample)
            /// 
            /// </summary>
            public void reload(string shaderdata)
                {
                m_ts.fnShaderData_reload(shaderdata);
                }
            }

        #endregion

        #region Nested type: ShapeBaseDataObject

        /// <summary>
        /// 
        /// </summary>
        public class ShapeBaseDataObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ShapeBaseDataObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Check if there is the space at the given transform is free to spawn into.
            /// 
            ///    The shape's bounding box volume is used to check for collisions at the given world 
            ///    transform.  Only interior and static objects are checked for collision.
            /// 
            ///    @param txfm Deploy transform to check
            ///    @return True if the space is free, false if there is already something in 
            ///    the way.
            /// 
            ///    @note This is a server side only check, and is not actually limited to spawning.)
            /// 
            /// </summary>
            public bool checkDeployPos(string shapebasedata, TransformF txfm)
                {
                return m_ts.fnShapeBaseData_checkDeployPos(shapebasedata, txfm.AsString());
                }

            /// <summary>
            /// @brief Helper method to get a transform from a position and vector (suitable for use with setTransform).
            ///    @param pos Desired transform position
            ///    @param normal Vector of desired direction
            ///    @return The deploy transform )
            /// 
            /// </summary>
            public TransformF getDeployTransform(string shapebasedata, Point3F pos, Point3F normal)
                {
                return new TransformF(m_ts.fnShapeBaseData_getDeployTransform(shapebasedata, pos.AsString(), normal.AsString()));
                }
            }

        #endregion

        #region Nested type: ShapeBaseObject

        /// <summary>
        /// 
        /// </summary>
        public class ShapeBaseObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ShapeBaseObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Increment the current damage level by the specified amount.
            /// 
            ///    @param amount value to add to current damage level )
            /// 
            /// </summary>
            public void applyDamage(string shapebase, float amount)
                {
                m_ts.fnShapeBase_applyDamage(shapebase, amount);
                }

            /// <summary>
            /// @brief Apply an impulse to the object.
            /// 
            ///    @param pos world position of the impulse
            ///    @param vec impulse momentum (velocity * mass)
            ///    @return true )
            /// 
            /// </summary>
            public bool applyImpulse(string shapebase, Point3F pos, Point3F vec)
                {
                return m_ts.fnShapeBase_applyImpulse(shapebase, pos.AsString(), vec.AsString());
                }

            /// <summary>
            /// @brief Repair damage by the specified amount.
            /// 
            ///    Note that the damage level is only reduced by repairRate per tick, so it may 
            ///    take several ticks for the total repair to complete.
            /// 
            ///    @param amount total repair value (subtracted from damage level over time) )
            /// 
            /// </summary>
            public void applyRepair(string shapebase, float amount)
                {
                m_ts.fnShapeBase_applyRepair(shapebase, amount);
                }

            /// <summary>
            /// @brief Check if this object can cloak.
            ///    @return true
            ///    
            ///    @note Not implemented as it always returns true.)
            /// 
            /// </summary>
            public bool canCloak(string shapebase)
                {
                return m_ts.fnShapeBase_canCloak(shapebase);
                }

            /// <summary>
            /// @brief Change one of the materials on the shape.
            /// 
            ///    This method changes materials per mapTo with others. The material that 
            ///    is being replaced is mapped to unmapped_mat as a part of this transition.
            /// 
            ///    @note Warning, right now this only sort of works. It doesn't do a live 
            ///    update like it should.
            /// 
            ///    @param mapTo the name of the material target to remap (from getTargetName)
            ///    @param oldMat the old Material that was mapped 
            ///    @param newMat the new Material to map
            /// 
            ///    @tsexample
            ///    // remap the first material in the shape
            ///    %mapTo = %obj.getTargetName( 0 );
            ///    %obj.changeMaterial( %mapTo, 0, MyMaterial );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void changeMaterial(string shapebase, string mapTo, string oldMat, string newMat)
                {
                m_ts.fnShapeBase_changeMaterial(shapebase, mapTo, oldMat, newMat);
                }

            /// <summary>
            /// @brief Destroy an animation thread, which prevents it from playing.
            /// 
            ///    @param slot thread slot to destroy
            ///    @return true if successful, false if failed
            ///    
            ///    @see playThread )
            /// 
            /// </summary>
            public bool destroyThread(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_destroyThread(shapebase, slot);
                }

            /// <summary>
            /// @brief Print a list of visible and hidden meshes in the shape to the console 
            ///    for debugging purposes.
            ///    @note Only in a SHIPPING build.)
            /// 
            /// </summary>
            public void dumpMeshVisibility(string shapebase)
                {
                m_ts.fnShapeBase_dumpMeshVisibility(shapebase);
                }

            /// <summary>
            /// @brief Get the position at which the AI should stand to repair things.
            /// 
            ///    If the shape defines a node called \"AIRepairNode\", this method will 
            ///    return the current world position of that node, otherwise \"0 0 0\".
            ///    @return the AI repair position )
            /// 
            /// </summary>
            public Point3F getAIRepairPoint(string shapebase)
                {
                return new Point3F(m_ts.fnShapeBase_getAIRepairPoint(shapebase));
                }

            /// <summary>
            /// @brief Returns the vertical field of view in degrees for this object if used as a camera.
            /// 
            ///    @return current FOV as defined in ShapeBaseData::cameraDefaultFov )
            /// 
            /// </summary>
            public float getCameraFov(string shapebase)
                {
                return m_ts.fnShapeBase_getCameraFov(shapebase);
                }

            /// <summary>
            /// @brief Get the client (if any) that controls this object.
            /// 
            ///    The controlling client is the one that will send moves to us to act on.
            /// 
            ///    @return the ID of the controlling GameConnection, or 0 if this object is not 
            ///    controlled by any client.
            ///    
            ///    @see GameConnection)
            /// 
            /// </summary>
            public int getControllingClient(string shapebase)
                {
                return m_ts.fnShapeBase_getControllingClient(shapebase);
                }

            /// <summary>
            /// @brief Get the object (if any) that controls this object.
            /// 
            ///    @return the ID of the controlling ShapeBase object, or 0 if this object is 
            ///    not controlled by another object. )
            /// 
            /// </summary>
            public int getControllingObject(string shapebase)
                {
                return m_ts.fnShapeBase_getControllingObject(shapebase);
                }

            /// <summary>
            /// @brief Get the damage flash level.
            /// 
            ///    @return flash level
            /// 
            ///    @see setDamageFlash )
            /// 
            /// </summary>
            public float getDamageFlash(string shapebase)
                {
                return m_ts.fnShapeBase_getDamageFlash(shapebase);
                }

            /// <summary>
            /// @brief Get the object's current damage level.
            /// 
            ///    @return damage level
            ///    
            ///    @see setDamageLevel())
            /// 
            /// </summary>
            public float getDamageLevel(string shapebase)
                {
                return m_ts.fnShapeBase_getDamageLevel(shapebase);
                }

            /// <summary>
            /// @brief Get the object's current damage level as a percentage of maxDamage.
            /// 
            ///    @return damageLevel / datablock.maxDamage
            ///    
            ///    @see setDamageLevel())
            /// 
            /// </summary>
            public float getDamagePercent(string shapebase)
                {
                return m_ts.fnShapeBase_getDamagePercent(shapebase);
                }

            /// <summary>
            /// @brief Get the object's damage state.
            /// 
            ///    @return the damage state; one of \"Enabled\", \"Disabled\", \"Destroyed\"
            ///    
            ///    @see setDamageState())
            /// 
            /// </summary>
            public string getDamageState(string shapebase)
                {
                return m_ts.fnShapeBase_getDamageState(shapebase);
                }

            /// <summary>
            /// @brief Returns the default vertical field of view in degrees for this object if used as a camera.
            /// 
            ///    @return Default FOV )
            /// 
            /// </summary>
            public float getDefaultCameraFov(string shapebase)
                {
                return m_ts.fnShapeBase_getDefaultCameraFov(shapebase);
                }

            /// <summary>
            /// @brief Get the object's current energy level.
            /// 
            ///    @return energy level
            ///    
            ///    @see setEnergyLevel())
            /// 
            /// </summary>
            public float getEnergyLevel(string shapebase)
                {
                return m_ts.fnShapeBase_getEnergyLevel(shapebase);
                }

            /// <summary>
            /// @brief Get the object's current energy level as a percentage of maxEnergy.
            ///    @return energyLevel / datablock.maxEnergy
            /// 
            ///    @see setEnergyLevel())
            /// 
            /// </summary>
            public float getEnergyPercent(string shapebase)
                {
                return m_ts.fnShapeBase_getEnergyPercent(shapebase);
                }

            /// <summary>
            /// @brief Get the position of the 'eye' for this object.
            /// 
            ///    If the object model has a node called 'eye', this method will return that 
            ///    node's current world position, otherwise it will return the object's current 
            ///    world position.
            /// 
            ///    @return the eye position for this object
            /// 
            ///    @see getEyeVector
            ///    @see getEyeTransform )
            /// 
            /// </summary>
            public Point3F getEyePoint(string shapebase)
                {
                return new Point3F(m_ts.fnShapeBase_getEyePoint(shapebase));
                }

            /// <summary>
            /// @brief Get the 'eye' transform for this object.
            /// 
            ///    If the object model has a node called 'eye', this method will return that 
            ///    node's current transform, otherwise it will return the object's current 
            ///    transform.
            /// 
            ///    @return the eye transform for this object
            /// 
            ///    @see getEyeVector
            ///    @see getEyePoint )
            /// 
            /// </summary>
            public TransformF getEyeTransform(string shapebase)
                {
                return new TransformF(m_ts.fnShapeBase_getEyeTransform(shapebase));
                }

            /// <summary>
            /// @brief Get the forward direction of the 'eye' for this object.
            /// 
            ///    If the object model has a node called 'eye', this method will return that 
            ///    node's current forward direction vector, otherwise it will return the 
            ///    object's current forward direction vector.
            /// 
            ///    @return the eye vector for this object
            /// 
            ///    @see getEyePoint
            ///    @see getEyeTransform )
            /// 
            /// </summary>
            public Point3F getEyeVector(string shapebase)
                {
                return new Point3F(m_ts.fnShapeBase_getEyeVector(shapebase));
                }

            /// <summary>
            /// @brief Get the alt trigger state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return the Image's current alt trigger state )
            /// 
            /// </summary>
            public bool getImageAltTrigger(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getImageAltTrigger(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the ammo state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return the Image's current ammo state )
            /// 
            /// </summary>
            public bool getImageAmmo(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getImageAmmo(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the generic trigger state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @param trigger Generic trigger number
            ///    @return the Image's current generic trigger state )
            /// 
            /// </summary>
            public bool getImageGenericTrigger(string shapebase, int slot, int trigger)
                {
                return m_ts.fnShapeBase_getImageGenericTrigger(shapebase, slot, trigger);
                }

            /// <summary>
            /// @brief Get the loaded state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return the Image's current loaded state )
            /// 
            /// </summary>
            public bool getImageLoaded(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getImageLoaded(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the script animation prefix of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return the Image's current script animation prefix )
            /// 
            /// </summary>
            public string getImageScriptAnimPrefix(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getImageScriptAnimPrefix(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the skin tag ID for the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return the skinTag value passed to mountImage when the image was 
            ///    mounted )
            /// 
            /// </summary>
            public int getImageSkinTag(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getImageSkinTag(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the name of the current state of the Image in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return name of the current Image state, or \"Error\" if slot is invalid )
            /// 
            /// </summary>
            public string getImageState(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getImageState(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the target state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return the Image's current target state )
            /// 
            /// </summary>
            public bool getImageTarget(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getImageTarget(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the trigger state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return the Image's current trigger state )
            /// 
            /// </summary>
            public bool getImageTrigger(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getImageTrigger(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the world position this object is looking at.
            /// 
            ///    Casts a ray from the eye and returns information about what the ray hits.
            /// 
            ///    @param distance maximum distance of the raycast
            ///    @param typeMask typeMask of objects to include for raycast collision testing
            ///    @return look-at information as \"Object HitX HitY HitZ [Material]\" or empty string for no hit
            /// 
            ///    @tsexample
            ///    %lookat = %obj.getLookAtPoint();
            ///    echo( \"Looking at: \" @ getWords( %lookat, 1, 3 ) );
            ///    @endtsexample )
            /// 
            /// </summary>
            public string getLookAtPoint(string shapebase, float distance, int typeMask)
                {
                return m_ts.fnShapeBase_getLookAtPoint(shapebase, distance, typeMask);
                }

            /// <summary>
            /// Get the object's maxDamage level.  
            ///    @return datablock.maxDamage)    
            /// 
            /// </summary>
            public float getMaxDamage(string shapebase)
                {
                return m_ts.fnShapeBase_getMaxDamage(shapebase);
                }

            /// <summary>
            /// @brief Get the model filename used by this shape.
            /// 
            ///    @return the shape filename )
            /// 
            /// </summary>
            public string getModelFile(string shapebase)
                {
                return m_ts.fnShapeBase_getModelFile(shapebase);
                }

            /// <summary>
            /// @brief Get the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return ID of the ShapeBaseImageData datablock mounted in the slot, or 0 
            ///    if no Image is mounted there. )
            /// 
            /// </summary>
            public int getMountedImage(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getMountedImage(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the first slot the given datablock is mounted to on this object.
            /// 
            ///    @param image ShapeBaseImageData datablock to query
            ///    @return index of the first slot the Image is mounted in, or -1 if the Image 
            ///    is not mounted in any slot on this object. )
            /// 
            /// 
            /// </summary>
            public int getMountSlot(string shapebase, string image)
                {
                return m_ts.fnShapeBase_getMountSlot(shapebase, image);
                }

            /// <summary>
            /// @brief Get the muzzle position of the Image mounted in the specified slot.
            /// 
            ///    If the Image shape contains a node called 'muzzlePoint', then the muzzle 
            ///    position is the position of that node in world space. If no such node 
            ///    is specified, the slot's mount node is used instead.
            /// 
            ///    @param slot Image slot to query
            ///    @return the muzzle position, or \"0 0 0\" if the slot is invalid )
            /// 
            /// </summary>
            public Point3F getMuzzlePoint(string shapebase, int slot)
                {
                return new Point3F(m_ts.fnShapeBase_getMuzzlePoint(shapebase, slot));
                }

            /// <summary>
            /// @brief Get the muzzle vector of the Image mounted in the specified slot.
            /// 
            ///    If the Image shape contains a node called 'muzzlePoint', then the muzzle 
            ///    vector is the forward direction vector of that node's transform in world 
            ///    space. If no such node is specified, the slot's mount node is used 
            ///    instead.
            /// 
            ///    If the correctMuzzleVector flag (correctMuzzleVectorTP in 3rd person) 
            ///    is set in the Image, the muzzle vector is computed to point at whatever 
            ///    object is right in front of the object's 'eye' node.
            /// 
            ///    @param slot Image slot to query
            ///    @return the muzzle vector, or \"0 1 0\" if the slot is invalid )
            /// 
            /// </summary>
            public Point3F getMuzzleVector(string shapebase, int slot)
                {
                return new Point3F(m_ts.fnShapeBase_getMuzzleVector(shapebase, slot));
                }

            /// <summary>
            /// @brief Get the Image that will be mounted next in the specified slot.
            /// 
            ///    Calling mountImage when an Image is already mounted does one of two things: 
            ///    ol>li>Mount the new Image immediately, the old Image is discarded and 
            ///    whatever state it was in is ignored./li>
            ///    li>If the current Image state does not allow Image changes, the new 
            ///    Image is marked as pending, and will not be mounted until the current 
            ///    state completes. eg. if the user changes weapons, you may wish to ensure 
            ///    that the current weapon firing state plays to completion first./li>/ol>
            ///    This command retrieves the ID of the pending Image (2nd case above).
            ///    
            ///    @param slot Image slot to query
            ///    @return ID of the pending ShapeBaseImageData datablock, or 0 if none. )
            /// 
            /// </summary>
            public int getPendingImage(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_getPendingImage(shapebase, slot);
                }

            /// <summary>
            /// @brief Get the current recharge rate.
            /// 
            ///    @return the recharge rate (per tick)
            ///    
            ///    @see setRechargeRate())
            /// 
            /// </summary>
            public float getRechargeRate(string shapebase)
                {
                return m_ts.fnShapeBase_getRechargeRate(shapebase);
                }

            /// <summary>
            /// @brief Get the per-tick repair amount.
            /// 
            ///    @return the current value to be subtracted from damage level each tick
            /// 
            ///    @see setRepairRate )
            /// 
            /// </summary>
            public float getRepairRate(string shapebase)
                {
                return m_ts.fnShapeBase_getRepairRate(shapebase);
                }

            /// <summary>
            /// @brief Get the name of the shape.
            /// 
            ///    @note This is the name of the shape object that is sent to the client, 
            ///    not the DTS or DAE model filename.
            /// 
            ///    @return the name of the shape 
            ///    
            ///    @see setShapeName())
            /// 
            /// </summary>
            public string getShapeName(string shapebase)
                {
                return m_ts.fnShapeBase_getShapeName(shapebase);
                }

            /// <summary>
            /// @brief Get the name of the skin applied to this shape.
            /// 
            ///    @return the name of the skin 
            /// 
            ///    @see skin
            ///    @see setSkinName())
            /// 
            /// </summary>
            public string getSkinName(string shapebase)
                {
                return m_ts.fnShapeBase_getSkinName(shapebase);
                }

            /// <summary>
            /// @brief Get the world transform of the specified mount slot.
            /// 
            ///    @param slot Image slot to query
            ///    @return the mount transform )
            /// 
            /// </summary>
            public TransformF getSlotTransform(string shapebase, int slot)
                {
                return new TransformF(m_ts.fnShapeBase_getSlotTransform(shapebase, slot));
                }

            /// <summary>
            /// @brief Get the number of materials in the shape.
            /// 
            ///    @return the number of materials in the shape. 
            ///    
            ///    @see getTargetName())
            /// 
            /// </summary>
            public int getTargetCount(string shapebase)
                {
                return m_ts.fnShapeBase_getTargetCount(shapebase);
                }

            /// <summary>
            /// @brief Get the name of the indexed shape material.
            /// 
            ///    @param index index of the material to get (valid range is 0 - getTargetCount()-1).
            ///    @return the name of the indexed material.
            ///    
            ///    @see getTargetCount())
            /// 
            /// </summary>
            public string getTargetName(string shapebase, int index)
                {
                return m_ts.fnShapeBase_getTargetName(shapebase, index);
                }

            /// <summary>
            /// @brief Get the object's current velocity.
            /// 
            ///    @return the current velocity )
            /// 
            /// </summary>
            public Point3F getVelocity(string shapebase)
                {
                return new Point3F(m_ts.fnShapeBase_getVelocity(shapebase));
                }

            /// <summary>
            /// @brief Get the visible distance applied to this shape.
            ///    @return the visible distance 
            ///    @see 
            ///    @see )
            /// 
            /// </summary>
            public int getVisibleDistance(string shapebase)
                {
                return m_ts.fnShapeBase_getVisibleDistance(shapebase);
                }

            /// <summary>
            /// @brief Get the white-out level.
            /// 
            ///    @return white-out level
            /// 
            ///    @see setWhiteOut )
            /// 
            /// </summary>
            public float getWhiteOut(string shapebase)
                {
                return m_ts.fnShapeBase_getWhiteOut(shapebase);
                }

            /// <summary>
            /// @brief Check if the given state exists on the mounted Image.
            /// 
            ///    @param slot Image slot to query
            ///    @param state Image state to check for
            ///    @return true if the Image has the requested state defined. )
            /// 
            /// </summary>
            public bool hasImageState(string shapebase, int slot, string state)
                {
                return m_ts.fnShapeBase_hasImageState(shapebase, slot, state);
                }

            /// <summary>
            /// @brief Check if this object is cloaked.
            /// 
            ///    @return true if cloaked, false if not 
            ///    
            ///    @see setCloaked())
            /// 
            /// </summary>
            public bool isCloaked(string shapebase)
                {
                return m_ts.fnShapeBase_isCloaked(shapebase);
                }

            /// <summary>
            /// @brief Check if the object is in the Destroyed damage state.
            /// 
            ///    @return true if damage state is \"Destroyed\", false if not 
            ///    
            ///    @see isDisabled()
            ///    @see isEnabled())
            /// 
            /// </summary>
            public bool isDestroyed(string shapebase)
                {
                return m_ts.fnShapeBase_isDestroyed(shapebase);
                }

            /// <summary>
            /// @brief Check if the object is in the Disabled or Destroyed damage state.
            /// 
            ///    @return true if damage state is not \"Enabled\", false if it is
            ///    
            ///    @see isDestroyed()
            ///    @see isEnabled())
            /// 
            /// </summary>
            public bool isDisabled(string shapebase)
                {
                return m_ts.fnShapeBase_isDisabled(shapebase);
                }

            /// <summary>
            /// @brief Check if the object is in the Enabled damage state.
            /// 
            ///    @return true if damage state is \"Enabled\", false if not
            ///    
            ///    @see isDestroyed()
            ///    @see isDisabled())
            /// 
            /// </summary>
            public bool isEnabled(string shapebase)
                {
                return m_ts.fnShapeBase_isEnabled(shapebase);
                }

            /// <summary>
            /// Check if the object is hidden.
            ///    @return true if the object is hidden, false if visible. )
            /// 
            /// </summary>
            public bool isHidden(string shapebase)
                {
                return m_ts.fnShapeBase_isHidden(shapebase);
                }

            /// <summary>
            /// @brief Check if the current Image state is firing.
            /// 
            ///    @param slot Image slot to query
            ///    @return true if the current Image state in this slot has the 'stateFire' flag set. )
            /// 
            /// </summary>
            public bool isImageFiring(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_isImageFiring(shapebase, slot);
                }

            /// <summary>
            /// @brief Check if the given datablock is mounted to any slot on this object.
            /// 
            ///    @param image ShapeBaseImageData datablock to query
            ///    @return true if the Image is mounted to any slot, false otherwise. )
            /// 
            /// </summary>
            public bool isImageMounted(string shapebase, string image)
                {
                return m_ts.fnShapeBase_isImageMounted(shapebase, image);
                }

            /// <summary>
            ///  ),
            ///    @brief Mount a new Image.
            /// 
            ///    @param image the Image to mount
            ///    @param slot Image slot to mount into (valid range is 0 - 3)
            ///    @param loaded initial loaded state for the Image
            ///    @param skinTag tagged string to reskin the mounted Image
            ///    @return true if successful, false if failed
            /// 
            ///    @tsexample
            ///    %player.mountImage( PistolImage, 1 );
            ///    %player.mountImage( CrossbowImage, 0, false );
            ///    %player.mountImage( RocketLauncherImage, 0, true, 'blue' );
            ///    @endtsexample
            ///    
            ///    @see unmountImage()
            ///    @see getMountedImage()
            ///    @see getPendingImage()
            ///    @see isImageMounted())
            /// 
            /// </summary>
            public bool mountImage(string shapebase, string image, int slot, bool loaded, string skinTag)
                {
                return m_ts.fnShapeBase_mountImage(shapebase, image, slot, loaded, skinTag);
                }

            /// <summary>
            /// @brief Pause an animation thread.
            ///    
            ///    If restarted using playThread, the animation 
            ///    will resume from the paused position.
            ///    @param slot thread slot to stop
            ///    @return true if successful, false if failed
            ///    
            ///    @see playThread )
            /// 
            /// </summary>
            public bool pauseThread(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_pauseThread(shapebase, slot);
                }

            /// <summary>
            /// @brief Attach a sound to this shape and start playing it.
            /// 
            ///    @param slot Audio slot index for the sound (valid range is 0 - 3)    @param track SFXTrack to play
            ///    @return true if the sound was attached successfully, false if failed
            ///    
            ///    @see stopAudio())
            /// 
            /// </summary>
            public bool playAudio(string shapebase, int slot, string track)
                {
                return m_ts.fnShapeBase_playAudio(shapebase, slot, track);
                }

            /// <summary>
            ///  ),
            ///    @brief Start a new animation thread, or restart one that has been paused or 
            ///    stopped.
            /// 
            ///    @param slot thread slot to play. Valid range is 0 - 3)     @param name name of the animation sequence to play in this slot. If not 
            ///    specified, the paused or stopped thread in this slot will be resumed.
            ///    @return true if successful, false if failed
            /// 
            ///    @tsexample
            ///    %obj.playThread( 0, \"ambient\" );      // Play the ambient sequence in slot 0
            ///    %obj.setThreadTimeScale( 0, 0.5 );    // Play at half-speed
            ///    %obj.pauseThread( 0 );                // Pause the sequence
            ///    %obj.playThread( 0 );                 // Resume playback
            ///    %obj.playThread( 0, \"spin\" );         // Replace the sequence in slot 0
            ///    @endtsexample
            ///    
            ///    @see pauseThread()
            ///    @see stopThread()
            ///    @see setThreadDir()
            ///    @see setThreadTimeScale()
            ///    @see destroyThread())
            /// 
            /// </summary>
            public bool playThread(string shapebase, int slot, string name)
                {
                return m_ts.fnShapeBase_playThread(shapebase, slot, name);
                }

            /// <summary>
            /// @brief Set the hidden state on all the shape meshes.
            /// 
            ///    This allows you to hide all meshes in the shape, for example, and then only 
            ///    enable a few.
            /// 
            ///    @param hide new hidden state for all meshes )
            /// 
            /// </summary>
            public void setAllMeshesHidden(string shapebase, bool hide)
                {
                m_ts.fnShapeBase_setAllMeshesHidden(shapebase, hide);
                }

            /// <summary>
            /// @brief Set the vertical field of view in degrees for this object if used as a camera.
            /// 
            ///    @param fov new FOV value )
            /// 
            /// </summary>
            public void setCameraFov(string shapebase, float fov)
                {
                m_ts.fnShapeBase_setCameraFov(shapebase, fov);
                }

            /// <summary>
            /// @brief Set the cloaked state of this object.
            /// 
            ///    When an object is cloaked it is not rendered.
            /// 
            ///    @param cloak true to cloak the object, false to uncloak
            ///    
            ///    @see isCloaked())
            /// 
            /// </summary>
            public void setCloaked(string shapebase, bool cloak)
                {
                m_ts.fnShapeBase_setCloaked(shapebase, cloak);
                }

            /// <summary>
            /// @brief Set the damage flash level.
            /// 
            ///    Damage flash may be used as a postfx effect to flash the screen when the 
            ///    client is damaged.
            /// 
            ///    @note Relies on the flash postFx.
            /// 
            ///    @param level flash level (0-1)
            ///    
            ///    @see getDamageFlash())
            /// 
            /// </summary>
            public void setDamageFlash(string shapebase, float level)
                {
                m_ts.fnShapeBase_setDamageFlash(shapebase, level);
                }

            /// <summary>
            /// @brief Set the object's current damage level.
            /// 
            ///    @param level new damage level
            ///    
            ///    @see getDamageLevel()
            ///    @see getDamagePercent())
            /// 
            /// </summary>
            public void setDamageLevel(string shapebase, float level)
                {
                m_ts.fnShapeBase_setDamageLevel(shapebase, level);
                }

            /// <summary>
            /// @brief Set the object's damage state.
            /// 
            ///    @param state should be one of \"Enabled\", \"Disabled\", \"Destroyed\"
            ///    @return true if successful, false if failed
            ///    
            ///    @see getDamageState())
            /// 
            /// </summary>
            public bool setDamageState(string shapebase, string state)
                {
                return m_ts.fnShapeBase_setDamageState(shapebase, state);
                }

            /// <summary>
            /// @brief Set the damage direction vector.
            /// 
            ///    Currently this is only used to initialise the explosion if this object 
            ///    is blown up.
            /// 
            ///    @param vec damage direction vector
            /// 
            ///    @tsexample
            ///    %obj.setDamageVector( \"0 0 1\" );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void setDamageVector(string shapebase, Point3F vec)
                {
                m_ts.fnShapeBase_setDamageVector(shapebase, vec.AsString());
                }

            /// <summary>
            /// @brief Set this object's current energy level.
            /// 
            ///    @param level new energy level
            ///    
            ///    @see getEnergyLevel()
            ///    @see getEnergyPercent())
            /// 
            /// </summary>
            public void setEnergyLevel(string shapebase, float level)
                {
                m_ts.fnShapeBase_setEnergyLevel(shapebase, level);
                }

            /// <summary>
            /// @brief Add or remove this object from the scene.
            ///    When removed from the scene, the object will not be processed or rendered.
            ///    @param show False to hide the object, true to re-show it )
            /// 
            /// </summary>
            public void setHidden(string shapebase, bool show)
                {
                m_ts.fnShapeBase_setHidden(shapebase, show);
                }

            /// <summary>
            /// @brief Set the alt trigger state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to modify
            ///    @param state new alt trigger state for the Image
            ///    @return the Image's new alt trigger state )
            /// 
            /// </summary>
            public bool setImageAltTrigger(string shapebase, int slot, bool state)
                {
                return m_ts.fnShapeBase_setImageAltTrigger(shapebase, slot, state);
                }

            /// <summary>
            /// @brief Set the ammo state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to modify
            ///    @param state new ammo state for the Image
            ///    @return the Image's new ammo state )
            /// 
            /// </summary>
            public bool setImageAmmo(string shapebase, int slot, bool state)
                {
                return m_ts.fnShapeBase_setImageAmmo(shapebase, slot, state);
                }

            /// <summary>
            /// @brief Set the generic trigger state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to modify
            ///    @param trigger Generic trigger number
            ///    @param state new generic trigger state for the Image
            ///    @return the Image's new generic trigger state or -1 if there was a problem. )
            /// 
            /// </summary>
            public int setImageGenericTrigger(string shapebase, int slot, int trigger, bool state)
                {
                return m_ts.fnShapeBase_setImageGenericTrigger(shapebase, slot, trigger, state);
                }

            /// <summary>
            /// @brief Set the loaded state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to modify
            ///    @param state new loaded state for the Image
            ///    @return the Image's new loaded state )
            /// 
            /// </summary>
            public bool setImageLoaded(string shapebase, int slot, bool state)
                {
                return m_ts.fnShapeBase_setImageLoaded(shapebase, slot, state);
                }

            /// <summary>
            /// @brief Set the script animation prefix for the Image mounted in the specified slot.
            ///    This is used to further modify the prefix used when deciding which animation sequence to 
            ///    play while this image is mounted.
            /// 
            ///    @param slot Image slot to modify
            ///    @param prefix The prefix applied to the image )
            /// 
            /// </summary>
            public void setImageScriptAnimPrefix(string shapebase, int slot, string prefix)
                {
                m_ts.fnShapeBase_setImageScriptAnimPrefix(shapebase, slot, prefix);
                }

            /// <summary>
            /// @brief Set the target state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to modify
            ///    @param state new target state for the Image
            ///    @return the Image's new target state )
            /// 
            /// </summary>
            public bool setImageTarget(string shapebase, int slot, bool state)
                {
                return m_ts.fnShapeBase_setImageTarget(shapebase, slot, state);
                }

            /// <summary>
            /// @brief Set the trigger state of the Image mounted in the specified slot.
            /// 
            ///    @param slot Image slot to modify
            ///    @param state new trigger state for the Image
            ///    @return the Image's new trigger state )
            /// 
            /// </summary>
            public bool setImageTrigger(string shapebase, int slot, bool state)
                {
                return m_ts.fnShapeBase_setImageTrigger(shapebase, slot, state);
                }

            /// <summary>
            /// @brief Setup the invincible effect.
            /// 
            ///    This effect is used for HUD feedback to the user that they are invincible.
            ///    @note Currently not implemented
            /// 
            ///    @param time duration in seconds for the invincible effect
            ///    @param speed speed at which the invincible effect progresses )
            /// 
            /// </summary>
            public void setInvincibleMode(string shapebase, float time, float speed)
                {
                m_ts.fnShapeBase_setInvincibleMode(shapebase, time, speed);
                }

            /// <summary>
            /// @brief Set the hidden state on the named shape mesh.
            /// 
            ///    @param name name of the mesh to hide/show
            ///    @param hide new hidden state for the mesh )
            /// 
            /// </summary>
            public void setMeshHidden(string shapebase, string name, bool hide)
                {
                m_ts.fnShapeBase_setMeshHidden(shapebase, name, hide);
                }

            /// <summary>
            /// @brief Set the recharge rate.
            /// 
            ///    The recharge rate is added to the object's current energy level each tick, 
            ///    up to the maxEnergy level set in the ShapeBaseData datablock.
            ///    
            ///    @param rate the recharge rate (per tick)
            ///    
            ///    @see getRechargeRate())
            /// 
            /// </summary>
            public void setRechargeRate(string shapebase, float rate)
                {
                m_ts.fnShapeBase_setRechargeRate(shapebase, rate);
                }

            /// <summary>
            /// @brief Set amount to repair damage by each tick.
            /// 
            ///    Note that this value is separate to the repairRate field in ShapeBaseData. 
            ///    This value will be subtracted from the damage level each tick, whereas the 
            ///    ShapeBaseData field limits how much of the applyRepair value is subtracted 
            ///    each tick. Both repair types can be active at the same time.
            ///    
            ///    @param rate value to subtract from damage level each tick (must be > 0)
            ///    
            ///    @see getRepairRate())
            /// 
            /// </summary>
            public void setRepairRate(string shapebase, float rate)
                {
                m_ts.fnShapeBase_setRepairRate(shapebase, rate);
                }

            /// <summary>
            /// @brief Set the name of this shape.
            /// 
            ///    @note This is the name of the shape object that is sent to the client, 
            ///    not the DTS or DAE model filename.
            /// 
            ///    @param name new name for the shape
            ///    
            ///    @see getShapeName())
            /// 
            /// </summary>
            public void setShapeName(string shapebase, string name)
                {
                m_ts.fnShapeBase_setShapeName(shapebase, name);
                }

            /// <summary>
            /// @brief Apply a new skin to this shape.
            /// 
            ///    'Skinning' the shape effectively renames the material targets, allowing 
            ///    different materials to be used on different instances of the same model.
            /// 
            ///    @param name name of the skin to apply
            /// 
            ///    @see skin
            ///    @see getSkinName())
            /// 
            /// </summary>
            public void setSkinName(string shapebase, string name)
                {
                m_ts.fnShapeBase_setSkinName(shapebase, name);
                }

            /// <summary>
            /// @brief Set the playback direction of an animation thread.
            /// 
            ///    @param slot thread slot to modify
            ///    @param fwd true to play the animation forwards, false to play backwards
            ///    @return true if successful, false if failed
            ///    
            ///    @see playThread() )
            /// 
            /// </summary>
            public bool setThreadDir(string shapebase, int slot, bool fwd)
                {
                return m_ts.fnShapeBase_setThreadDir(shapebase, slot, fwd);
                }

            /// <summary>
            /// @brief Set the position within an animation thread.
            /// 
            ///    @param slot thread slot to modify
            ///    @param pos position within thread
            ///    @return true if successful, false if failed
            ///    
            ///    @see playThread )
            /// 
            /// </summary>
            public bool setThreadPosition(string shapebase, int slot, float pos)
                {
                return m_ts.fnShapeBase_setThreadPosition(shapebase, slot, pos);
                }

            /// <summary>
            /// @brief Set the playback time scale of an animation thread.
            /// 
            ///    @param slot thread slot to modify
            ///    @param scale new thread time scale (1=normal speed, 0.5=half speed etc)
            ///    @return true if successful, false if failed
            ///    
            ///    @see playThread )
            /// 
            /// </summary>
            public bool setThreadTimeScale(string shapebase, int slot, float scale)
                {
                return m_ts.fnShapeBase_setThreadTimeScale(shapebase, slot, scale);
                }

            /// <summary>
            /// @brief Set the object's velocity.
            /// 
            ///    @param vel new velocity for the object
            ///    @return true )
            /// 
            /// </summary>
            public bool setVelocity(string shapebase, Point3F vel)
                {
                return m_ts.fnShapeBase_setVelocity(shapebase, vel.AsString());
                }

            /// <summary>
            /// @brief Get the visible distance applied to this shape.
            ///    @return the visible distance 
            ///    @see 
            ///    @see )
            /// 
            /// </summary>
            public void setVisibleDistance(string shapebase, int dist)
                {
                m_ts.fnShapeBase_setVisibleDistance(shapebase, dist);
                }

            /// <summary>
            /// @brief Set the white-out level.
            /// 
            ///    White-out may be used as a postfx effect to brighten the screen in response 
            ///    to a game event.
            /// 
            ///    @note Relies on the flash postFx.
            /// 
            ///    @param level flash level (0-1)
            ///    
            ///    @see getWhiteOut())
            /// 
            /// </summary>
            public void setWhiteOut(string shapebase, float level)
                {
                m_ts.fnShapeBase_setWhiteOut(shapebase, level);
                }

            /// <summary>
            /// @brief Fade the object in or out without removing it from the scene.
            /// 
            ///    A faded out object is still in the scene and can still be collided with, 
            ///    so if you want to disable collisions for this shape after it fades out 
            ///    use setHidden to temporarily remove this shape from the scene.
            ///   
            ///    @note Items have the ability to light their surroundings. When an Item with 
            ///    an active light is fading out, the light it emits is correspondingly 
            ///    reduced until it goes out. Likewise, when the item fades in, the light is 
            ///    turned-up till it reaches it's normal brightntess.
            /// 
            ///    @param time duration of the fade effect in ms
            ///    @param delay delay in ms before the fade effect begins
            ///    @param fadeOut true to fade-out to invisible, false to fade-in to full visibility )
            /// 
            /// </summary>
            public void startFade(string shapebase, int time, int delay, bool fadeOut)
                {
                m_ts.fnShapeBase_startFade(shapebase, time, delay, fadeOut);
                }

            /// <summary>
            /// @brief Stop a sound started with playAudio.
            /// 
            ///    @param slot audio slot index (started with playAudio)
            ///    @return true if the sound was stopped successfully, false if failed
            ///    
            ///    @see playAudio())
            /// 
            /// </summary>
            public bool stopAudio(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_stopAudio(shapebase, slot);
                }

            /// <summary>
            /// @brief Stop an animation thread.
            /// 
            ///    If restarted using playThread, the animation 
            ///    will start from the beginning again.
            ///    @param slot thread slot to stop
            ///    @return true if successful, false if failed
            ///    
            ///    @see playThread )
            /// 
            /// </summary>
            public bool stopThread(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_stopThread(shapebase, slot);
                }

            /// <summary>
            /// @brief Unmount the mounted Image in the specified slot.
            /// 
            ///    @param slot Image slot to unmount
            ///    @return true if successful, false if failed
            ///    
            ///    @see mountImage())
            /// 
            /// </summary>
            public bool unmountImage(string shapebase, int slot)
                {
                return m_ts.fnShapeBase_unmountImage(shapebase, slot);
                }
            }

        #endregion

        #region Nested type: SimComponentObject

        /// <summary>
        /// 
        /// </summary>
        public class SimComponentObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SimComponentObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( SimComponent, addComponents, bool, 3, 64, %obj.addComponents( %compObjName, %compObjName2, ... );
            /// 			  Adds additional components to current list.
            /// 			  @param Up to 62 component names
            /// 			  @return Returns true on success, false otherwise.)
            /// 
            /// </summary>
            public bool addComponents(string simcomponent, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "", string a20 = "", string a21 = "", string a22 = "", string a23 = "", string a24 = "", string a25 = "", string a26 = "", string a27 = "", string a28 = "", string a29 = "", string a30 = "", string a31 = "", string a32 = "", string a33 = "", string a34 = "", string a35 = "", string a36 = "", string a37 = "", string a38 = "", string a39 = "", string a40 = "", string a41 = "", string a42 = "", string a43 = "", string a44 = "", string a45 = "", string a46 = "", string a47 = "", string a48 = "", string a49 = "", string a50 = "", string a51 = "", string a52 = "", string a53 = "", string a54 = "", string a55 = "", string a56 = "", string a57 = "", string a58 = "", string a59 = "", string a60 = "", string a61 = "", string a62 = "", string a63 = "")
                {
                return m_ts.fnSimComponent_addComponents(simcomponent, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63);
                }

            /// <summary>
            /// ( SimComponent, getComponent, S32, 3, 3, (idx) Get the component corresponding to the given index.
            /// 			  @param idx An integer index value corresponding to the desired component.
            /// 			  @return The id of the component at the given index as an integer)
            /// 
            /// </summary>
            public int getComponent(string simcomponent, string a2 = "")
                {
                return m_ts.fnSimComponent_getComponent(simcomponent, a2);
                }

            /// <summary>
            /// ( SimComponent, getComponentCount, S32, 2, 2, () Get the current component count
            /// 			  @return The number of components in the list as an integer)
            /// 
            /// </summary>
            public int getComponentCount(string simcomponent = "")
                {
                return m_ts.fnSimComponent_getComponentCount(simcomponent);
                }

            /// <summary>
            /// (SimComponent, getIsTemplate, bool, 2, 2, () Check whether SimComponent is currently a template
            /// 			  @return true if is a template and false if not)
            /// 
            /// </summary>
            public bool getIsTemplate(string simcomponent = "")
                {
                return m_ts.fnSimComponent_getIsTemplate(simcomponent);
                }

            /// <summary>
            /// (SimComponent, isEnabled, bool, 2, 2, () Check whether SimComponent is currently enabled
            /// 			  @return true if enabled and false if not)
            /// 
            /// </summary>
            public bool isEnabled(string simcomponent = "")
                {
                return m_ts.fnSimComponent_isEnabled(simcomponent);
                }

            /// <summary>
            /// ( SimComponent, removeComponents, bool, 3, 64, %obj.removeComponents( %compObjName, %compObjName2, ... );
            /// 			  Removes components by name from current list.
            /// 			  @param objNamex Up to 62 component names
            /// 			  @return Returns true on success, false otherwise.)
            /// 
            /// </summary>
            public bool removeComponents(string simcomponent, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "", string a20 = "", string a21 = "", string a22 = "", string a23 = "", string a24 = "", string a25 = "", string a26 = "", string a27 = "", string a28 = "", string a29 = "", string a30 = "", string a31 = "", string a32 = "", string a33 = "", string a34 = "", string a35 = "", string a36 = "", string a37 = "", string a38 = "", string a39 = "", string a40 = "", string a41 = "", string a42 = "", string a43 = "", string a44 = "", string a45 = "", string a46 = "", string a47 = "", string a48 = "", string a49 = "", string a50 = "", string a51 = "", string a52 = "", string a53 = "", string a54 = "", string a55 = "", string a56 = "", string a57 = "", string a58 = "", string a59 = "", string a60 = "", string a61 = "", string a62 = "", string a63 = "")
                {
                return m_ts.fnSimComponent_removeComponents(simcomponent, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63);
                }

            /// <summary>
            /// (SimComponent, setEnabled, void, 3, 3, (enabled) Sets or unsets the enabled flag
            /// 			  @param enabled Boolean value
            /// 			  @return No return value)
            /// 
            /// </summary>
            public void setEnabled(string simcomponent, string a2 = "")
                {
                m_ts.fnSimComponent_setEnabled(simcomponent, a2);
                }

            /// <summary>
            /// (SimComponent, setIsTemplate, void, 3, 3, (template) Sets or unsets the template flag
            /// 			  @param template Boolean value
            /// 			  @return No return value)
            /// 
            /// </summary>
            public void setIsTemplate(string simcomponent, string a2 = "")
                {
                m_ts.fnSimComponent_setIsTemplate(simcomponent, a2);
                }
            }

        #endregion

        #region Nested type: SimDataBlockObject

        /// <summary>
        /// 
        /// </summary>
        public class SimDataBlockObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SimDataBlockObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Reload the datablock.  This can only be used with a local client configuration. )
            /// 
            /// </summary>
            public void SimDataBlock_reloadOnLocalClient(string simdatablock)
                {
                m_ts.fn_SimDataBlock_reloadOnLocalClient(simdatablock);
                }
            }

        #endregion

        #region Nested type: SimObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class SimObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SimObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Copy fields from another object onto this one.  The objects must 
            ///    be of same type. Everything from the object will overwrite what's 
            ///    in this object; extra fields in this object will remain. This 
            ///    includes dynamic fields.
            ///    @param fromObject The object from which to copy fields. )
            /// 
            /// </summary>
            public void SimObject_assignFieldsFrom(string simobject, string fromObject)
                {
                m_ts.fn_SimObject_assignFieldsFrom(simobject, fromObject);
                }

            /// <summary>
            /// Delete and remove the object. )
            /// 
            /// </summary>
            public void SimObject_delete(string simobject)
                {
                m_ts.fn_SimObject_delete(simobject);
                }

            /// <summary>
            /// Dump the native C++ class hierarchy of this object's C++ class to the console. )
            /// 
            /// </summary>
            public void SimObject_dumpClassHierarchy(string simobject)
                {
                m_ts.fn_SimObject_dumpClassHierarchy(simobject);
                }

            /// <summary>
            /// List the methods defined on this object.
            ///    Each description is a newline-separated vector with the following elements:
            ///    - Minimum number of arguments.
            ///    - Maximum number of arguments.
            ///    - Prototype string.
            ///    - Full script file path (if script method).
            ///    - Line number of method definition in script (if script method).
            ///    - Documentation string (not including prototype).  This takes up the remainder of the vector.
            ///    @return An ArrayObject populated with (name,description) pairs of all methods defined on the object. )
            /// 
            /// </summary>
            public string SimObject_dumpMethods(string simobject)
                {
                return m_ts.fn_SimObject_dumpMethods(simobject);
                }

            /// <summary>
            /// Get whether the object will be included in saves.
            ///    @return True if the object will be saved; false otherwise. )
            /// 
            /// </summary>
            public bool SimObject_getCanSave(string simobject)
                {
                return m_ts.fn_SimObject_getCanSave(simobject);
                }

            /// <summary>
            /// Get the name of the C++ class which the object is an instance of.
            ///    @return The name of the C++ class of the object. )
            /// 
            /// </summary>
            public string SimObject_getClassName(string simobject)
                {
                return m_ts.fn_SimObject_getClassName(simobject);
                }

            /// <summary>
            /// Get the name of the class namespace assigned to this object.
            ///    @return The name of the 'class' namespace. )
            /// 
            /// </summary>
            public string SimObject_getClassNamespace(string simobject)
                {
                return m_ts.fn_SimObject_getClassNamespace(simobject);
                }

            /// <summary>
            /// Get the line number at which the object is defined in its file.
            ///    @return The line number of the object's definition in script.
            ///    @see getFilename())
            /// 
            /// </summary>
            public int SimObject_getDeclarationLine(string simobject)
                {
                return m_ts.fn_SimObject_getDeclarationLine(simobject);
                }

            /// <summary>
            /// Get a value of a dynamic field by index.
            ///    @param index The index of the dynamic field.
            ///    @return The value of the dynamic field at the given index or \"\". )
            /// 
            /// </summary>
            public string SimObject_getDynamicField(string simobject, int index)
                {
                return m_ts.fn_SimObject_getDynamicField(simobject, index);
                }

            /// <summary>
            /// Get the number of dynamic fields defined on the object.
            ///    @return The number of dynamic fields defined on the object. )
            /// 
            /// </summary>
            public int SimObject_getDynamicFieldCount(string simobject)
                {
                return m_ts.fn_SimObject_getDynamicFieldCount(simobject);
                }

            /// <summary>
            /// Retrieve the value of a static field by index.
            ///    @param index The index of the static field.
            ///    @return The value of the static field with the given index or \"\". )
            /// 
            /// </summary>
            public string SimObject_getField(string simobject, int index)
                {
                return m_ts.fn_SimObject_getField(simobject, index);
                }

            /// <summary>
            /// Get the number of static fields on the object.
            ///    @return The number of static fields defined on the object. )
            /// 
            /// </summary>
            public int SimObject_getFieldCount(string simobject)
                {
                return m_ts.fn_SimObject_getFieldCount(simobject);
                }

            /// <summary>
            /// Get the console type code of the given field.
            ///    @return The numeric type code for the underlying console type of the given field. )
            /// 
            /// </summary>
            public string SimObject_getFieldType(string simobject, string fieldName)
                {
                return m_ts.fn_SimObject_getFieldType(simobject, fieldName);
                }

            /// <summary>
            /// Return the value of the given field on this object.
            ///    @param fieldName The name of the field.  If it includes a field index, the index is parsed out.
            ///    @param index Optional parameter to specify the index of an array field separately.
            ///    @return The value of the given field or \"\" if undefined. )
            /// 
            /// </summary>
            public string SimObject_getFieldValue(string simobject, string fieldName, int index)
                {
                return m_ts.fn_SimObject_getFieldValue(simobject, fieldName, index);
                }

            /// <summary>
            /// Returns the filename the object is attached to.
            ///    @return The name of the file the object is associated with; usually the file the object was loaded from. )
            /// 
            /// </summary>
            public string SimObject_getFilename(string simobject)
                {
                return m_ts.fn_SimObject_getFilename(simobject);
                }

            /// <summary>
            /// Get the name of the superclass namespace assigned to this object.
            ///    @return The name of the 'superClass' namespace. )
            /// 
            /// </summary>
            public string SimObject_getSuperClassNamespace(string simobject)
                {
                return m_ts.fn_SimObject_getSuperClassNamespace(simobject);
                }

            /// <summary>
            /// Get whether the object has been marked as expanded. (in editor)
            ///    @return True if the object is marked expanded. )
            /// 
            /// </summary>
            public bool SimObject_isExpanded(string simobject)
                {
                return m_ts.fn_SimObject_isExpanded(simobject);
                }

            /// <summary>
            /// Test whether the given field is defined on this object.
            ///    @param fieldName The name of the field.
            ///    @return True if the object implements the given field. )
            /// 
            /// </summary>
            public bool SimObject_isField(string simobject, string fieldName)
                {
                return m_ts.fn_SimObject_isField(simobject, fieldName);
                }

            /// <summary>
            /// Test whether the namespace of this object is a direct or indirect child to the given namespace.
            ///    @param name The name of a namespace.
            ///    @return True if the given namespace name is within the namespace hierarchy of this object. )
            /// 
            /// </summary>
            public bool SimObject_isInNamespaceHierarchy(string simobject, string name)
                {
                return m_ts.fn_SimObject_isInNamespaceHierarchy(simobject, name);
                }

            /// <summary>
            /// Test whether this object is a member of the specified class.
            ///    @param className Name of a native C++ class.
            ///    @return True if this object is an instance of the given C++ class or any of its super classes. )
            /// 
            /// </summary>
            public bool SimObject_isMemberOfClass(string simobject, string className)
                {
                return m_ts.fn_SimObject_isMemberOfClass(simobject, className);
                }

            /// <summary>
            /// Test whether the given method is defined on this object.
            ///    @param The name of the method.
            ///    @return True if the object implements the given method. )
            /// 
            /// </summary>
            public bool SimObject_isMethod(string simobject, string methodName)
                {
                return m_ts.fn_SimObject_isMethod(simobject, methodName);
                }

            /// <summary>
            ///  ),
            ///    Save out the object to the given file.
            ///    @param fileName The name of the file to save to.
            ///    @param selectedOnly If true, only objects marked as selected will be saved out.
            ///    @param preAppendString Text which will be preprended directly to the object serialization.
            ///    @param True on success, false on failure. )
            /// 
            /// </summary>
            public bool SimObject_save(string simobject, string fileName, bool selectedOnly, string preAppendString)
                {
                return m_ts.fn_SimObject_save(simobject, fileName, selectedOnly, preAppendString);
                }

            /// <summary>
            /// Set whether the object will be included in saves.
            ///    @param value If true, the object will be included in saves; if false, it will be excluded. )
            /// 
            /// </summary>
            public void SimObject_setCanSave(string simobject, bool value)
                {
                m_ts.fn_SimObject_setCanSave(simobject, value);
                }

            /// <summary>
            /// Assign a class namespace to this object.
            ///    @param name The name of the 'class' namespace for this object. )
            /// 
            /// </summary>
            public void SimObject_setClassNamespace(string simobject, string name)
                {
                m_ts.fn_SimObject_setClassNamespace(simobject, name);
                }

            /// <summary>
            /// Set the console type code for the given field.
            ///    @param fieldName The name of the dynamic field to change to type for.
            ///    @param type The name of the console type.
            ///    @note This only works for dynamic fields.  Types of static fields cannot be changed. )
            /// 
            /// </summary>
            public void SimObject_setFieldType(string simobject, string fieldName, string type)
                {
                m_ts.fn_SimObject_setFieldType(simobject, fieldName, type);
                }

            /// <summary>
            /// Set the value of the given field on this object.
            ///    @param fieldName The name of the field to assign to.  If it includes an array index, the index will be parsed out.
            ///    @param value The new value to assign to the field.
            ///    @param index Optional argument to specify an index for an array field.
            ///    @return True. )
            /// 
            /// </summary>
            public bool SimObject_setFieldValue(string simobject, string fieldName, string value, int index)
                {
                return m_ts.fn_SimObject_setFieldValue(simobject, fieldName, value, index);
                }

            /// <summary>
            /// Sets the object's file name and path
            ///    @param fileName The name of the file to associate this object with. )
            /// 
            /// </summary>
            public void SimObject_setFilename(string simobject, string fileName)
                {
                m_ts.fn_SimObject_setFilename(simobject, fileName);
                }

            /// <summary>
            /// Set whether the object has been marked as expanded. (in editor)
            ///    @param state True if the object is to be marked expanded; false if not. )
            /// 
            /// </summary>
            public void SimObject_setIsExpanded(string simobject, bool state)
                {
                m_ts.fn_SimObject_setIsExpanded(simobject, state);
                }

            /// <summary>
            /// Assign a superclass namespace to this object.
            ///    @param name The name of the 'superClass' namespace for this object. )
            /// 
            /// </summary>
            public void SimObject_setSuperClassNamespace(string simobject, string name)
                {
                m_ts.fn_SimObject_setSuperClassNamespace(simobject, name);
                }

            /// <summary>
            /// Assign a persistent ID to the object if it does not already have one. )
            /// 
            /// </summary>
            public void assignPersistentId(string simobject)
                {
                m_ts.fnSimObject_assignPersistentId(simobject);
                }

            /// <summary>
            /// ( SimObject, call, const char*, 3, 0, ( string method, string args... ) Dynamically call a method on an object.
            ///    @param method Name of method to call.
            ///    @param args Zero or more arguments for the method.
            ///    @return The result of the method call. )
            /// 
            /// </summary>
            public string call(string simobject, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                return m_ts.fnSimObject_call(simobject, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// Create a copy of this object.
            ///    @return An exact duplicate of this object. )
            /// 
            /// </summary>
            public string clone(string simobject)
                {
                return m_ts.fnSimObject_clone(simobject);
                }

            /// <summary>
            /// Create a copy of this object and all its subobjects.
            ///    @return An exact duplicate of this object and all objects it references. )
            /// 
            /// </summary>
            public string deepClone(string simobject)
                {
                return m_ts.fnSimObject_deepClone(simobject);
                }

            /// <summary>
            /// Dump a description of all fields and methods defined on this object to the console.
            ///    @param detailed Whether to print detailed information about members. )
            /// 
            /// </summary>
            public void dump(string simobject, bool detailed)
                {
                m_ts.fnSimObject_dump(simobject, detailed);
                }

            /// <summary>
            /// Dump the hierarchy of this object up to RootGroup to the console. )
            /// 
            /// </summary>
            public void dumpGroupHierarchy(string simobject)
                {
                m_ts.fnSimObject_dumpGroupHierarchy(simobject);
                }

            /// <summary>
            /// Return some behind-the-scenes information on the object.
            ///    @return An ArrayObject filled with internal information about the object. )
            /// 
            /// </summary>
            public string getDebugInfo(string simobject)
                {
                return m_ts.fnSimObject_getDebugInfo(simobject);
                }

            /// <summary>
            /// Get the group that this object is contained in.
            ///    @note If not assigned to particular SimGroup, an object belongs to RootGroup.
            ///    @return The SimGroup object to which the object belongs. )
            /// 
            /// </summary>
            public string getGroup(string simobject)
                {
                return m_ts.fnSimObject_getGroup(simobject);
                }

            /// <summary>
            /// Get the underlying unique numeric ID of the object.
            ///    @note Object IDs are unique only during single engine runs.
            ///    @return The unique numeric ID of the object. )
            /// 
            /// </summary>
            public int getId(string simobject)
                {
                return m_ts.fnSimObject_getId(simobject);
                }

            /// <summary>
            /// Get the internal name of the object.
            ///    @return The internal name of the object. )
            /// 
            /// </summary>
            public string getInternalName(string simobject)
                {
                return m_ts.fnSimObject_getInternalName(simobject);
                }

            /// <summary>
            /// Get the global name of the object.
            ///    @return The global name assigned to the object. )
            /// 
            /// </summary>
            public string getName(string simobject)
                {
                return m_ts.fnSimObject_getName(simobject);
                }

            /// <summary>
            /// Test whether the object belongs directly or indirectly to the given group.
            ///    @param group The SimGroup object.
            ///    @return True if the object is a child of the given group or a child of a group that the given group is directly or indirectly a child to. )
            /// 
            /// </summary>
            public bool isChildOfGroup(string simobject, string group)
                {
                return m_ts.fnSimObject_isChildOfGroup(simobject, group);
                }

            /// <summary>
            /// Return true if the object is only used by the editor.
            ///    @return True if this object exists only for the sake of editing. )
            /// 
            /// </summary>
            public bool isEditorOnly(string simobject)
                {
                return m_ts.fnSimObject_isEditorOnly(simobject);
                }

            /// <summary>
            /// Get whether this object may be renamed.
            ///    @return True if this object can be renamed; false otherwise. )
            /// 
            /// </summary>
            public bool isNameChangeAllowed(string simobject)
                {
                return m_ts.fnSimObject_isNameChangeAllowed(simobject);
                }

            /// <summary>
            /// Get whether the object has been marked as selected. (in editor)
            ///    @return True if the object is currently selected. )
            /// 
            /// </summary>
            public bool isSelected(string simobject)
                {
                return m_ts.fnSimObject_isSelected(simobject);
                }

            /// <summary>
            /// ( SimObject,schedule, S32, 4, 0, ( float time, string method, string args... ) Delay an invocation of a method.
            ///    @param time The number of milliseconds after which to invoke the method.  This is a soft limit.
            ///    @param method The method to call.
            ///    @param args The arguments with which to call the method.
            ///    @return The numeric ID of the created schedule.  Can be used to cancel the call. )
            /// 
            /// </summary>
            public int schedule(string simobject, string a2, string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                return m_ts.fnSimObject_schedule(simobject, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// Set/clear the editor-only flag on this object.
            ///    @param value If true, the object is marked as existing only for the editor. )
            /// 
            /// </summary>
            public void setEditorOnly(string simobject, bool value)
                {
                m_ts.fnSimObject_setEditorOnly(simobject, value);
                }

            /// <summary>
            /// Hide/unhide the object.
            ///    @param value If true, the object will be hidden; if false, the object will be unhidden. )
            /// 
            /// </summary>
            public void setHidden(string simobject, bool value)
                {
                m_ts.fnSimObject_setHidden(simobject, value);
                }

            /// <summary>
            /// Set the internal name of the object.
            ///    @param newInternalName The new internal name for the object. )
            /// 
            /// </summary>
            public void setInternalName(string simobject, string newInternalName)
                {
                m_ts.fnSimObject_setInternalName(simobject, newInternalName);
                }

            /// <summary>
            /// Set whether the object has been marked as selected. (in editor)
            ///    @param state True if object is to be marked selected; false if not. )
            /// 
            /// </summary>
            public void setIsSelected(string simobject, bool state)
                {
                m_ts.fnSimObject_setIsSelected(simobject, state);
                }

            /// <summary>
            /// Lock/unlock the object in the editor.
            ///    @param value If true, the object will be locked; if false, the object will be unlocked. )
            /// 
            /// </summary>
            public void setLocked(string simobject, bool value)
                {
                m_ts.fnSimObject_setLocked(simobject, value);
                }

            /// <summary>
            /// Set the global name of the object.
            ///    @param newName The new global name to assign to the object.
            ///    @note If name changing is disallowed on the object, the method will fail with a console error. )
            /// 
            /// </summary>
            public void setName(string simobject, string newName)
                {
                m_ts.fnSimObject_setName(simobject, newName);
                }

            /// <summary>
            /// Set whether this object can be renamed from its first name.
            ///    @param value If true, renaming is allowed for this object; if false, trying to change the name of the object will generate a console error. )
            /// 
            /// </summary>
            public void setNameChangeAllowed(string simobject, bool value)
                {
                m_ts.fnSimObject_setNameChangeAllowed(simobject, value);
                }
            }

        #endregion

        #region Nested type: SimPersistSetObject

        /// <summary>
        /// 
        /// </summary>
        public class SimPersistSetObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SimPersistSetObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( SimPersistSet, resolvePersistentIds, void, 2, 2, () - Try to bind unresolved persistent IDs in the set. )
            /// 
            /// </summary>
            public void resolvePersistentIds(string simpersistset = "")
                {
                m_ts.fnSimPersistSet_resolvePersistentIds(simpersistset);
                }
            }

        #endregion

        #region Nested type: SimResponseCurveObject

        /// <summary>
        /// 
        /// </summary>
        public class SimResponseCurveObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SimResponseCurveObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( SimResponseCurve, addPoint, void, 4, 4, addPoint( F32 value, F32 time ) )
            /// 
            /// </summary>
            public void addPoint(string simresponsecurve, string a2, string a3 = "")
                {
                m_ts.fnSimResponseCurve_addPoint(simresponsecurve, a2, a3);
                }

            /// <summary>
            /// ( SimResponseCurve, clear, void, 2, 2, clear() )
            /// 
            /// </summary>
            public void clear(string simresponsecurve = "")
                {
                m_ts.fnSimResponseCurve_clear(simresponsecurve);
                }

            /// <summary>
            /// ( SimResponseCurve, getValue, F32, 3, 3, getValue( F32 time ) )
            /// 
            /// </summary>
            public float getValue(string simresponsecurve, string a2 = "")
                {
                return m_ts.fnSimResponseCurve_getValue(simresponsecurve, a2);
                }
            }

        #endregion

        #region Nested type: SimSetObject

        /// <summary>
        /// 
        /// </summary>
        public class SimSetObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SimSetObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Test whether the given object may be added to the set.
            ///    @param obj The object to test for potential membership.
            ///    @return True if the object may be added to the set, false otherwise. )
            /// 
            /// </summary>
            public bool acceptsAsChild(string simset, string obj)
                {
                return m_ts.fnSimSet_acceptsAsChild(simset, obj);
                }

            /// <summary>
            /// ( SimSet, add, void, 3, 0,
            ///    ( SimObject objects... ) Add the given objects to the set.
            ///    @param objects The objects to add to the set. )
            /// 
            /// </summary>
            public void add(string simset, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fnSimSet_add(simset, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// Make the given object the first object in the set.
            ///    @param obj The object to bring to the frontmost position.  Must be contained in the set. )
            /// 
            /// </summary>
            public void bringToFront(string simset, string obj)
                {
                m_ts.fnSimSet_bringToFront(simset, obj);
                }

            /// <summary>
            /// ( SimSet, callOnChildren, void, 3, 0,
            ///    ( string method, string args... ) Call a method on all objects contained in the set.
            ///    @param method The name of the method to call.
            ///    @param args The arguments to the method.
            ///    @note This method recurses into all SimSets that are children to the set.
            ///    @see callOnChildrenNoRecurse )
            /// 
            /// </summary>
            public void callOnChildren(string simset, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fnSimSet_callOnChildren(simset, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// ( SimSet, callOnChildrenNoRecurse, void, 3, 0,
            ///    ( string method, string args... ) Call a method on all objects contained in the set.
            ///    @param method The name of the method to call.
            ///    @param args The arguments to the method.
            ///    @note This method does not recurse into child SimSets.
            ///    @see callOnChildren )
            /// 
            /// </summary>
            public void callOnChildrenNoRecurse(string simset, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fnSimSet_callOnChildrenNoRecurse(simset, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// Remove all objects from the set. )
            /// 
            /// </summary>
            public void clear(string simset)
                {
                m_ts.fnSimSet_clear(simset);
                }

            /// <summary>
            /// ( SimSet, deleteAllObjects, void, 2, 2, () Delete all objects in the set. )
            /// 
            /// </summary>
            public void deleteAllObjects(string simset = "")
                {
                m_ts.fnSimSet_deleteAllObjects(simset);
                }

            /// <summary>
            /// Find an object in the set by its internal name.
            ///    @param internalName The internal name of the object to look for.
            ///    @param searchChildren If true, SimSets contained in the set will be recursively searched for the object.
            ///    @return The object with the given internal name or 0 if no match was found. )
            /// 
            /// </summary>
            public string findObjectByInternalName(string simset, string internalName, bool searchChildren)
                {
                return m_ts.fnSimSet_findObjectByInternalName(simset, internalName, searchChildren);
                }

            /// <summary>
            /// Get the number of objects contained in the set.
            ///    @return The number of objects contained in the set. )
            /// 
            /// </summary>
            public int getCount(string simset)
                {
                return m_ts.fnSimSet_getCount(simset);
                }

            /// <summary>
            /// ( SimSet, getFullCount, S32, 2, 2, () Get the number of direct and indirect child objects contained in the set.
            ///    @return The number of objects contained in the set as well as in other sets contained directly or indirectly in the set. )
            /// 
            /// </summary>
            public int getFullCount(string simset = "")
                {
                return m_ts.fnSimSet_getFullCount(simset);
                }

            /// <summary>
            /// Get the object at the given index.
            ///    @param index The object index.
            ///    @return The object at the given index or -1 if index is out of range. )
            /// 
            /// </summary>
            public string getObject(string simset, uint index)
                {
                return m_ts.fnSimSet_getObject(simset, index);
                }

            /// <summary>
            /// Return the index of the given object in this set.
            ///    @param obj The object for which to return the index.  Must be contained in the set.
            ///    @return The index of the object or -1 if the object is not contained in the set. )
            /// 
            /// </summary>
            public int getObjectIndex(string simset, string obj)
                {
                return m_ts.fnSimSet_getObjectIndex(simset, obj);
                }

            /// <summary>
            /// Return a random object from the set.
            ///    @return A randomly selected object from the set or -1 if the set is empty. )
            /// 
            /// </summary>
            public string getRandom(string simset)
                {
                return m_ts.fnSimSet_getRandom(simset);
                }

            /// <summary>
            /// Test whether the given object belongs to the set.
            ///    @param obj The object.
            ///    @return True if the object is contained in the set; false otherwise. )
            /// 
            /// </summary>
            public bool isMember(string simset, string obj)
                {
                return m_ts.fnSimSet_isMember(simset, obj);
                }

            /// <summary>
            /// Dump a list of all objects contained in the set to the console. )
            /// 
            /// </summary>
            public void listObjects(string simset)
                {
                m_ts.fnSimSet_listObjects(simset);
                }

            /// <summary>
            /// Make the given object the last object in the set.
            ///    @param obj The object to bring to the last position.  Must be contained in the set. )
            /// 
            /// </summary>
            public void pushToBack(string simset, string obj)
                {
                m_ts.fnSimSet_pushToBack(simset, obj);
                }

            /// <summary>
            /// ( SimSet, remove, void, 3, 0,
            ///    ( SimObject objects... ) Remove the given objects from the set.
            ///    @param objects The objects to remove from the set. )
            /// 
            /// </summary>
            public void remove(string simset, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fnSimSet_remove(simset, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// Make sure child1 is ordered right before child2 in the set.
            ///    @param child1 The first child.  The object must already be contained in the set.
            ///    @param child2 The second child.  The object must already be contained in the set. )
            /// 
            /// </summary>
            public void reorderChild(string simset, string child1, string child2)
                {
                m_ts.fnSimSet_reorderChild(simset, child1, child2);
                }

            /// <summary>
            /// ( SimSet, sort, void, 3, 3, ( string callbackFunction ) Sort the objects in the set using the given comparison function.
            ///    @param callbackFunction Name of a function that takes two object arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal. )
            /// 
            /// </summary>
            public void sort(string simset, string a2 = "")
                {
                m_ts.fnSimSet_sort(simset, a2);
                }
            }

        #endregion

        #region Nested type: SimXMLDocumentObject

        /// <summary>
        /// 
        /// </summary>
        public class SimXMLDocumentObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SimXMLDocumentObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Add the given comment as a child of the document.
            ///   @param comment String containing the comment.
            /// 
            ///    @tsexample
            ///    // Create a new XML document with a header, a comment and single element.
            ///    %x = new SimXMLDocument();
            ///    %x.addHeader();
            ///    %x.addComment(\"This is a test comment\");
            ///    %x.addNewElement(\"NewElement\");
            ///    %x.saveFile(\"test.xml\");
            ///    // Produces the following file:
            ///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
            ///    // !--This is a test comment-->
            ///    // NewElement />
            ///    @endtsexample
            ///    
            ///    @see readComment())
            /// 
            /// </summary>
            public void addComment(string simxmldocument, string comment)
                {
                m_ts.fnSimXMLDocument_addComment(simxmldocument, comment);
                }

            /// <summary>
            /// @brief Add the given text as a child of current Element.
            /// 
            ///    Use getData() to retrieve any text from the current Element.
            /// 
            ///    addData() and addText() may be used interchangeably.  As there is no 
            ///    difference between data and text, you may also use removeText() to clear 
            ///    any data from the current Element.
            /// 
            ///    @param text String containing the text.
            /// 
            ///    @tsexample
            ///    // Create a new XML document with a header and single element
            ///    // with some added data.
            ///    %x = new SimXMLDocument();
            ///    %x.addHeader();
            ///    %x.addNewElement(\"NewElement\");
            ///    %x.addData(\"Some text\");
            ///    %x.saveFile(\"test.xml\");
            ///    // Produces the following file:
            ///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
            ///    // NewElement>Some text/NewElement>
            ///    @endtsexample
            /// 
            ///    @see getData()
            ///    @see addText()
            ///    @see getText()
            ///    @see removeText())
            /// 
            /// </summary>
            public void addData(string simxmldocument, string text)
                {
                m_ts.fnSimXMLDocument_addData(simxmldocument, text);
                }

            /// <summary>
            /// @brief Add a XML header to a document.
            /// 
            ///    Sometimes called a declaration, you typically add a standard header to 
            ///    the document before adding any elements.  SimXMLDocument always produces 
            ///    the following header:
            ///    ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
            ///   
            ///    @tsexample
            ///    // Create a new XML document with just a header and single element.
            ///    %x = new SimXMLDocument();
            ///    %x.addHeader();
            ///    %x.addNewElement(\"NewElement\");
            ///    %x.saveFile(\"test.xml\");
            ///    // Produces the following file:
            ///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
            ///    // NewElement />
            ///    @endtsexample)
            /// 
            /// </summary>
            public void addHeader(string simxmldocument)
                {
                m_ts.fnSimXMLDocument_addHeader(simxmldocument);
                }

            /// <summary>
            /// @brief Create a new element with the given name as child of current Element's 
            ///    parent and push it onto the Element stack making it the current one.
            /// 
            ///    @note This differs from pushNewElement() in that it adds the new Element to the 
            ///    current Element's parent (or document if there is no parent Element).  This makes 
            ///    the new Element a sibling of the current one.
            /// 
            ///    @param name XML tag for the new Element.
            ///    
            ///    @see pushNewElement())
            /// 
            /// </summary>
            public void addNewElement(string simxmldocument, string name)
                {
                m_ts.fnSimXMLDocument_addNewElement(simxmldocument, name);
                }

            /// <summary>
            /// @brief Add the given text as a child of current Element.
            /// 
            ///    Use getText() to retrieve any text from the current Element and removeText() 
            ///    to clear any text.
            /// 
            ///    addText() and addData() may be used interchangeably.
            /// 
            ///    @param text String containing the text.
            /// 
            ///    @tsexample
            ///    // Create a new XML document with a header and single element
            ///    // with some added text.
            ///    %x = new SimXMLDocument();
            ///    %x.addHeader();
            ///    %x.addNewElement(\"NewElement\");
            ///    %x.addText(\"Some text\");
            ///    %x.saveFile(\"test.xml\");
            ///    // Produces the following file:
            ///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
            ///    // NewElement>Some text/NewElement>
            ///    @endtsexample
            /// 
            ///    @see getText()
            ///    @see removeText()
            ///    @see addData()
            ///    @see getData())
            /// 
            /// </summary>
            public void addText(string simxmldocument, string text)
                {
                m_ts.fnSimXMLDocument_addText(simxmldocument, text);
                }

            /// <summary>
            /// @brief Get a string attribute from the current Element on the stack.
            ///    @param attributeName Name of attribute to retrieve.
            ///    @return The attribute string if found.  Otherwise returns an empty string.)
            /// 
            /// </summary>
            public string attribute(string simxmldocument, string attributeName)
                {
                return m_ts.fnSimXMLDocument_attribute(simxmldocument, attributeName);
                }

            /// <summary>
            /// @brief Tests if the requested attribute exists.
            ///    @param attributeName Name of attribute being queried for.
            ///    @return True if the attribute exists.)
            /// 
            /// </summary>
            public bool attributeExists(string simxmldocument, string attributeName)
                {
                return m_ts.fnSimXMLDocument_attributeExists(simxmldocument, attributeName);
                }

            /// <summary>
            /// ( SimXMLDocument, attributeF32, F32, 3, 3, (string attributeName)
            ///    @brief Get float attribute from the current Element on the stack.
            ///    @param attributeName Name of attribute to retrieve.
            ///    @return The value of the given attribute in the form of a float.
            ///    @deprecated Use attribute().)
            /// 
            /// </summary>
            public float attributeF32(string simxmldocument, string a2 = "")
                {
                return m_ts.fnSimXMLDocument_attributeF32(simxmldocument, a2);
                }

            /// <summary>
            /// (SimXMLDocument, attributeS32, S32, 3, 3, (string attributeName)
            ///    @brief Get int attribute from the current Element on the stack.
            ///    @param attributeName Name of attribute to retrieve.
            ///    @return The value of the given attribute in the form of an integer.
            ///    @deprecated Use attribute().)
            /// 
            /// </summary>
            public int attributeS32(string simxmldocument, string a2 = "")
                {
                return m_ts.fnSimXMLDocument_attributeS32(simxmldocument, a2);
                }

            /// <summary>
            /// @brief Set this document to its default state.
            ///    
            ///    Clears all Elements from the documents.  Equivalent to using reset()
            ///    
            ///    @see reset())
            /// 
            /// </summary>
            public void clear(string simxmldocument)
                {
                m_ts.fnSimXMLDocument_clear(simxmldocument);
                }

            /// <summary>
            /// @brief Clear the last error description.)
            /// 
            /// </summary>
            public void clearError(string simxmldocument)
                {
                m_ts.fnSimXMLDocument_clearError(simxmldocument);
                }

            /// <summary>
            /// @brief Get the Element's value if it exists.
            ///    Usually returns the text from the Element.
            ///    @return The value from the Element, or an empty string if none is found.)
            /// 
            /// </summary>
            public string elementValue(string simxmldocument)
                {
                return m_ts.fnSimXMLDocument_elementValue(simxmldocument);
                }

            /// <summary>
            /// @brief Obtain the name of the current Element's first attribute.
            ///    @return String containing the first attribute's name, or an empty string if none is found.
            ///    @see nextAttribute()
            ///    @see lastAttribute()
            ///    @see prevAttribute())
            /// 
            /// </summary>
            public string firstAttribute(string simxmldocument)
                {
                return m_ts.fnSimXMLDocument_firstAttribute(simxmldocument);
                }

            /// <summary>
            /// @brief Gets the text from the current Element.
            /// 
            ///    Use addData() to add text to the current Element.
            /// 
            ///    getData() and getText() may be used interchangeably.  As there is no 
            ///    difference between data and text, you may also use removeText() to clear 
            ///    any data from the current Element.
            /// 
            ///    @return String containing the text in the current Element.
            /// 
            ///    @tsexample
            ///    // Using the following test.xml file as an example:
            ///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
            ///    // NewElement>Some data/NewElement>
            /// 
            ///    // Load in the file
            ///    %x = new SimXMLDocument();
            ///    %x.loadFile(\"test.xml\");
            /// 
            ///    // Make the first Element the current one
            ///    %x.pushFirstChildElement(\"NewElement\");
            /// 
            ///    // Store the current Element's data ('Some data' in this example)
            ///    // into 'result'
            ///    %result = %x.getData();
            ///    echo( %result );
            ///    @endtsexample
            ///    
            ///    @see addData()
            ///    @see addText()
            ///    @see getText()
            ///    @see removeText())
            /// 
            /// </summary>
            public string getData(string simxmldocument)
                {
                return m_ts.fnSimXMLDocument_getData(simxmldocument);
                }

            /// <summary>
            /// @brief Get last error description.
            ///    @return A string of the last error message.)
            /// 
            /// </summary>
            public string getErrorDesc(string simxmldocument)
                {
                return m_ts.fnSimXMLDocument_getErrorDesc(simxmldocument);
                }

            /// <summary>
            /// @brief Gets the text from the current Element.
            /// 
            ///    Use addText() to add text to the current Element and removeText() 
            ///    to clear any text.
            /// 
            ///    getText() and getData() may be used interchangeably.
            /// 
            ///    @return String containing the text in the current Element.
            /// 
            ///    @tsexample
            ///    // Using the following test.xml file as an example:
            ///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
            ///    // NewElement>Some text/NewElement>
            /// 
            ///    // Load in the file
            ///    %x = new SimXMLDocument();
            ///    %x.loadFile(\"test.xml\");
            /// 
            ///    // Make the first Element the current one
            ///    %x.pushFirstChildElement(\"NewElement\");
            /// 
            ///    // Store the current Element's text ('Some text' in this example)
            ///    // into 'result'
            ///    %result = %x.getText();
            ///    echo( %result );
            ///    @endtsexample
            ///    
            ///    @see addText()
            ///    @see removeText()
            ///    @see addData()
            ///    @see getData())
            /// 
            /// </summary>
            public string getText(string simxmldocument)
                {
                return m_ts.fnSimXMLDocument_getText(simxmldocument);
                }

            /// <summary>
            /// @brief Obtain the name of the current Element's last attribute.
            ///    @return String containing the last attribute's name, or an empty string if none is found.
            ///    @see prevAttribute()
            ///    @see firstAttribute()
            ///    @see lastAttribute())
            /// 
            /// </summary>
            public string lastAttribute(string simxmldocument)
                {
                return m_ts.fnSimXMLDocument_lastAttribute(simxmldocument);
                }

            /// <summary>
            /// @brief Load in given filename and prepare it for use.
            ///    @note Clears the current document's contents.
            ///    @param fileName Name and path of XML document
            ///    @return True if the file was loaded successfully.)
            /// 
            /// </summary>
            public bool loadFile(string simxmldocument, string fileName)
                {
                return m_ts.fnSimXMLDocument_loadFile(simxmldocument, fileName);
                }

            /// <summary>
            /// @brief Get the name of the next attribute for the current Element after a call to firstAttribute().
            ///    @return String containing the next attribute's name, or an empty string if none is found.
            ///    @see firstAttribute()
            ///    @see lastAttribute()
            ///    @see prevAttribute())
            /// 
            /// </summary>
            public string nextAttribute(string simxmldocument)
                {
                return m_ts.fnSimXMLDocument_nextAttribute(simxmldocument);
                }

            /// <summary>
            /// @brief Put the next sibling Element with the given name on the stack, making it the current one.
            ///    @param name String containing name of the next sibling.
            ///    @return True if the Element was found and made the current one.)
            /// 
            /// </summary>
            public bool nextSiblingElement(string simxmldocument, string name)
                {
                return m_ts.fnSimXMLDocument_nextSiblingElement(simxmldocument, name);
                }

            /// <summary>
            /// @brief Create a document from a XML string.
            ///    @note Clears the current document's contents.
            ///    @param xmlString Valid XML to parse and store as a document.)
            /// 
            /// </summary>
            public void parse(string simxmldocument, string xmlString)
                {
                m_ts.fnSimXMLDocument_parse(simxmldocument, xmlString);
                }

            /// <summary>
            /// @brief Pop the last Element off the stack.)
            /// 
            /// </summary>
            public void popElement(string simxmldocument)
                {
                m_ts.fnSimXMLDocument_popElement(simxmldocument);
                }

            /// <summary>
            /// @brief Get the name of the previous attribute for the current Element after a call to lastAttribute().
            ///    @return String containing the previous attribute's name, or an empty string if none is found.
            ///    @see lastAttribute()
            ///    @see firstAttribute()
            ///    @see nextAttribute())
            /// 
            /// </summary>
            public string prevAttribute(string simxmldocument)
                {
                return m_ts.fnSimXMLDocument_prevAttribute(simxmldocument);
                }

            /// <summary>
            /// @brief Push the child Element at the given index onto the stack, making it the current one.
            ///    @param index Numerical index of Element being pushed.
            ///    @return True if the Element was found and made the current one.)
            /// 
            /// </summary>
            public bool pushChildElement(string simxmldocument, int index)
                {
                return m_ts.fnSimXMLDocument_pushChildElement(simxmldocument, index);
                }

            /// <summary>
            /// @brief Push the first child Element with the given name onto the stack, making it the current Element.
            /// 
            ///    @param name String containing name of the child Element.
            ///    @return True if the Element was found and made the current one.
            /// 
            ///    @tsexample
            ///    // Using the following test.xml file as an example:
            ///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
            ///    // NewElement>Some text/NewElement>
            /// 
            ///    // Load in the file
            ///    %x = new SimXMLDocument();
            ///    %x.loadFile(\"test.xml\");
            /// 
            ///    // Make the first Element the current one
            ///    %x.pushFirstChildElement(\"NewElement\");
            /// 
            ///    // Store the current Element's text ('Some text' in this example)
            ///    // into 'result'
            ///    %result = %x.getText();
            ///    echo( %result );
            ///    @endtsexample)
            /// 
            /// </summary>
            public bool pushFirstChildElement(string simxmldocument, string name)
                {
                return m_ts.fnSimXMLDocument_pushFirstChildElement(simxmldocument, name);
                }

            /// <summary>
            /// @brief Create a new element with the given name as child of current Element 
            ///    and push it onto the Element stack making it the current one.
            /// 
            ///    @note This differs from addNewElement() in that it adds the new Element as a 
            ///    child of the current Element (or a child of the document if no Element exists).
            /// 
            ///    @param name XML tag for the new Element.
            /// 
            ///    @see addNewElement())
            /// 
            /// </summary>
            public void pushNewElement(string simxmldocument, string name)
                {
                m_ts.fnSimXMLDocument_pushNewElement(simxmldocument, name);
                }

            /// <summary>
            /// Gives the comment at the specified index, if any.
            /// 
            ///    Unlike addComment() that only works at the document level, readComment() may read 
            ///    comments from the document or any child Element.  The current Element (or document 
            ///    if no Elements have been pushed to the stack) is the parent for any comments, and the 
            ///    provided index is the number of comments in to read back.
            /// 
            ///    @param index Comment index number to query from the current Element stack
            ///    @return String containing the comment, or an empty string if no comment is found.
            /// 
            ///    @see addComment())
            /// 
            /// </summary>
            public string readComment(string simxmldocument, int index)
                {
                return m_ts.fnSimXMLDocument_readComment(simxmldocument, index);
                }

            /// <summary>
            /// @brief Remove any text on the current Element.
            /// 
            ///    Use getText() to retrieve any text from the current Element and addText() 
            ///    to add text to the current Element.  As getData() and addData() are equivalent 
            ///    to getText() and addText(), removeText() will also remove any data from the 
            ///    current Element.
            ///    
            ///    @see addText()
            ///    @see getText()
            ///    @see addData()
            ///    @see getData())
            /// 
            /// </summary>
            public void removeText(string simxmldocument)
                {
                m_ts.fnSimXMLDocument_removeText(simxmldocument);
                }

            /// <summary>
            /// @brief Set this document to its default state.
            ///    
            ///    Clears all Elements from the documents.  Equivalent to using clear()
            ///    
            ///    @see clear())
            /// 
            /// </summary>
            public void reset(string simxmldocument)
                {
                m_ts.fnSimXMLDocument_reset(simxmldocument);
                }

            /// <summary>
            /// @brief Save document to the given file name.
            ///    @param fileName Path and name of XML file to save to.
            ///    @return True if the file was successfully saved.)
            /// 
            /// </summary>
            public bool saveFile(string simxmldocument, string fileName)
                {
                return m_ts.fnSimXMLDocument_saveFile(simxmldocument, fileName);
                }

            /// <summary>
            /// @brief Set the attribute of the current Element on the stack to the given value.
            ///    @param attributeName Name of attribute being changed
            ///    @param value New value to assign to the attribute)
            /// 
            /// </summary>
            public void setAttribute(string simxmldocument, string attributeName, string value)
                {
                m_ts.fnSimXMLDocument_setAttribute(simxmldocument, attributeName, value);
                }

            /// <summary>
            /// @brief Add the given SimObject's fields as attributes of the current Element on the stack.
            ///    @param objectID ID of SimObject being copied.)
            /// 
            /// </summary>
            public void setObjectAttributes(string simxmldocument, string objectID)
                {
                m_ts.fnSimXMLDocument_setObjectAttributes(simxmldocument, objectID);
                }
            }

        #endregion

        #region Nested type: SkyBoxObject

        /// <summary>
        /// 
        /// </summary>
        public class SkyBoxObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SkyBoxObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( SkyBox, postApply, void, 2, 2, )
            /// 
            /// </summary>
            public void postApply(string skybox = "")
                {
                m_ts.fnSkyBox_postApply(skybox);
                }
            }

        #endregion

        #region Nested type: SpawnSphereObject

        /// <summary>
        /// 
        /// </summary>
        public class SpawnSphereObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SpawnSphereObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (SpawnSphere, spawnObject, S32, 2, 3,
            ///    ([string additionalProps]) Spawns the object based on the SpawnSphere's 
            ///    class, datablock, properties, and script settings. Allows you to pass in 
            ///    extra properties.
            ///    @hide )
            /// 
            /// </summary>
            public int spawnObject(string spawnsphere = "", string a2 = "")
                {
                return m_ts.fnSpawnSphere_spawnObject(spawnsphere, a2);
                }
            }

        #endregion

        #region Nested type: StaticShapeObject

        /// <summary>
        /// 
        /// </summary>
        public class StaticShapeObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public StaticShapeObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( StaticShape, getPoweredState, bool, 2, 2, @internal)
            /// 
            /// </summary>
            public bool getPoweredState(string staticshape = "")
                {
                return m_ts.fnStaticShape_getPoweredState(staticshape);
                }

            /// <summary>
            /// ( StaticShape, setPoweredState, void, 3, 3, (bool isPowered)
            /// 			  @internal)
            /// 
            /// </summary>
            public void setPoweredState(string staticshape, string a2 = "")
                {
                m_ts.fnStaticShape_setPoweredState(staticshape, a2);
                }
            }

        #endregion

        #region Nested type: StreamObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class StreamObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public StreamObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Copy from another StreamObject into this StreamObject
            ///    @param other The StreamObject to copy from.
            ///    @return True if the copy was successful.)
            /// 
            /// </summary>
            public bool copyFrom(string streamobject, string other)
                {
                return m_ts.fnStreamObject_copyFrom(streamobject, other);
                }

            /// <summary>
            /// @brief Gets the position in the stream
            ///    
            ///    The easiest way to visualize this is to think of a cursor in a text file. If you have moved the cursor by 
            ///    five characters, the current position is 5. If you move ahead 10 more characters, the position is now 15. 
            ///    For StreamObject, when you read in the line the position is increased by the number of characters parsed, 
            ///    the null terminator, and a newline.
            ///    
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    %fsObject = new FileStreamObject();
            ///    // Open a file for reading
            ///    // This file contains two lines of text repeated:
            ///    // Hello World
            ///    // Hello World
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Read in the first line
            ///    %line = %fsObject.readLine();
            ///    // Get the position of the stream
            ///    %position = %fsObject.getPosition();
            ///    // Print the current position
            ///    // Should be 13, 10 for the words, 1 for the space, 1 for the null terminator, and 1 for the newline
            ///    echo(%position);
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            /// 
            ///    @return Number of bytes which stream has parsed so far, null terminators and newlines are included
            ///    
            ///    @see setPosition())
            /// 
            /// </summary>
            public int getPosition(string streamobject)
                {
                return m_ts.fnStreamObject_getPosition(streamobject);
                }

            /// <summary>
            /// @brief Gets a printable string form of the stream's status
            ///    
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    %fsObject = new FileStreamObject();
            ///    // Open a file for reading
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Get the status and print it
            ///    %status = %fsObject.getStatus();
            ///    echo(%status);
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            /// 
            ///    @return String containing status constant, one of the following:
            /// 
            ///    	OK - Stream is active and no file errors
            /// 
            ///    	IOError - Something went wrong during read or writing the stream
            /// 
            ///    	EOS - End of Stream reached (mostly for reads)
            /// 
            ///    	IllegalCall - An unsupported operation used.  Always w/ accompanied by AssertWarn
            /// 
            ///      Closed - Tried to operate on a closed stream (or detached filter)
            /// 
            ///    	UnknownError - Catch all for an error of some kind
            /// 
            ///    	Invalid - Entire stream is invalid)
            /// 
            /// </summary>
            public string getStatus(string streamobject)
                {
                return m_ts.fnStreamObject_getStatus(streamobject);
                }

            /// <summary>
            /// @brief Gets the size of the stream
            ///    
            ///    The size is dependent on the type of stream being used. If it is a file stream, returned value will 
            ///    be the size of the file. If it is a memory stream, it will be the size of the allocated buffer.
            ///       
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    %fsObject = new FileStreamObject();
            ///    // Open a file for reading
            ///    // This file contains the following two lines:
            ///    // HelloWorld
            ///    // HelloWorld
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Found out how large the file stream is
            ///    // Then print it to the console
            ///    // Should be 22
            ///    %streamSize = %fsObject.getStreamSize();
            ///    echo(%streamSize);
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            /// 
            ///    @return Size of stream, in bytes)
            /// 
            /// </summary>
            public int getStreamSize(string streamobject)
                {
                return m_ts.fnStreamObject_getStreamSize(streamobject);
                }

            /// <summary>
            /// @brief Tests if the stream has reached the end of the file
            ///    
            ///    This is an alternative name for isEOS. Both functions are interchangeable. This simply exists 
            ///    for those familiar with some C++ file I/O standards.
            ///    
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    %fsObject = new FileStreamObject();
            ///    // Open a file for reading
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Keep reading until we reach the end of the file
            ///    while( !%fsObject.isEOF() )
            ///    {
            ///       %line = %fsObject.readLine();
            ///       echo(%line);
            ///    }
            ///    // Made it to the end
            ///    echo(\"Finished reading file\");
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            /// 
            ///    @return True if the parser has reached the end of the file, false otherwise
            ///    
            ///    @see isEOS())
            /// 
            /// </summary>
            public bool isEOF(string streamobject)
                {
                return m_ts.fnStreamObject_isEOF(streamobject);
                }

            /// <summary>
            /// @brief Tests if the stream has reached the end of the file
            ///    
            ///    This is an alternative name for isEOF. Both functions are interchangeable. This simply exists 
            ///    for those familiar with some C++ file I/O standards.
            /// 
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    %fsObject = new FileStreamObject();
            ///    // Open a file for reading
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Keep reading until we reach the end of the file
            ///    while( !%fsObject.isEOS() )
            ///    {
            ///       %line = %fsObject.readLine();
            ///       echo(%line);
            ///    }
            ///    // Made it to the end
            ///    echo(\"Finished reading file\");
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            /// 
            ///    @return True if the parser has reached the end of the file, false otherwise
            /// 
            ///    @see isEOF())
            /// 
            /// </summary>
            public bool isEOS(string streamobject)
                {
                return m_ts.fnStreamObject_isEOS(streamobject);
                }

            /// <summary>
            /// @brief Read a line from the stream.
            ///    
            ///    Emphasis on *line*, as in you cannot parse individual characters or chunks of data. 
            ///    There is no limitation as to what kind of data you can read.
            ///    
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    // This file contains the following two lines:
            ///    // HelloWorld
            ///    // HelloWorld
            ///    %fsObject = new FileStreamObject();
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Read in the first line
            ///    %line = %fsObject.readLine();
            ///    // Print the line we just read
            ///    echo(%line);
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            /// 
            ///    @return String containing the line of data that was just read
            ///    
            ///    @see writeLine())
            /// 
            /// </summary>
            public string readLine(string streamobject)
                {
                return m_ts.fnStreamObject_readLine(streamobject);
                }

            /// <summary>
            /// @brief Read in a string up to the given maximum number of characters.
            ///    @param maxLength The maximum number of characters to read in.
            ///    @return The string that was read from the stream.
            ///    @see writeLongString()
            ///    
            ///    @note When working with these particular string reading and writing methods, the stream 
            ///    begins with the length of the string followed by the string itself, and does not include 
            ///    a NULL terminator.)
            /// 
            /// </summary>
            public string readLongString(string streamobject, int maxLength)
                {
                return m_ts.fnStreamObject_readLongString(streamobject, maxLength);
                }

            /// <summary>
            /// @brief Read a string up to a maximum of 256 characters
            ///    @return The string that was read from the stream.
            ///    @see writeString()
            ///    
            ///    @note When working with these particular string reading and writing methods, the stream 
            ///    begins with the length of the string followed by the string itself, and does not include 
            ///    a NULL terminator.)
            /// 
            /// </summary>
            public string readString(string streamobject)
                {
                return m_ts.fnStreamObject_readString(streamobject);
                }

            /// <summary>
            /// @brief Read in a string and place it on the string table.
            ///    @param caseSensitive If false then case will not be taken into account when attempting 
            ///    to match the read in string with what is already in the string table.
            ///    @return The string that was read from the stream.
            ///    @see writeString()
            ///    
            ///    @note When working with these particular string reading and writing methods, the stream 
            ///    begins with the length of the string followed by the string itself, and does not include 
            ///    a NULL terminator.)
            /// 
            /// </summary>
            public string readSTString(string streamobject, bool caseSensitive)
                {
                return m_ts.fnStreamObject_readSTString(streamobject, caseSensitive);
                }

            /// <summary>
            /// @brief Gets the position in the stream
            ///    
            ///    The easiest way to visualize this is to think of a cursor in a text file. If you have moved the cursor by 
            ///    five characters, the current position is 5. If you move ahead 10 more characters, the position is now 15. 
            ///    For StreamObject, when you read in the line the position is increased by the number of characters parsed, 
            ///    the null terminator, and a newline. Using setPosition allows you to skip to specific points of the file.
            ///    
            ///    @tsexample
            ///    // Create a file stream object for reading
            ///    %fsObject = new FileStreamObject();
            ///    // Open a file for reading
            ///    // This file contains the following two lines:
            ///    // 11111111111
            ///    // Hello World
            ///    %fsObject.open(\"./test.txt\", \"read\");
            ///    // Skip ahead by 12, which will bypass the first line entirely
            ///    %fsObject.setPosition(12);
            ///    // Read in the next line
            ///    %line = %fsObject.readLine();
            ///    // Print the line just read in, should be \"Hello World\"
            ///    echo(%line);
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            /// 
            ///    @return Number of bytes which stream has parsed so far, null terminators and newlines are included
            ///    
            ///    @see getPosition())
            /// 
            /// </summary>
            public bool setPosition(string streamobject, int newPosition)
                {
                return m_ts.fnStreamObject_setPosition(streamobject, newPosition);
                }

            /// <summary>
            /// @brief Write a line to the stream, if it was opened for writing.
            ///    
            ///    There is no limit as to what kind of data you can write. Any format and data is allowable, not just text. 
            ///    Be careful of what you write, as whitespace, current values, and literals will be preserved.
            /// 
            ///    @param line The data we are writing out to file.
            ///    
            ///    @tsexample
            ///    // Create a file stream
            ///    %fsObject = new FileStreamObject();
            ///    // Open the file for writing
            ///    // If it does not exist, it is created. If it does exist, the file is cleared
            ///    %fsObject.open(\"./test.txt\", \"write\");
            ///    // Write a line to the file
            ///    %fsObject.writeLine(\"Hello World\");
            ///    // Write another line to the file
            ///    %fsObject.writeLine(\"Documentation Rocks!\");
            ///    // Always remember to close a file stream when finished
            ///    %fsObject.close();
            ///    @endtsexample
            ///    
            ///    @see readLine())
            /// 
            /// </summary>
            public void writeLine(string streamobject, string line)
                {
                m_ts.fnStreamObject_writeLine(streamobject, line);
                }

            /// <summary>
            /// @brief Write out a string up to the maximum number of characters.
            ///    @param maxLength The maximum number of characters that will be written.
            ///    @param string The string to write out to the stream.
            ///    @see readLongString()
            ///    
            ///    @note When working with these particular string reading and writing methods, the stream 
            ///    begins with the length of the string followed by the string itself, and does not include 
            ///    a NULL terminator.)
            /// 
            /// </summary>
            public void writeLongString(string streamobject, int maxLength, string xstring)
                {
                m_ts.fnStreamObject_writeLongString(streamobject, maxLength, xstring);
                }

            /// <summary>
            /// @brief Write out a string with a default maximum length of 256 characters.
            ///    @param string The string to write out to the stream
            ///    @param maxLength The maximum string length to write out with a default of 256 characters.  This 
            ///    value should not be larger than 256 as it is written to the stream as a single byte.
            ///    @see readString()
            ///    
            ///    @note When working with these particular string reading and writing methods, the stream 
            ///    begins with the length of the string followed by the string itself, and does not include 
            ///    a NULL terminator.)
            /// 
            /// </summary>
            public void writeString(string streamobject, string xstring, int maxLength)
                {
                m_ts.fnStreamObject_writeString(streamobject, xstring, maxLength);
                }
            }

        #endregion

        #region Nested type: SunObject

        /// <summary>
        /// 
        /// </summary>
        public class SunObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public SunObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (Sun, animate, void, 7, 7, animate( F32 duration, F32 startAzimuth, F32 endAzimuth, F32 startElevation, F32 endElevation ))
            /// 
            /// </summary>
            public void animate(string sun, string a2, string a3, string a4, string a5, string a6 = "")
                {
                m_ts.fnSun_animate(sun, a2, a3, a4, a5, a6);
                }

            /// <summary>
            /// (Sun, apply, void, 2, 2, )
            /// 
            /// </summary>
            public void apply(string sun = "")
                {
                m_ts.fnSun_apply(sun);
                }
            }

        #endregion

        #region Nested type: TCPObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class TCPObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public TCPObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Connect to the given address.
            /// 
            ///    @param address Server address (including port) to connect to.
            /// 
            ///    @tsexample
            ///       // Set the address.
            ///       %address = \"www.garagegames.com:80\";
            /// 
            ///       // Inform this TCPObject to connect to the specified address.
            ///       %thisTCPObj.connect(%address);
            ///    @endtsexample)
            /// 
            /// </summary>
            public void connect(string tcpobject, string address)
                {
                m_ts.fnTCPObject_connect(tcpobject, address);
                }

            /// <summary>
            /// @brief Disconnect from whatever this TCPObject is currently connected to, if anything.
            /// 
            ///    @tsexample
            ///       // Inform this TCPObject to disconnect from anything it is currently connected to.
            ///       %thisTCPObj.disconnect();
            ///    @endtsexample)
            /// 
            /// </summary>
            public void disconnect(string tcpobject)
                {
                m_ts.fnTCPObject_disconnect(tcpobject);
                }

            /// <summary>
            /// @brief Start listening on the specified port for connections.
            /// 
            ///    This method starts a listener which looks for incoming TCP connections to a port.  
            ///    You must overload the onConnectionRequest callback to create a new TCPObject to 
            ///    read, write, or reject the new connection.
            /// 
            ///    @param port Port for this TCPObject to start listening for connections on.
            /// 
            ///    @tsexample
            /// 
            ///     // Create a listener on port 8080.
            ///     new TCPObject( TCPListener );
            ///     TCPListener.listen( 8080 );
            /// 
            ///     function TCPListener::onConnectionRequest( %this, %address, %id )
            ///     {
            ///        // Create a new object to manage the connection.
            ///        new TCPObject( TCPClient, %id );
            ///     }
            /// 
            ///     function TCPClient::onLine( %this, %line )
            ///     {
            ///        // Print the line of text from client.
            ///        echo( %line );
            ///     }
            /// 
            ///    @endtsexample)
            /// 
            /// </summary>
            public void listen(string tcpobject, int port)
                {
                m_ts.fnTCPObject_listen(tcpobject, port);
                }

            /// <summary>
            /// @brief Transmits the data string to the connected computer.
            /// 
            ///    This method is used to send text data to the connected computer regardless if we initiated the 
            ///    connection using connect(), or listening to a port using listen().
            /// 
            ///    @param data The data string to send.
            /// 
            ///    @tsexample
            ///       // Set the command data
            ///       %data = \"GET \" @ $RSSFeed::serverURL @ \" HTTP/1.0\\r\\";
            ///       %data = %data @ \"Host: \" @ $RSSFeed::serverName @ \"\\r\\";
            ///       %data = %data @ \"User-Agent: \" @ $RSSFeed::userAgent @ \"\\r\\\r\\"
            /// 
            ///       // Send the command to the connected server.
            ///       %thisTCPObj.send(%data);
            ///    @endtsexample)
            /// 
            /// </summary>
            public void send(string tcpobject, string data)
                {
                m_ts.fnTCPObject_send(tcpobject, data);
                }
            }

        #endregion

        #region Nested type: TSStaticObject

        /// <summary>
        /// 
        /// </summary>
        public class TSStaticObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public TSStaticObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ,NULL,NULL),
            ///    @brief Change one of the materials on the shape.
            /// 
            ///    This method changes materials per mapTo with others. The material that 
            ///    is being replaced is mapped to unmapped_mat as a part of this transition.
            /// 
            ///    @note Warning, right now this only sort of works. It doesn't do a live 
            ///    update like it should.
            /// 
            ///    @param mapTo the name of the material target to remap (from getTargetName)
            ///    @param oldMat the old Material that was mapped 
            ///    @param newMat the new Material to map
            /// 
            ///    @tsexample
            ///       // remap the first material in the shape
            ///       %mapTo = %obj.getTargetName( 0 );
            ///       %obj.changeMaterial( %mapTo, 0, MyMaterial );
            ///    @endtsexample )
            /// 
            /// </summary>
            public void changeMaterial(string tsstatic, string mapTo, string oldMat, string newMat)
                {
                m_ts.fnTSStatic_changeMaterial(tsstatic, mapTo, oldMat, newMat);
                }

            /// <summary>
            /// @brief Get the model filename used by this shape.
            /// 
            ///    @return the shape filename
            ///    @tsexample
            /// 		// Acquire the model filename used on this shape.
            /// 		%modelFilename = %obj.getModelFile();
            ///    @endtsexample
            ///    )
            /// 
            /// </summary>
            public string getModelFile(string tsstatic)
                {
                return m_ts.fnTSStatic_getModelFile(tsstatic);
                }

            /// <summary>
            /// Get the number of materials in the shape.
            ///    @return the number of materials in the shape.
            ///    @see getTargetName())
            /// 
            /// </summary>
            public int getTargetCount(string tsstatic)
                {
                return m_ts.fnTSStatic_getTargetCount(tsstatic);
                }

            /// <summary>
            /// Get the name of the indexed shape material.
            ///    @param index index of the material to get (valid range is 0 - getTargetCount()-1).
            ///    @return the name of the indexed material.
            ///    @see getTargetCount())
            /// 
            /// </summary>
            public string getTargetName(string tsstatic, int index)
                {
                return m_ts.fnTSStatic_getTargetName(tsstatic, index);
                }
            }

        #endregion

        #region Nested type: TerrainBlockObject

        /// <summary>
        /// 
        /// </summary>
        public class TerrainBlockObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public TerrainBlockObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Saves the terrain block's terrain file to the specified file name.
            /// 
            /// 				   @param fileName Name and path of file to save terrain data to.
            /// 
            /// 				   @return True if file save was successful, false otherwise)
            /// 
            /// </summary>
            public bool save(string terrainblock, string fileName)
                {
                return m_ts.fnTerrainBlock_save(terrainblock, fileName);
                }
            }

        #endregion

        #region Nested type: TimeOfDayObject

        /// <summary>
        /// 
        /// </summary>
        public class TimeOfDayObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public TimeOfDayObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void addTimeOfDayEvent(string timeofday, float elevation, string identifier)
                {
                m_ts.fnTimeOfDay_addTimeOfDayEvent(timeofday, elevation, identifier);
                }

            /// <summary>
            /// )
            /// 
            /// </summary>
            public void animate(string timeofday, float elevation, float degreesPerSecond)
                {
                m_ts.fnTimeOfDay_animate(timeofday, elevation, degreesPerSecond);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void setDayLength(string timeofday, float seconds)
                {
                m_ts.fnTimeOfDay_setDayLength(timeofday, seconds);
                }

            /// <summary>
            /// )
            /// 
            /// </summary>
            public void setPlay(string timeofday, bool enabled)
                {
                m_ts.fnTimeOfDay_setPlay(timeofday, enabled);
                }

            /// <summary>
            ///  )
            /// 
            /// </summary>
            public void setTimeOfDay(string timeofday, float time)
                {
                m_ts.fnTimeOfDay_setTimeOfDay(timeofday, time);
                }
            }

        #endregion

        #region Nested type: TriggerObject

        /// <summary>
        /// 
        /// </summary>
        public class TriggerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public TriggerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Get the number of objects that are within the Trigger's bounds.
            ///    @see getObject())
            /// 
            /// </summary>
            public int getNumObjects(string trigger)
                {
                return m_ts.fnTrigger_getNumObjects(trigger);
                }

            /// <summary>
            /// @brief Retrieve the requested object that is within the Trigger's bounds.
            ///    @param index Index of the object to get (range is 0 to getNumObjects()-1)
            ///    @returns The SimObjectID of the object, or -1 if the requested index is invalid.
            ///    @see getNumObjects())
            /// 
            /// </summary>
            public int getObject(string trigger, int index)
                {
                return m_ts.fnTrigger_getObject(trigger, index);
                }
            }

        #endregion

        #region Nested type: TurretShapeObject

        /// <summary>
        /// 
        /// </summary>
        public class TurretShapeObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public TurretShapeObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Does the turret respawn after it has been destroyed.
            ///    @returns True if the turret respawns.)
            /// 
            /// </summary>
            public bool doRespawn(string turretshape)
                {
                return m_ts.fnTurretShape_doRespawn(turretshape);
                }

            /// <summary>
            /// @brief Get if the turret is allowed to fire through moves.
            ///    @return True if the turret is allowed to fire through moves. )
            /// 
            /// </summary>
            public bool getAllowManualFire(string turretshape)
                {
                return m_ts.fnTurretShape_getAllowManualFire(turretshape);
                }

            /// <summary>
            /// @brief Get if the turret is allowed to rotate through moves.
            ///    @return True if the turret is allowed to rotate through moves. )
            /// 
            /// </summary>
            public bool getAllowManualRotation(string turretshape)
                {
                return m_ts.fnTurretShape_getAllowManualRotation(turretshape);
                }

            /// <summary>
            /// @brief Get the name of the turret's current state.
            /// 
            ///    The state is one of the following:ul>
            ///    li>Dead - The TurretShape is destroyed./li>
            ///    li>Mounted - The TurretShape is mounted to an object such as a vehicle./li>
            ///    li>Ready - The TurretShape is free to move.  The usual state./li>/ul>
            /// 
            ///    @return The current state; one of: \"Dead\", \"Mounted\", \"Ready\" )
            /// 
            /// </summary>
            public string getState(string turretshape)
                {
                return m_ts.fnTurretShape_getState(turretshape);
                }

            /// <summary>
            /// @brief Get Euler rotation of this turret's heading and pitch nodes.
            ///    @return the orientation of the turret's heading and pitch nodes in the 
            ///    form of rotations around the X, Y and Z axes in degrees. )
            /// 
            /// </summary>
            public Point3F getTurretEulerRotation(string turretshape)
                {
                return new Point3F(m_ts.fnTurretShape_getTurretEulerRotation(turretshape));
                }

            /// <summary>
            /// @brief Set if the turret is allowed to fire through moves.
            ///    @param allow If true then the turret may be fired through moves.)
            /// 
            /// </summary>
            public void setAllowManualFire(string turretshape, bool allow)
                {
                m_ts.fnTurretShape_setAllowManualFire(turretshape, allow);
                }

            /// <summary>
            /// @brief Set if the turret is allowed to rotate through moves.
            ///    @param allow If true then the turret may be rotated through moves.)
            /// 
            /// </summary>
            public void setAllowManualRotation(string turretshape, bool allow)
                {
                m_ts.fnTurretShape_setAllowManualRotation(turretshape, allow);
                }

            /// <summary>
            /// @brief Set Euler rotation of this turret's heading and pitch nodes in degrees.
            ///    @param rot The rotation in degrees.  The pitch is the X component and the 
            ///    heading is the Z component.  The Y component is ignored.)
            /// 
            /// </summary>
            public void setTurretEulerRotation(string turretshape, Point3F rot)
                {
                m_ts.fnTurretShape_setTurretEulerRotation(turretshape, rot.AsString());
                }
            }

        #endregion

        #region Nested type: UndoActionObject

        /// <summary>
        /// 
        /// </summary>
        public class UndoActionObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public UndoActionObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (UndoAction, addToManager, void, 2, 3, action.addToManager([undoManager]))
            /// 
            /// </summary>
            public void addToManager(string undoaction = "", string a2 = "")
                {
                m_ts.fnUndoAction_addToManager(undoaction, a2);
                }

            /// <summary>
            /// ( UndoAction, redo, void, 2, 2, () - Reo action contained in undo. )
            /// 
            /// </summary>
            public void redo(string undoaction = "")
                {
                m_ts.fnUndoAction_redo(undoaction);
                }

            /// <summary>
            /// ( UndoAction, undo, void, 2, 2, () - Undo action contained in undo. )
            /// 
            /// </summary>
            public void undo(string undoaction = "")
                {
                m_ts.fnUndoAction_undo(undoaction);
                }
            }

        #endregion

        #region Nested type: UndoManagerObject

        /// <summary>
        /// 
        /// </summary>
        public class UndoManagerObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public UndoManagerObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// (UndoManager, clearAll, void, 2, 2, Clears the undo manager.)
            /// 
            /// </summary>
            public void clearAll(string undomanager = "")
                {
                m_ts.fnUndoManager_clearAll(undomanager);
                }

            /// <summary>
            /// (UndoManager, getNextRedoName, const char *, 2, 2, UndoManager.getNextRedoName();)
            /// 
            /// </summary>
            public string getNextRedoName(string undomanager = "")
                {
                return m_ts.fnUndoManager_getNextRedoName(undomanager);
                }

            /// <summary>
            /// (UndoManager, getNextUndoName, const char *, 2, 2, UndoManager.getNextUndoName();)
            /// 
            /// </summary>
            public string getNextUndoName(string undomanager = "")
                {
                return m_ts.fnUndoManager_getNextUndoName(undomanager);
                }

            /// <summary>
            /// (UndoManager, getRedoAction, S32, 3, 3, (index))
            /// 
            /// </summary>
            public int getRedoAction(string undomanager, string a2 = "")
                {
                return m_ts.fnUndoManager_getRedoAction(undomanager, a2);
                }

            /// <summary>
            /// (UndoManager, getRedoCount, S32, 2, 2, )
            /// 
            /// </summary>
            public int getRedoCount(string undomanager = "")
                {
                return m_ts.fnUndoManager_getRedoCount(undomanager);
                }

            /// <summary>
            /// (UndoManager, getRedoName, const char*, 3, 3, (index))
            /// 
            /// </summary>
            public string getRedoName(string undomanager, string a2 = "")
                {
                return m_ts.fnUndoManager_getRedoName(undomanager, a2);
                }

            /// <summary>
            /// (UndoManager, getUndoAction, S32, 3, 3, (index))
            /// 
            /// </summary>
            public int getUndoAction(string undomanager, string a2 = "")
                {
                return m_ts.fnUndoManager_getUndoAction(undomanager, a2);
                }

            /// <summary>
            /// (UndoManager, getUndoCount, S32, 2, 2, )
            /// 
            /// </summary>
            public int getUndoCount(string undomanager = "")
                {
                return m_ts.fnUndoManager_getUndoCount(undomanager);
                }

            /// <summary>
            /// (UndoManager, getUndoName, const char*, 3, 3, (index))
            /// 
            /// </summary>
            public string getUndoName(string undomanager, string a2 = "")
                {
                return m_ts.fnUndoManager_getUndoName(undomanager, a2);
                }

            /// <summary>
            /// ( UndoManager, popCompound, void, 2, 3, ( bool discard=false ) - Pop the current CompoundUndoAction off the stack. )
            /// 
            /// </summary>
            public void popCompound(string undomanager = "", string a2 = "")
                {
                m_ts.fnUndoManager_popCompound(undomanager, a2);
                }

            /// <summary>
            /// ( UndoManager, pushCompound, const char*, 2, 3, ( string name=\"\" ) - Push a CompoundUndoAction onto the compound stack for assembly. )
            /// 
            /// </summary>
            public string pushCompound(string undomanager = "", string a2 = "")
                {
                return m_ts.fnUndoManager_pushCompound(undomanager, a2);
                }

            /// <summary>
            /// (UndoManager, redo, void, 2, 2, UndoManager.redo();)
            /// 
            /// </summary>
            public void redo(string undomanager = "")
                {
                m_ts.fnUndoManager_redo(undomanager);
                }

            /// <summary>
            /// (UndoManager, undo, void, 2, 2, UndoManager.undo();)
            /// 
            /// </summary>
            public void undo(string undomanager = "")
                {
                m_ts.fnUndoManager_undo(undomanager);
                }
            }

        #endregion

        #region Nested type: UtilObject

        /// <summary>
        /// 
        /// </summary>
        public class UtilObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public UtilObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( activateDirectInput, void, 1, 1,()
            ///             @brief Activates DirectInput.
            ///             Also activates any connected joysticks.
            /// 			@ingroup Input)
            /// 
            /// </summary>
            public void _activateDirectInput()
                {
                m_ts.fn__activateDirectInput();
                }

            /// <summary>
            /// ( addMaterialMapping, void, 3, 3, (string texName, string matName)
            ///    @brief Maps the given texture to the given material.
            ///    Generates a console warning before overwriting.
            ///    Material maps are used by terrain and interiors for triggering 
            ///    effects when an object moves onto a terrain 
            ///    block or interior surface using the associated texture.
            ///    @ingroup Materials)
            /// 
            /// </summary>
            public void _addMaterialMapping(string a1, string a2)
                {
                m_ts.fn__addMaterialMapping(a1, a2);
                }

            /// <summary>
            /// ( addTaggedString, const char*, 2, 2, (string str)
            ///    @brief Use the addTaggedString function to tag a new string and add it to the NetStringTable
            /// 
            ///    @param str The string to be tagged and placed in the NetStringTable. Tagging ignores case, 
            ///    so tagging the same string (excluding case differences) will be ignored as a duplicated tag.
            /// 
            ///    @return Returns a string( containing a numeric value) equivalent to the string ID for the newly tagged string
            /// 
            ///    @see \\ref syntaxDataTypes under Tagged %Strings
            ///    @see removeTaggedString()
            ///    @see getTaggedString()
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public string _addTaggedString(string a1)
                {
                return m_ts.fn__addTaggedString(a1);
                }

            /// <summary>
            /// ( aiAddPlayer, S32 , 2, 3, aiAddPlayer( 'playerName'[, 'AIClassType'] ); ) 
            /// </summary>
            public int _aiAddPlayer(string a1, string a2 = "")
                {
                return m_ts.fn__aiAddPlayer(a1, a2);
                }

            /// <summary>
            /// (aiConnect, S32 , 2, 20, (...)
            ///    @brief Creates a new AIConnection, and passes arguments to its onConnect script callback.
            ///    @returns The newly created AIConnection
            ///    @see GameConnection for parameter information
            ///    @ingroup AI)
            /// 
            /// </summary>
            public int _aiConnect(string a1, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                return m_ts.fn__aiConnect(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// ( buildTaggedString, const char*, 2, 11, (string format, ...)
            ///    @brief Build a string using the specified tagged string format.
            /// 
            ///    This function takes an already tagged string (passed in as a tagged string ID) and one 
            ///    or more additional strings.  If the tagged string contains argument tags that range from 
            ///    %%1 through %%9, then each additional string will be substituted into the tagged string.  
            ///    The final (non-tagged) combined string will be returned.  The maximum length of the tagged 
            ///    string plus any inserted additional strings is 511 characters.
            /// 
            ///    @param format A tagged string ID that contains zero or more argument tags, in the form of 
            ///    %%1 through %%9.
            ///    @param ... A variable number of arguments that are insterted into the tagged string 
            ///    based on the argument tags within the format string.
            /// 
            ///    @returns An ordinary string that is a combination of the original tagged string with any additional 
            ///    strings passed in inserted in place of each argument tag.
            /// 
            ///    @tsexample
            ///       // Create a tagged string with argument tags
            ///       %taggedStringID = addTaggedString(\"Welcome %1 to the game!\");
            /// 
            ///       // Some point later, combine the tagged string with some other string
            ///       %string = buildTaggedString(%taggedStringID, %playerName);
            ///       echo(%string);
            /// 	@endtsexample
            /// 
            ///    @see \\ref syntaxDataTypes under Tagged %Strings
            ///    @see addTaggedString()
            ///    @see getTaggedString()
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public string _buildTaggedString(string a1, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "")
                {
                return m_ts.fn__buildTaggedString(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                }

            /// <summary>
            /// ( call, const char *, 2, 0, ( string functionName, string args... ) 
            ///    Apply the given arguments to the specified global function and return the result of the call.
            ///    @param functionName The name of the function to call.  This function must be in the global namespace, i.e. 
            ///       you cannot call a function in a namespace through #call.  Use eval() for that.
            ///    @return The result of the function call.
            ///    @tsexample
            ///       function myFunction( %arg )
            ///       {
            ///         return ( %arg SPC \"World!\" );
            ///       }
            ///       
            ///       echo( call( \"myFunction\", \"Hello\" ) ); // Prints \"Hello World!\" to the console.
            ///    @endtsexample
            ///    @ingroup Scripting )
            /// 
            /// </summary>
            public string _call(string a1, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                return m_ts.fn__call(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// (cancel,void,2,2,cancel(eventId))
            /// 
            /// </summary>
            public void _cancel(string a1)
                {
                m_ts.fn__cancel(a1);
                }

            /// <summary>
            /// (cancelAll,void,2,2,cancelAll(objectId): cancel pending events on the specified object.  Events will be automatically cancelled if object is deleted.)
            /// 
            /// </summary>
            public void _cancelAll(string a1)
                {
                m_ts.fn__cancelAll(a1);
                }

            /// <summary>
            /// (clearClientPaths, void, 1, 1, )
            /// 
            /// </summary>
            public void _clearClientPaths()
                {
                m_ts.fn__clearClientPaths();
                }

            /// <summary>
            /// (clearServerPaths, void, 1, 1, )
            /// 
            /// </summary>
            public void _clearServerPaths()
                {
                m_ts.fn__clearServerPaths();
                }

            /// <summary>
            /// ( closeNetPort, void, 1, 1, ()
            ///    @brief Closes the current network port
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public void _closeNetPort()
                {
                m_ts.fn__closeNetPort();
                }

            /// <summary>
            /// (containerFindFirst, const char*, 6, 6, (int mask, Point3F point, float x, float y, float z)
            ///    @brief Find objects matching the bitmask type within a box centered at point, with extents x, y, z.
            ///    @returns The first object found, or an empty string if nothing was found.  Thereafter, you can get more 
            ///    results using containerFindNext().
            ///    @see containerFindNext
            ///    @ingroup Game)
            /// 
            /// </summary>
            public string _containerFindFirst(string a1, string a2, string a3, string a4, string a5)
                {
                return m_ts.fn__containerFindFirst(a1, a2, a3, a4, a5);
                }

            /// <summary>
            /// ( containerFindNext, const char*, 1, 1, ()
            ///    @brief Get more results from a previous call to containerFindFirst().
            ///    @note You must call containerFindFirst() to begin the search.
            ///    @returns The next object found, or an empty string if nothing else was found.
            ///    @see containerFindFirst()
            /// 	@ingroup Game)
            /// 
            /// </summary>
            public string _containerFindNext()
                {
                return m_ts.fn__containerFindNext();
                }

            /// <summary>
            /// ( dbgIsConnected, bool, 1, 1, ()
            ///                 Returns true if a script debugging client is connected else return false.
            /// 				@internal Primarily used for Torsion and other debugging tools)
            /// 
            /// </summary>
            public bool _dbgIsConnected()
                {
                return m_ts.fn__dbgIsConnected();
                }

            /// <summary>
            /// ( deactivateDirectInput, void, 1, 1, ()
            ///             @brief Disables DirectInput.
            ///             Also deactivates any connected joysticks.
            /// 			@ingroup Input )
            /// 
            /// </summary>
            public void _deactivateDirectInput()
                {
                m_ts.fn__deactivateDirectInput();
                }

            /// <summary>
            /// ( disableJoystick, void, 1, 1,()
            ///              @brief Disables use of the joystick.
            ///              @note DirectInput must be enabled and active to use this function.
            ///              @ingroup Input)
            /// 
            /// </summary>
            public void _disableJoystick()
                {
                m_ts.fn__disableJoystick();
                }

            /// <summary>
            /// ( disableXInput, void, 1, 1, ()
            ///             @brief Disables XInput for Xbox 360 controllers.
            ///             @ingroup Input)
            /// 
            /// </summary>
            public void _disableXInput()
                {
                m_ts.fn__disableXInput();
                }

            /// <summary>
            /// ( dumpMaterialInstances, void, 1, 1, 
            ///    @brief Dumps a formatted list of currently allocated material instances to the console.
            ///    @ingroup Materials)
            /// 
            /// </summary>
            public void _dumpMaterialInstances()
                {
                m_ts.fn__dumpMaterialInstances();
                }

            /// <summary>
            /// ( dumpProcessList, void, 1, 1, 
            ///    Dumps all ProcessObjects in ServerProcessList and ClientProcessList to the console. )
            /// 
            /// </summary>
            public void _dumpProcessList()
                {
                m_ts.fn__dumpProcessList();
                }

            /// <summary>
            /// ( echo, void, 2, 0, ( string message... ) 
            ///    @brief Logs a message to the console.
            ///    Concatenates all given arguments to a single string and prints the string to the console. 
            ///    A newline is added automatically after the text.
            ///    @param message Any number of string arguments.
            ///    @ingroup Logging )
            /// 
            /// </summary>
            public void _echo(string a1, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fn__echo(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// ( enableJoystick, bool, 1, 1, ()
            ///              @brief Enables use of the joystick.
            ///              @note DirectInput must be enabled and active to use this function.
            ///              @ingroup Input)
            /// 
            /// </summary>
            public bool _enableJoystick()
                {
                return m_ts.fn__enableJoystick();
                }

            /// <summary>
            /// ( enableSamples, void, 2, 3, (pattern, [state]) -
            /// 				@brief Enable sampling for all keys that match the given name 
            /// 				pattern. Slashes are treated as separators.
            /// 				@ingroup Rendering)
            /// 
            /// </summary>
            public void _enableSamples(string a1, string a2 = "")
                {
                m_ts.fn__enableSamples(a1, a2);
                }

            /// <summary>
            /// ( enableXInput, bool, 1, 1, ()
            ///             @brief Enables XInput for Xbox 360 controllers.
            ///             @note XInput is enabled by default. Disable to use an Xbox 360 
            ///             Controller as a joystick device.
            /// 				@ingroup Input)
            /// 
            /// </summary>
            public bool _enableXInput()
                {
                return m_ts.fn__enableXInput();
                }

            /// <summary>
            /// ( error, void, 2, 0, ( string message... ) 
            ///    @brief Logs an error message to the console.
            ///    Concatenates all given arguments to a single string and prints the string to the console as an error 
            ///    message (in the in-game console, these will show up using a red font by default). 
            ///    A newline is added automatically after the text.
            ///    @param message Any number of string arguments.
            ///    @ingroup Logging )
            /// 
            /// </summary>
            public void _error(string a1, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fn__error(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// (eval, const char *, 2, 2, eval(consoleString))
            /// 
            /// </summary>
            public string _eval(string a1)
                {
                return m_ts.fn__eval(a1);
                }

            /// <summary>
            /// ( execPrefs, bool, 2, 4, ( string relativeFileName, bool noCalls=false, bool journalScript=false )
            /// 				@brief Manually execute a special script file that contains game or editor preferences
            /// 				@param relativeFileName Name and path to file from project folder
            /// 				@param noCalls Deprecated
            /// 				@param journalScript Deprecated
            /// 				@return True if script was successfully executed
            /// 				@note Appears to be useless in Torque 3D, should be deprecated
            /// 				@ingroup Scripting)
            /// 
            /// </summary>
            public bool _execPrefs(string a1, string a2 = "", string a3 = "")
                {
                return m_ts.fn__execPrefs(a1, a2, a3);
                }

            /// <summary>
            /// (expandFilename, const char*, 2, 2, (string filename)
            /// 				@brief Grabs the full path of a specified file
            /// 				@param filename Name of the local file to locate
            /// 				@return String containing the full filepath on disk
            /// 				@ingroup FileSystem)
            /// 
            /// </summary>
            public string _expandFilename(string a1)
                {
                return m_ts.fn__expandFilename(a1);
                }

            /// <summary>
            /// ( getBuildString, const char*, 1, 1, Get the type of build, \"Debug\" or \"Release\".
            /// 				@ingroup Debugging)
            /// 
            /// </summary>
            public string _getBuildString()
                {
                return m_ts.fn__getBuildString();
                }

            /// <summary>
            /// ( getClipboard, const char*, 1, 1, ()
            /// 				@brief Get text from the clipboard.
            /// 				@internal)
            /// 
            /// </summary>
            public string _getClipboard()
                {
                return m_ts.fn__getClipboard();
                }

            /// <summary>
            /// ( getCompileTimeString, const char*, 1, 1, Get the time of compilation.
            /// 				@ingroup Debugging)
            /// 
            /// </summary>
            public string _getCompileTimeString()
                {
                return m_ts.fn__getCompileTimeString();
                }

            /// <summary>
            /// ( getEngineName, const char*, 1, 1, Get the name of the engine product that this is running from, as a string.
            /// 				@ingroup Debugging)
            /// 
            /// </summary>
            public string _getEngineName()
                {
                return m_ts.fn__getEngineName();
                }

            /// <summary>
            /// (getEventTimeLeft, S32, 2, 2, getEventTimeLeft(scheduleId) Get the time left in ms until this event will trigger.)
            /// 
            /// </summary>
            public int _getEventTimeLeft(string a1)
                {
                return m_ts.fn__getEventTimeLeft(a1);
                }

            /// <summary>
            /// (getFunctionPackage, const char*, 2, 2, (string funcName)
            /// 	@brief Provides the name of the package the function belongs to
            /// 	@param funcName String containing name of the function
            /// 	@return The name of the function's package
            /// 	@ingroup Packages)
            /// 
            /// </summary>
            public string _getFunctionPackage(string a1)
                {
                return m_ts.fn__getFunctionPackage(a1);
                }

            /// <summary>
            /// ( getMapEntry, const char *, 2, 2, 
            ///    @hide)
            /// 
            /// </summary>
            public string _getMapEntry(string a1)
                {
                return m_ts.fn__getMapEntry(a1);
                }

            /// <summary>
            /// ( getMaterialMapping, const char*, 2, 2, (string texName)
            ///    @brief Returns the name of the material mapped to this texture.
            ///    If no materials are found, an empty string is returned.
            ///    @param texName Name of the texture
            ///    @ingroup Materials)
            /// 
            /// </summary>
            public string _getMaterialMapping(string a1)
                {
                return m_ts.fn__getMaterialMapping(a1);
                }

            /// <summary>
            /// (getMethodPackage, const char*, 3, 3, (string namespace, string method)
            /// 	@brief Provides the name of the package the method belongs to
            /// 	@param namespace Class or namespace, such as Player
            /// 	@param method Name of the funciton to search for
            /// 	@return The name of the method's package
            /// 	@ingroup Packages)
            /// 
            /// </summary>
            public string _getMethodPackage(string a1, string a2)
                {
                return m_ts.fn__getMethodPackage(a1, a2);
                }

            /// <summary>
            /// (getModNameFromPath, const char *, 2, 2, (string path)
            /// 				@brief Attempts to extract a mod directory from path. Returns empty string on failure.
            /// 				@param File path of mod folder
            /// 				@note This is no longer relevant in Torque 3D (which does not use mod folders), should be deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public string _getModNameFromPath(string a1)
                {
                return m_ts.fn__getModNameFromPath(a1);
                }

            /// <summary>
            /// (getPrefsPath, const char *, 1, 2, ([relativeFileName])
            /// 				@note Appears to be useless in Torque 3D, should be deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public string _getPrefsPath(string a1 = "")
                {
                return m_ts.fn__getPrefsPath(a1);
                }

            /// <summary>
            /// ( getRandom, F32, 1, 3,
            ///    ( int a, int b ) 
            ///    @brief Returns a random number based on parameters passed in..
            ///    If no parameters are passed in, getRandom() will return a float between 0.0 and 1.0. If one 
            ///    parameter is passed an integer between 0 and the passed in value will be returned. Two parameters will 
            ///    return an integer between the specified numbers.
            ///    @param a If this is the only parameter, a number between 0 and a is returned. Elsewise represents the lower bound.
            ///    @param b Upper bound on the random number.  The random number will be = @a b.
            ///    @return A pseudo-random integer between @a a and @a b, between 0 and a, or a 
            ///    float between 0.0 and 1.1 depending on usage.
            ///    @note All parameters are optional.
            ///    @see setRandomSeed
            ///    @ingroup Random )
            /// 
            /// </summary>
            public float _getRandom(string a1 = "", string a2 = "")
                {
                return m_ts.fn__getRandom(a1, a2);
                }

            /// <summary>
            /// ( getRealTime, S32, 1, 1, ()
            /// 				@brief Return the current real time in milliseconds.
            ///                 Real time is platform defined; typically time since the computer booted.
            /// 				@ingroup Platform)
            /// 
            /// </summary>
            public int _getRealTime()
                {
                return m_ts.fn__getRealTime();
                }

            /// <summary>
            /// (getScheduleDuration, S32, 2, 2, getScheduleDuration(%scheduleId);)
            /// 
            /// </summary>
            public int _getScheduleDuration(string a1)
                {
                return m_ts.fn__getScheduleDuration(a1);
                }

            /// <summary>
            /// ( getServerCount, int, 1, 1, getServerCount(); )
            /// 
            /// </summary>
            public int _getServerCount()
                {
                return m_ts.fn__getServerCount();
                }

            /// <summary>
            /// ( getSimTime, S32, 1, 1, ()
            /// 				Return the current sim time in milliseconds.
            ///                 @brief Sim time is time since the game started.
            /// 				@ingroup Platform)
            /// 
            /// </summary>
            public int _getSimTime()
                {
                return m_ts.fn__getSimTime();
                }

            /// <summary>
            /// (getTag, const char *, 2, 2, (string textTagString)
            ///    @brief Extracts the tag from a tagged string
            /// 
            ///    Should only be used within the context of a function that receives a tagged 
            ///    string, and is not meant to be used outside of this context.
            /// 
            ///    @param textTagString The tagged string to extract.
            /// 
            ///    @returns The tag ID of the string.
            /// 
            ///    @see \\ref syntaxDataTypes under Tagged %Strings
            ///    @see detag()
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public string _getTag(string a1)
                {
                return m_ts.fn__getTag(a1);
                }

            /// <summary>
            /// ( getTaggedString, const char*, 2, 2, (int tag)
            ///    @brief Use the getTaggedString function to convert a tag to a string.
            /// 
            ///    This is not the same as detag() which can only be used within the context 
            ///    of a function that receives a tag. This function can be used any time and 
            ///    anywhere to convert a tag to a string.
            /// 
            ///    @param tag A numeric tag ID.
            /// 
            ///    @returns The string as found in the Net String table.
            /// 
            ///    @see \\ref syntaxDataTypes under Tagged %Strings
            ///    @see addTaggedString()
            ///    @see removeTaggedString()
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public string _getTaggedString(string a1)
                {
                return m_ts.fn__getTaggedString(a1);
                }

            /// <summary>
            /// (getTemporaryDirectory, const char *, 1, 1, ()
            /// 				@brief Returns the OS temporary directory, \"C:/Users/Mich/AppData/Local/Temp\" for example
            /// 				@note This can be useful to adhering to OS standards and practices, 
            /// 				but not really used in Torque 3D right now.
            /// 				@note Be very careful when getting into OS level File I/O.
            /// 				@return String containing path to OS temp directory
            /// 				@note This is legacy function brought over from TGB, and does not appear 
            /// 				to have much use. Possibly deprecate?
            /// 				@ingroup FileSystem
            /// 				@internal)
            /// 
            /// </summary>
            public string _getTemporaryDirectory()
                {
                return m_ts.fn__getTemporaryDirectory();
                }

            /// <summary>
            /// (getTemporaryFileName, const char *, 1, 1, ()
            /// 				@brief Creates a name and extension for a potential temporary file
            /// 				This does not create the actual file. It simply creates a random name 
            /// 				for a file that does not exist.
            /// 				@note This is legacy function brought over from TGB, and does not appear 
            /// 				to have much use. Possibly deprecate?
            /// 				@ingroup FileSystem
            /// 				@internal)
            /// 
            /// </summary>
            public string _getTemporaryFileName()
                {
                return m_ts.fn__getTemporaryFileName();
                }

            /// <summary>
            /// (getTimeSinceStart, S32, 2, 2, getTimeSinceStart(%scheduleId);)
            /// 
            /// </summary>
            public int _getTimeSinceStart(string a1)
                {
                return m_ts.fn__getTimeSinceStart(a1);
                }

            /// <summary>
            /// (getUniqueInternalName, const char*, 4, 4,
            ///    ( String baseName, SimSet set, bool searchChildren )
            ///    @brief Returns a unique unused internal name within the SimSet/Group based on a given base name.
            ///    @note Currently only used by editors
            ///    @ingroup Editors
            ///    @internal)
            /// 
            /// </summary>
            public string _getUniqueInternalName(string a1, string a2, string a3)
                {
                return m_ts.fn__getUniqueInternalName(a1, a2, a3);
                }

            /// <summary>
            /// (getUniqueName, const char*, 2, 2, 
            /// 	( String baseName )
            /// 	@brief Returns a unique unused SimObject name based on a given base name.
            /// 	@baseName Name to conver to a unique string if another instance exists
            /// 	@note Currently only used by editors
            /// 	@ingroup Editors
            /// 	@internal)
            /// 
            /// </summary>
            public string _getUniqueName(string a1)
                {
                return m_ts.fn__getUniqueName(a1);
                }

            /// <summary>
            /// (getUserDataDirectory, const char*, 1, 1, getUserDataDirectory())
            /// 
            /// </summary>
            public string _getUserDataDirectory()
                {
                return m_ts.fn__getUserDataDirectory();
                }

            /// <summary>
            /// (getUserHomeDirectory, const char*, 1, 1, getUserHomeDirectory())
            /// 
            /// </summary>
            public string _getUserHomeDirectory()
                {
                return m_ts.fn__getUserHomeDirectory();
                }

            /// <summary>
            /// (getVariable, const char *, 2, 2, (string varName)
            ///    @brief Returns the value of the named variable or an empty string if not found.
            ///    @varName Name of the variable to search for
            ///    @return Value contained by varName, \"\" if the variable does not exist
            ///    @ingroup Scripting)
            /// 
            /// </summary>
            public string _getVariable(string a1)
                {
                return m_ts.fn__getVariable(a1);
                }

            /// <summary>
            /// ( getVersionNumber, S32, 1, 1, Get the version of the build, as a string.
            /// 				@ingroup Debugging)
            /// 
            /// </summary>
            public int _getVersionNumber()
                {
                return m_ts.fn__getVersionNumber();
                }

            /// <summary>
            /// ( getVersionString, const char*, 1, 1, Get the version of the build, as a string.
            /// 				@ingroup Debugging)
            /// 
            /// </summary>
            public string _getVersionString()
                {
                return m_ts.fn__getVersionString();
                }

            /// <summary>
            /// ( getXInputState, int, 3, 4, ( int controllerID, string property, bool current )
            /// 				@brief Queries the current state of a connected Xbox 360 controller.
            ///             XInput Properties:
            ///              - XI_THUMBLX, XI_THUMBLY - X and Y axes of the left thumbstick. 
            ///              - XI_THUMBRX, XI_THUMBRY - X and Y axes of the right thumbstick. 
            ///              - XI_LEFT_TRIGGER, XI_RIGHT_TRIGGER - Left and Right triggers. 
            ///              - SI_UPOV, SI_DPOV, SI_LPOV, SI_RPOV - Up, Down, Left, and Right on the directional pad.
            ///              - XI_START, XI_BACK - The Start and Back buttons.
            ///              - XI_LEFT_THUMB, XI_RIGHT_THUMB - Clicking in the left and right thumbstick.
            ///              - XI_LEFT_SHOULDER, XI_RIGHT_SHOULDER - Left and Right bumpers.
            ///              - XI_A, XI_B , XI_X, XI_Y - The A, B, X, and Y buttons.
            ///             @param controllerID Zero-based index of the controller to return information about.
            ///             @param property Name of input action being queried, such as \"XI_THUMBLX\".
            ///             @param current True checks current device in action.
            ///             @return Button queried - 1 if the button is pressed, 0 if it's not.
            ///             @return Thumbstick queried - Int representing displacement from rest position.
            ///             @return %Trigger queried - Int from 0 to 255 representing how far the trigger is displaced.
            ///             @ingroup Input)
            /// 
            /// </summary>
            public int _getXInputState(string a1, string a2, string a3 = "")
                {
                return m_ts.fn__getXInputState(a1, a2, a3);
                }

            /// <summary>
            /// ( isCurrentScriptToolScript, bool, 1, 1,
            ///    () Returns true if the calling script is a tools script.
            ///    @hide)
            /// 
            /// </summary>
            public bool _isCurrentScriptToolScript()
                {
                return m_ts.fn__isCurrentScriptToolScript();
                }

            /// <summary>
            /// (isDefined, bool, 2, 3, (string varName)
            /// 	@brief Determines if a variable exists and contains a value
            /// 	@param varName Name of the variable to search for
            /// 	@return True if the variable was defined in script, false if not
            ///    @tsexample
            ///       isDefined( \"$myVar\" );
            ///    @endtsexample
            /// 	@ingroup Scripting)
            /// 
            /// </summary>
            public bool _isDefined(string a1, string a2 = "")
                {
                return m_ts.fn__isDefined(a1, a2);
                }

            /// <summary>
            /// (isDemo, bool, 1, 1, )
            /// 
            /// </summary>
            public bool _isDemo()
                {
                return m_ts.fn__isDemo();
                }

            /// <summary>
            /// (isEventPending, bool, 2, 2, isEventPending(%scheduleId);)
            /// 
            /// </summary>
            public bool _isEventPending(string a1)
                {
                return m_ts.fn__isEventPending(a1);
                }

            /// <summary>
            /// (isFunction, bool, 2, 2, (string funcName)
            /// 	@brief Determines if a function exists or not
            /// 	@param funcName String containing name of the function
            /// 	@return True if the function exists, false if not
            /// 	@ingroup Scripting)
            /// 
            /// </summary>
            public bool _isFunction(string a1)
                {
                return m_ts.fn__isFunction(a1);
                }

            /// <summary>
            /// ( isJoystickDetected, bool, 1, 1, isJoystickDetected() )
            /// 
            /// </summary>
            public bool _isJoystickDetected()
                {
                return m_ts.fn__isJoystickDetected();
                }

            /// <summary>
            /// ( isJoystickEnabled, bool, 1, 1, ()
            /// 				@brief Queries input manager to see if a joystick is enabled
            /// 				@return 1 if a joystick exists and is enabled, 0 if it's not.
            /// 				@ingroup Input)
            /// 
            /// </summary>
            public bool _isJoystickEnabled()
                {
                return m_ts.fn__isJoystickEnabled();
                }

            /// <summary>
            /// (isMethod, bool, 3, 3, (string namespace, string method)
            /// 	@brief Determines if a class/namespace method exists
            /// 	@param namespace Class or namespace, such as Player
            /// 	@param method Name of the function to search for
            /// 	@return True if the method exists, false if not
            /// 	@ingroup Scripting)
            /// 
            /// </summary>
            public bool _isMethod(string a1, string a2)
                {
                return m_ts.fn__isMethod(a1, a2);
                }

            /// <summary>
            /// (isObject, bool, 2, 2, isObject(object))
            /// 
            /// </summary>
            public bool _isObject(string a1)
                {
                return m_ts.fn__isObject(a1);
                }

            /// <summary>
            /// ( isPointInside, bool, 2, 4, Check to see if a point in world space is inside of an interior.
            /// 				@hide)
            /// 
            /// </summary>
            public bool _isPointInside(string a1, string a2 = "", string a3 = "")
                {
                return m_ts.fn__isPointInside(a1, a2, a3);
                }

            /// <summary>
            /// ( isValidObjectName, bool, 2, 2, ( string name )
            /// 				@brief Return true if the given name makes for a valid object name.
            /// 				@param name Name of object
            /// 				@return True if name is allowed, false if denied (usually because it starts with a number, _, or invalid character
            /// 				@ingroup Console)
            /// 
            /// </summary>
            public bool _isValidObjectName(string a1)
                {
                return m_ts.fn__isValidObjectName(a1);
                }

            /// <summary>
            /// (isWebDemo, bool, 1, 1, )
            /// 
            /// </summary>
            public bool _isWebDemo()
                {
                return m_ts.fn__isWebDemo();
                }

            /// <summary>
            /// ( isXInputConnected, bool, 2, 2, ( int controllerID )
            /// 				@brief Checks to see if an Xbox 360 controller is connected
            /// 				@param controllerID Zero-based index of the controller to check.
            ///             @return 1 if the controller is connected, 0 if it isn't, and 205 if XInput 
            ///             hasn't been initialized.
            /// 				@ingroup Input)
            /// 
            /// </summary>
            public bool _isXInputConnected(string a1)
                {
                return m_ts.fn__isXInputConnected(a1);
                }

            /// <summary>
            /// ( lockMouse, void, 2, 2, (bool isLocked)
            ///             @brief Lock or unlock the mouse to the window.
            ///             When true, prevents the mouse from leaving the bounds of the game window.
            ///             @ingroup Input)
            /// 
            /// </summary>
            public void _lockMouse(string a1)
                {
                m_ts.fn__lockMouse(a1);
                }

            /// <summary>
            /// (nameToID, S32, 2, 2, nameToID(object))
            /// 
            /// </summary>
            public int _nameToID(string a1)
                {
                return m_ts.fn__nameToID(a1);
                }

            /// <summary>
            /// ( nextToken, const char *, 4, 4, ( string str, string token, string delimiters ) 
            ///    Tokenize a string using a set of delimiting characters.
            ///    This function first skips all leading charaters in @a str that are contained in @a delimiters. 
            ///    From that position, it then scans for the next character in @a str that is contained in @a delimiters and stores all characters 
            ///    from the starting position up to the first delimiter in a variable in the current scope called @a token.  Finally, it 
            ///    skips all characters in @a delimiters after the token and then returns the remaining string contents in @a str.
            ///    To scan out all tokens in a string, call this function repeatedly by passing the result it returns each time as the new @a str 
            ///    until the function returns \"\".
            ///    @param str A string.
            ///    @param token The name of the variable in which to store the current token.  This variable is set in the 
            ///       scope in which nextToken is called.
            ///    @param delimiters A string of characters.  Each character is considered a delimiter.
            ///    @return The remainder of @a str after the token has been parsed out or \"\" if no more tokens were found in @a str.
            ///    @tsexample
            ///       // Prints:
            ///       // a
            ///       // b
            ///       // c
            ///       %str = \"a   b c\";
            ///       while ( %str !$= \"\" )
            ///       {
            ///          // First time, stores \"a\" in the variable %token and sets %str to \"b c\".
            ///          %str = nextToken( %str, \"token\", \" \" );
            ///          echo( %token );
            ///       }
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string _nextToken(string a1, string a2, string a3)
                {
                return m_ts.fn__nextToken(a1, a2, a3);
                }

            /// <summary>
            /// ( physicsDebugDraw, void, 2, 2, physicsDebugDraw( bool enable ) )
            /// 
            /// </summary>
            public void _physicsDebugDraw(string a1)
                {
                m_ts.fn__physicsDebugDraw(a1);
                }

            /// <summary>
            /// ( physicsDestroy, void, 1, 1, physicsDestroy() )
            /// 
            /// </summary>
            public void _physicsDestroy()
                {
                m_ts.fn__physicsDestroy();
                }

            /// <summary>
            /// ( physicsDestroyWorld, void, 2, 2, physicsDestroyWorld( String worldName ) )
            /// 
            /// </summary>
            public void _physicsDestroyWorld(string a1)
                {
                m_ts.fn__physicsDestroyWorld(a1);
                }

            /// <summary>
            /// ( physicsGetTimeScale, F32, 1, 1, physicsGetTimeScale() )
            /// 
            /// </summary>
            public float _physicsGetTimeScale()
                {
                return m_ts.fn__physicsGetTimeScale();
                }

            /// <summary>
            /// ( physicsInit, bool, 1, 2, physicsInit( [string library] ) )
            /// 
            /// </summary>
            public bool _physicsInit(string a1 = "")
                {
                return m_ts.fn__physicsInit(a1);
                }

            /// <summary>
            /// ( physicsInitWorld, bool, 2, 2, physicsInitWorld( String worldName ) )
            /// 
            /// </summary>
            public bool _physicsInitWorld(string a1)
                {
                return m_ts.fn__physicsInitWorld(a1);
                }

            /// <summary>
            /// ( physicsPluginPresent, bool, 1, 1, physicsPluginPresent()
            ///    @brief Returns true if a physics plugin exists and is initialized.
            ///    @ingroup Physics )
            /// 
            /// </summary>
            public bool _physicsPluginPresent()
                {
                return m_ts.fn__physicsPluginPresent();
                }

            /// <summary>
            /// ( physicsRestoreState, void, 1, 1, physicsRestoreState() )
            /// 
            /// </summary>
            public void _physicsRestoreState()
                {
                m_ts.fn__physicsRestoreState();
                }

            /// <summary>
            /// ( physicsSetTimeScale, void, 2, 2, physicsSetTimeScale( F32 scale ) )
            /// 
            /// </summary>
            public void _physicsSetTimeScale(string a1)
                {
                m_ts.fn__physicsSetTimeScale(a1);
                }

            /// <summary>
            /// ( physicsSimulationEnabled, bool, 1, 1, physicsSimulationEnabled() )
            /// 
            /// </summary>
            public bool _physicsSimulationEnabled()
                {
                return m_ts.fn__physicsSimulationEnabled();
                }

            /// <summary>
            /// ( physicsStartSimulation, void, 2, 2, physicsStartSimulation( String worldName ) )
            /// 
            /// </summary>
            public void _physicsStartSimulation(string a1)
                {
                m_ts.fn__physicsStartSimulation(a1);
                }

            /// <summary>
            /// ( physicsStopSimulation, void, 2, 2, physicsStopSimulation( String worldName ) )
            /// 
            /// </summary>
            public void _physicsStopSimulation(string a1)
                {
                m_ts.fn__physicsStopSimulation(a1);
                }

            /// <summary>
            /// ( physicsStoreState, void, 1, 1, physicsStoreState() )
            /// 
            /// </summary>
            public void _physicsStoreState()
                {
                m_ts.fn__physicsStoreState();
                }

            /// <summary>
            /// ( playJournal, void, 2, 3, (string filename)
            ///                 @brief Begin playback of a journal from a specified field.
            /// 				@param filename Name and path of file journal file
            /// 				@ingroup Platform)
            /// 
            /// </summary>
            public void _playJournal(string a1, string a2 = "")
                {
                m_ts.fn__playJournal(a1, a2);
                }

            /// <summary>
            /// ( popInstantGroup, void, 1, 1, ()
            /// 				@brief Pop and restore the last setting of $instantGroup off the stack.
            /// 				@note Currently only used for editors
            /// 				@ingroup Editors
            /// 				@internal)
            /// 
            /// </summary>
            public void _popInstantGroup()
                {
                m_ts.fn__popInstantGroup();
                }

            /// <summary>
            /// ( pushInstantGroup, void, 1, 2, ([group])
            /// 				@brief Pushes the current $instantGroup on a stack 
            /// 				and sets it to the given value (or clears it).
            /// 				@note Currently only used for editors
            /// 				@ingroup Editors
            /// 				@internal)
            /// 
            /// </summary>
            public void _pushInstantGroup(string a1 = "")
                {
                m_ts.fn__pushInstantGroup(a1);
                }

            /// <summary>
            /// ( queryAllServers, void, 12, 12, queryAllServers(...); )
            /// 
            /// </summary>
            public void _queryAllServers(string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11)
                {
                m_ts.fn__queryAllServers(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
                }

            /// <summary>
            /// ( queryLanServers, void, 12, 12, queryLanServers(...); )
            /// 
            /// </summary>
            public void _queryLanServers(string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11)
                {
                m_ts.fn__queryLanServers(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
                }

            /// <summary>
            /// ( queryMasterServer, void, 11, 11, queryMasterServer(...); )
            /// 
            /// </summary>
            public void _queryMasterServer(string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10)
                {
                m_ts.fn__queryMasterServer(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                }

            /// <summary>
            /// ( querySingleServer, void, 3, 3, querySingleServer(address, flags); )
            /// 
            /// </summary>
            public void _querySingleServer(string a1, string a2)
                {
                m_ts.fn__querySingleServer(a1, a2);
                }

            /// <summary>
            /// ( realQuit, void, 1, 1,  )
            /// 
            /// </summary>
            public void _realQuit()
                {
                m_ts.fn__realQuit();
                }

            /// <summary>
            /// (redbookClose, bool, 1, 1, Close the current Redbook device.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public bool _redbookClose()
                {
                return m_ts.fn__redbookClose();
                }

            /// <summary>
            /// ( redbookGetDeviceCount, S32, 1, 1, get the number of redbook devices.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public int _redbookGetDeviceCount()
                {
                return m_ts.fn__redbookGetDeviceCount();
                }

            /// <summary>
            /// ( redbookGetDeviceName, const char *, 2, 2, (int index) Get name of specified Redbook device.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public string _redbookGetDeviceName(string a1)
                {
                return m_ts.fn__redbookGetDeviceName(a1);
                }

            /// <summary>
            /// ( redbookGetLastError, const char*, 1, 1, Get a string explaining the last redbook error.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public string _redbookGetLastError()
                {
                return m_ts.fn__redbookGetLastError();
                }

            /// <summary>
            /// (redbookGetTrackCount, S32, 1, 1, Return the number of tracks.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public int _redbookGetTrackCount()
                {
                return m_ts.fn__redbookGetTrackCount();
                }

            /// <summary>
            /// (redbookGetVolume, F32, 1, 1, Get the volume.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public float _redbookGetVolume()
                {
                return m_ts.fn__redbookGetVolume();
                }

            /// <summary>
            /// (redbookOpen, bool, 1, 2, (string device=NULL)
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public bool _redbookOpen(string a1 = "")
                {
                return m_ts.fn__redbookOpen(a1);
                }

            /// <summary>
            /// ( redbookPlay, bool, 2, 2, (int track) Play the selected track.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public bool _redbookPlay(string a1)
                {
                return m_ts.fn__redbookPlay(a1);
                }

            /// <summary>
            /// (redbookSetVolume, bool, 2, 2, (float volume) Set playback volume.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public bool _redbookSetVolume(string a1)
                {
                return m_ts.fn__redbookSetVolume(a1);
                }

            /// <summary>
            /// ( redbookStop, bool, 1, 1, Stop playing.
            /// 				@brief Deprecated
            /// 				@internal)
            /// 
            /// </summary>
            public bool _redbookStop()
                {
                return m_ts.fn__redbookStop();
                }

            /// <summary>
            /// ( reInitMaterials, void, 1, 1, 
            ///    @brief Flushes all procedural shaders and re-initializes all active material instances. 
            ///    @ingroup Materials)
            /// 
            /// </summary>
            public void _reInitMaterials()
                {
                m_ts.fn__reInitMaterials();
                }

            /// <summary>
            /// (removeTaggedString, void, 2, 2, (int tag)
            ///    @brief Remove a tagged string from the Net String Table
            /// 
            ///    @param tag The tag associated with the string
            /// 
            ///    @see \\ref syntaxDataTypes under Tagged %Strings
            ///    @see addTaggedString()
            ///    @see getTaggedString()
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public void _removeTaggedString(string a1)
                {
                m_ts.fn__removeTaggedString(a1);
                }

            /// <summary>
            /// ( resetFPSTracker, void, 1, 1, ()
            ///    @brief Reset FPS stats (fps::)
            ///    @ingroup Game)
            /// 
            /// </summary>
            public void _resetFPSTracker()
                {
                m_ts.fn__resetFPSTracker();
                }

            /// <summary>
            /// ( resetXInput, void, 1, 1, ()
            ///             @brief Rebuilds the XInput section of the InputManager
            ///             Requests a full refresh of events for all controllers. Useful when called at the beginning 
            ///             of game code after actionMaps are set up to hook up all appropriate events.
            ///             @ingroup Input)
            /// 
            /// </summary>
            public void _resetXInput()
                {
                m_ts.fn__resetXInput();
                }

            /// <summary>
            /// ( rumble, void, 4, 4, (string device, float xRumble, float yRumble)
            ///       @brief Activates the vibration motors in the specified controller.
            ///       The controller will constantly at it's xRumble and yRumble intensities until 
            ///       changed or told to stop.
            ///       Valid inputs for xRumble/yRumble are [0 - 1].
            ///       @param device Name of the device to rumble.
            ///       @param xRumble Intensity to apply to the left motor.
            ///       @param yRumble Intensity to apply to the right motor.
            ///       @note in an Xbox 360 controller, the left motor is low-frequency, 
            ///       while the right motor is high-frequency.
            ///       @ingroup Input)
            /// 
            /// </summary>
            public void _rumble(string a1, string a2, string a3)
                {
                m_ts.fn__rumble(a1, a2, a3);
                }

            /// <summary>
            /// ( saveJournal, void, 2, 2, (string filename)
            ///                 Save the journal to the specified file.
            /// 				@ingroup Platform)
            /// 
            /// </summary>
            public void _saveJournal(string a1)
                {
                m_ts.fn__saveJournal(a1);
                }

            /// <summary>
            /// (schedule, S32, 4, 0, schedule(time, refobject|0, command, arg1...argN>))
            /// 
            /// </summary>
            public int _schedule(string a1, string a2, string a3, string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                return m_ts.fn__schedule(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// ( setClipboard, bool, 2, 2, (string text)
            ///                @brief Set the system clipboard.
            /// 			   @internal)
            /// 
            /// </summary>
            public bool _setClipboard(string a1)
                {
                return m_ts.fn__setClipboard(a1);
                }

            /// <summary>
            /// ( setInteriorFocusedDebug, void, 2, 2, (bool enable)
            /// 				@brief No longer properly supported
            /// 				@internal)
            /// 
            /// </summary>
            public void _setInteriorFocusedDebug(string a1)
                {
                m_ts.fn__setInteriorFocusedDebug(a1);
                }

            /// <summary>
            /// ( setNetPort, bool, 2, 3, (int port, bool bind=true)
            ///    @brief Set the network port for the game to use.
            /// 
            ///    @param port The port to use.
            ///    @param bind True if bind() should be called on the port.
            /// 
            ///    @returns True if the port was successfully opened.
            /// 
            ///    This will trigger a windows firewall prompt.  
            ///    If you don't have firewall tunneling tech you can set this to false to avoid the prompt.
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public bool _setNetPort(string a1, string a2 = "")
                {
                return m_ts.fn__setNetPort(a1, a2);
                }

            /// <summary>
            /// ( setServerInfo, bool, 2, 2, setServerInfo(index); )
            /// 
            /// </summary>
            public bool _setServerInfo(string a1)
                {
                return m_ts.fn__setServerInfo(a1);
                }

            /// <summary>
            /// ( setShadowManager, bool, 1, 3, string sShadowSystemName )
            /// 
            /// </summary>
            public bool _setShadowManager(string a1 = "", string a2 = "")
                {
                return m_ts.fn__setShadowManager(a1, a2);
                }

            /// <summary>
            /// ( setShadowVizLight, const char*, 2, 2,  )
            /// 
            /// </summary>
            public string _setShadowVizLight(string a1)
                {
                return m_ts.fn__setShadowVizLight(a1);
                }

            /// <summary>
            /// (setVariable, void, 3, 3, (string varName, string value)
            ///    @brief Sets the value of the named variable.
            ///    @param varName Name of the variable to locate
            ///    @param value New value of the variable
            ///    @return True if variable was successfully found and set
            ///    @ingroup Scripting)
            /// 
            /// </summary>
            public void _setVariable(string a1, string a2)
                {
                m_ts.fn__setVariable(a1, a2);
                }

            /// <summary>
            /// ( sfxCreateSource, S32, 2, 6,
            ///                      ( SFXTrack track | ( SFXDescription description, string filename ) [, float x, float y, float z ] ) 
            ///                      Creates a new paused sound source using a profile or a description 
            ///                      and filename.  The return value is the source which must be 
            ///                      released by delete().
            ///                      @hide )
            /// 
            /// </summary>
            public int _sfxCreateSource(string a1, string a2 = "", string a3 = "", string a4 = "", string a5 = "")
                {
                return m_ts.fn__sfxCreateSource(a1, a2, a3, a4, a5);
                }

            /// <summary>
            /// ( sfxPlay, S32, 2, 5, ( SFXSource source | ( SFXTrack track [, float x, float y, float z ] ) ) 
            ///    Start playing the given source or create a new source for the given track and play it.
            ///    @hide )
            /// 
            /// </summary>
            public int _sfxPlay(string a1, string a2 = "", string a3 = "", string a4 = "")
                {
                return m_ts.fn__sfxPlay(a1, a2, a3, a4);
                }

            /// <summary>
            /// ( sfxPlayOnce, S32, 2, 6,
            ///    SFXSource sfxPlayOnce( ( SFXTrack track | SFXDescription description, string filename ) [, float x, float y, float z, float fadeInTime=-1 ] ) 
            ///    Create a new play-once source for the given profile or description+filename and start playback of the source.
            ///    @hide )
            /// 
            /// </summary>
            public int _sfxPlayOnce(string a1, string a2 = "", string a3 = "", string a4 = "", string a5 = "")
                {
                return m_ts.fn__sfxPlayOnce(a1, a2, a3, a4, a5);
                }

            /// <summary>
            /// (spawnObject, S32, 3, 6, spawnObject(class [, dataBlock, name, properties, script])
            /// 				@hide)
            /// 
            /// </summary>
            public int _spawnObject(string a1, string a2, string a3 = "", string a4 = "", string a5 = "")
                {
                return m_ts.fn__spawnObject(a1, a2, a3, a4, a5);
                }

            /// <summary>
            /// ( strToPlayerName, const char*, 2, 2, strToPlayerName( string ) )
            /// 
            /// </summary>
            public string _strToPlayerName(string a1)
                {
                return m_ts.fn__strToPlayerName(a1);
                }

            /// <summary>
            /// (TestFunction2Args, const char *, 3, 3, testFunction(arg1, arg2))
            /// 
            /// </summary>
            public string _TestFunction2Args(string a1, string a2)
                {
                return m_ts.fn__TestFunction2Args(a1, a2);
                }

            /// <summary>
            /// (testJavaScriptBridge, const char *, 4, 4, testBridge(arg1, arg2, arg3))
            /// 
            /// </summary>
            public string _testJavaScriptBridge(string a1, string a2, string a3)
                {
                return m_ts.fn__testJavaScriptBridge(a1, a2, a3);
                }

            /// <summary>
            /// (tsUpdateImposterImages, void, 1, 2, tsUpdateImposterImages( bool forceupdate ))
            /// 
            /// </summary>
            public void _tsUpdateImposterImages(string a1 = "")
                {
                m_ts.fn__tsUpdateImposterImages(a1);
                }

            /// <summary>
            /// ( warn, void, 2, 0, ( string message... ) 
            ///    @brief Logs a warning message to the console.
            ///    Concatenates all given arguments to a single string and prints the string to the console as a warning 
            ///    message (in the in-game console, these will show up using a turquoise font by default). 
            ///    A newline is added automatically after the text.
            ///    @param message Any number of string arguments.
            ///    @ingroup Logging )
            /// 
            /// </summary>
            public void _warn(string a1, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fn__warn(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// @brief Activates an existing package.
            ///    The activation occurs by updating the namespace linkage of existing functions and methods. 
            ///    If the package is already activated the function does nothing.
            ///    @ingroup Packages)
            /// 
            /// </summary>
            public void activatePackage(string packageName)
                {
                m_ts.fn_activatePackage(packageName);
                }

            /// <summary>
            /// @brief Add a string to the bad word filter
            /// 
            ///    The bad word filter is a table containing words which will not be 
            ///    displayed in chat windows. Instead, a designated replacement string will be displayed.  
            ///    There are already a number of bad words automatically defined.
            /// 
            ///    @param badWord Exact text of the word to restrict.
            ///    @return True if word was successfully added, false if the word or a subset of it already exists in the table
            /// 
            ///    @see filterString()
            /// 
            ///    @tsexample
            ///       // In this game, \"Foobar\" is banned
            ///       %badWord = \"Foobar\";
            ///       // Returns true, word was successfully added
            ///       addBadWord(%badWord);
            ///       // Returns false, word has already been added
            ///       addBadWord(\"Foobar\");
            ///    @endtsexample
            /// 
            ///    @ingroup Game)
            /// 
            /// </summary>
            public bool addBadWord(string badWord)
                {
                return m_ts.fn_addBadWord(badWord);
                }

            /// <summary>
            /// Adds a global shader macro which will be merged with the script defined 
            ///    macros on every shader.  The macro will replace the value of an existing 
            ///    macro of the same name.  For the new macro to take effect all the shaders 
            ///    in the system need to be reloaded.
            ///    @see resetLightManager, removeGlobalShaderMacro
            ///    @ingroup Rendering )
            /// 
            /// </summary>
            public void addGlobalShaderMacro(string name, string value)
                {
                m_ts.fn_addGlobalShaderMacro(name, value);
                }

            /// <summary>
            /// @brief Prints the scripting call stack to the console log.
            ///    Used to trace functions called from within functions. Can help discover what functions were called 
            ///    (and not yet exited) before the current point in scripts.
            ///    @ingroup Debugging)
            /// 
            /// </summary>
            public void backtrace()
                {
                m_ts.fn_backtrace();
                }

            /// <summary>
            /// @brief Calculates how much an explosion effects a specific object.
            ///    Use this to determine how much damage to apply to objects based on their 
            ///    distance from the explosion's center point, and whether the explosion is 
            ///    blocked by other objects.
            ///    @param pos Center position of the explosion.
            ///    @param id Id of the object of which to check coverage.
            ///    @param covMask Mask of object types that may block the explosion.
            ///    @return Coverage value from 0 (not affected by the explosion) to 1 (fully affected)
            ///    @tsexample
            ///    // Get the position of the explosion.
            ///    %position = %explosion.getPosition();
            ///    // Set a list of TypeMasks (defined in gameFunctioncs.cpp), seperated by the | character.
            ///    %TypeMasks = $TypeMasks::StaticObjectType | $TypeMasks::ItemObjectType
            ///    // Acquire the damage value from 0.0f - 1.0f.
            ///    %coverage = calcExplosionCoverage( %position, %sceneObject, %TypeMasks );
            ///    // Apply damage to object 
            ///    %sceneObject.applyDamage( %coverage * 20 );
            ///    @endtsexample
            ///    @ingroup FX)
            /// 
            /// </summary>
            public float calcExplosionCoverage(Point3F pos, int id, uint covMask)
                {
                return m_ts.fn_calcExplosionCoverage(pos.AsString(), id, covMask);
                }

            /// <summary>
            /// Release the unused pooled textures in texture manager freeing up video memory.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public void cleanupTexturePool()
                {
                m_ts.fn_cleanupTexturePool();
                }

            /// <summary>
            /// Clears the flagged state on all allocated GFX resources. 
            ///    See flagCurrentGFXResources for usage details.
            ///    @ingroup GFX
            ///    @see flagCurrentGFXResources, listGFXResources, describeGFXResources )
            /// 
            /// </summary>
            public void clearGFXResourceFlags()
                {
                m_ts.fn_clearGFXResourceFlags();
                }

            /// <summary>
            /// Replace all escape sequences in @a text with their respective character codes.
            ///    This function replaces all escape sequences (\\\, \\\\t, etc) in the given string 
            ///    with the respective characters they represent.
            ///    The primary use of this function is for converting strings from their literal form into 
            ///    their compiled/translated form, as is normally done by the TorqueScript compiler.
            ///    @param text A string.
            ///    @return A duplicate of @a text with all escape sequences replaced by their respective character codes.
            ///    @tsexample
            ///       // Print:
            ///       //
            ///       //    str
            ///       //    ing
            ///       //
            ///       // to the console.  Note how the backslash in the string must be escaped here
            ///       // in order to prevent the TorqueScript compiler from collapsing the escape
            ///       // sequence in the resulting string.
            ///       echo( collapseEscape( \"str\ing\" ) );
            ///    @endtsexample
            ///    @see expandEscape
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string collapseEscape(string text)
                {
                return m_ts.fn_collapseEscape(text);
                }

            /// <summary>
            /// Compile a file to bytecode.
            ///    This function will read the TorqueScript code in the specified file, compile it to internal bytecode, and, 
            ///    if DSO generation is enabled or @a overrideNoDDSO is true, will store the compiled code in a .dso file 
            ///    in the current DSO path mirrorring the path of @a fileName.
            ///    @param fileName Path to the file to compile to bytecode.
            ///    @param overrideNoDSO If true, force generation of DSOs even if the engine is compiled to not 
            ///       generate write compiled code to DSO files.
            ///    @return True if the file was successfully compiled, false if not.
            ///    @note The definitions contained in the given file will not be made available and no code will actually 
            ///       be executed.  Use exec() for that.
            ///    @see getDSOPath
            ///    @see exec
            ///    @ingroup Scripting )
            /// 
            /// </summary>
            public bool compile(string fileName, bool overrideNoDSO)
                {
                return m_ts.fn_compile(fileName, overrideNoDSO);
                }

            /// <summary>
            /// @brief See if any objects of the given types are present in box of given extent.
            ///    @note Extent parameter is last since only one radius is often needed.  If 
            ///    one radius is provided, the yRadius and zRadius are assumed to be the same.  Unfortunately, 
            ///    if you need to use the client container, you'll need to set all of the radius parameters.  
            ///    Fortunately, this function is mostly used on the server.
            ///    @param  mask   Indicates the type of objects we are checking against.
            ///    @param  center Center of box.
            ///    @param  xRadius Search radius in the x-axis. See note above.
            ///    @param  yRadius Search radius in the y-axis. See note above.
            ///    @param  zRadius Search radius in the z-axis. See note above.
            ///    @param useClientContainer Optionally indicates the search should be within the 
            ///    client container.
            ///    @return true if the box is empty, false if any object is found.
            ///    @ingroup Game)
            /// 
            /// </summary>
            public bool containerBoxEmpty(uint mask, Point3F center, float xRadius, float yRadius, float zRadius, bool useClientContainer)
                {
                return m_ts.fn_containerBoxEmpty(mask, center.AsString(), xRadius, yRadius, zRadius, useClientContainer);
                }

            /// <summary>
            /// @brief Cast a ray from start to end, checking for collision against items matching mask.
            /// 
            ///    If pExempt is specified, then it is temporarily excluded from collision checks (For 
            ///    instance, you might want to exclude the player if said player was firing a weapon.)
            /// 
            ///    @param start An XYZ vector containing the tail position of the ray.
            ///    @param end An XYZ vector containing the head position of the ray
            ///    @param mask A bitmask corresponding to the type of objects to check for
            ///    @param pExempt An optional ID for a single object that ignored for this raycast
            ///    @param useClientContainer Optionally indicates the search should be within the 
            ///    client container.
            /// 
            ///    @returns A string containing either null, if nothing was struck, or these fields:
            ///    ul>li>The ID of the object that was struck./li>
            ///    li>The x, y, z position that it was struck./li>
            ///    li>The x, y, z of the normal of the face that was struck./li>
            ///    li>The distance between the start point and the position we hit./li>/ul> 
            /// 
            ///    @ingroup Game)
            /// 
            /// </summary>
            public string containerRayCast(Point3F start, Point3F end, uint mask, string pExempt, bool useClientContainer)
                {
                return m_ts.fn_containerRayCast(start.AsString(), end.AsString(), mask, pExempt, useClientContainer);
                }

            /// <summary>
            /// @brief Get distance of the center of the current item from the center of the 
            ///    current initContainerRadiusSearch.
            /// 
            ///    @param useClientContainer Optionally indicates the search should be within the 
            ///    client container.
            ///    @return distance from the center of the current object to the center of 
            ///    the search
            /// 
            ///    @see containerSearchNext
            ///    @ingroup Game)
            /// 
            /// </summary>
            public float containerSearchCurrDist(bool useClientContainer)
                {
                return m_ts.fn_containerSearchCurrDist(useClientContainer);
                }

            /// <summary>
            /// @brief Get the distance of the closest point of the current item from the center 
            ///    of the current initContainerRadiusSearch.
            /// 
            ///    @param useClientContainer Optionally indicates the search should be within the 
            ///    client container.
            ///    @return distance from the closest point of the current object to the 
            ///    center of the search
            /// 
            ///    @see containerSearchNext 
            ///    @ingroup Game)
            /// 
            /// </summary>
            public float containerSearchCurrRadiusDist(bool useClientContainer)
                {
                return m_ts.fn_containerSearchCurrRadiusDist(useClientContainer);
                }

            /// <summary>
            /// @brief Get next item from a search started with initContainerRadiusSearch() or 
            ///    initContainerTypeSearch().
            /// 
            ///    @param useClientContainer Optionally indicates the search should be within the 
            ///    client container.
            ///    @return the next object found in the search, or null if no more
            /// 
            ///    @tsexample
            ///    // print the names of all nearby ShapeBase derived objects
            ///    %position = %obj.getPosition;
            ///    %radius = 20;
            ///    %mask = $TypeMasks::ShapeBaseObjectType;
            ///    initContainerRadiusSearch( %position, %radius, %mask );
            ///    while ( (%targetObject = containerSearchNext()) != 0 )
            ///    {
            ///       echo( \"Found: \" @ %targetObject.getName() );
            ///    }
            ///    @endtsexample
            /// 
            ///    @see initContainerRadiusSearch()
            ///    @see initContainerTypeSearch()
            ///    @ingroup Game)
            /// 
            /// </summary>
            public string containerSearchNext(bool useClientContainer)
                {
                return m_ts.fn_containerSearchNext(useClientContainer);
                }

            /// <summary>
            /// @brief Checks to see if text is a bad word
            /// 
            ///    The text is considered to be a bad word if it has been added to the bad word filter.
            /// 
            ///    @param text Text to scan for bad words
            ///    @return True if the text has bad word(s), false if it is clean
            /// 
            ///    @see addBadWord()
            ///    @see filterString()
            /// 
            ///    @tsexample
            ///       // In this game, \"Foobar\" is banned
            ///       %badWord = \"Foobar\";
            ///       // Add a banned word to the bad word filter
            ///       addBadWord(%badWord);
            ///       // Create the base string, can come from anywhere like user chat
            ///       %userText = \"Foobar\";
            ///       // Create a string of random letters
            ///       %replacementChars = \"knqwrtlzs\";
            ///       // If the text contains a bad word, filter it before printing
            ///       // Otherwise print the original text
            ///       if(containsBadWords(%userText))
            ///       {
            ///       	// Filter the string
            ///       	%filteredText = filterString(%userText, %replacementChars);
            ///       	// Print filtered text
            ///       	echo(%filteredText);
            ///       }
            ///       else
            ///       	echo(%userText);
            ///    @endtsexample
            /// 
            ///    @ingroup Game)
            /// 
            /// </summary>
            public bool containsBadWords(string text)
                {
                return m_ts.fn_containsBadWords(text);
                }

            /// <summary>
            /// Count the number of bits that are set in the given 32 bit integer.
            ///    @param v An integer value.
            ///    @return The number of bits that are set in @a v.
            ///    @ingroup Utilities )
            /// 
            /// </summary>
            public int countBits(int v)
                {
                return m_ts.fn_countBits(v);
                }

            /// <summary>
            /// @brief Create the given directory or the path leading to the given filename.
            ///    If @a path ends in a trailing slash, then all components in the given path will be created as directories (if not already in place).  If @a path, 
            ///    does @b not end in a trailing slash, then the last component of the path is taken to be a file name and only the directory components 
            ///    of the path will be created.
            ///    @param path The path to create.
            ///    @note Only present in a Tools build of Torque.
            ///    @ingroup FileSystem )
            /// 
            /// </summary>
            public bool createPath(string path)
                {
                return m_ts.fn_createPath(path);
                }

            /// <summary>
            /// @brief Deactivates a previously activated package.
            ///    The package is deactivated by removing its namespace linkages to any function or method. 
            ///    If there are any packages above this one in the stack they are deactivated as well. 
            ///    If the package is not on the stack this function does nothing.
            ///    @ingroup Packages)
            /// 
            /// </summary>
            public void deactivatePackage(string packageName)
                {
                m_ts.fn_deactivatePackage(packageName);
                }

            /// <summary>
            /// Drops the engine into the native C++ debugger.
            ///    This function triggers a debug break and drops the process into the IDE's debugger.  If the process is not 
            ///    running with a debugger attached it will generate a runtime error on most platforms.
            ///    @note This function is not available in shipping builds.
            ///    @ingroup Debugging )
            /// 
            /// </summary>
            public void debug()
                {
                m_ts.fn_debug();
                }

            /// <summary>
            /// @brief Logs the value of the given variable to the console.
            ///    Prints a string of the form \"variableName> = variable value>\" to the console.
            ///    @param variableName Name of the local or global variable to print.
            ///    @tsexample
            ///       %var = 1;
            ///       debugv( \"%var\" ); // Prints \"%var = 1\"
            ///    @endtsexample
            ///    @ingroup Debugging )
            /// 
            /// </summary>
            public void debugv(string variableName)
                {
                m_ts.fn_debugv(variableName);
                }

            /// <summary>
            /// Delete all the datablocks we've downloaded.
            ///    This is usually done in preparation of downloading a new set of datablocks, 
            ///    such as occurs on a mission change, but it's also good post-mission cleanup. )
            /// 
            /// </summary>
            public void deleteDataBlocks()
                {
                m_ts.fn_deleteDataBlocks();
                }

            /// <summary>
            /// Undefine all global variables matching the given name @a pattern.
            ///    @param pattern A global variable name pattern.  Must begin with '$'.
            ///    @tsexample
            ///       // Define a global variable in the \"My\" namespace.
            ///       $My::Variable = \"value\";
            ///       // Undefine all variable in the \"My\" namespace.
            ///       deleteVariables( \"$My::*\" );
            ///    @endtsexample
            ///    @see strIsMatchExpr
            ///    @ingroup Scripting )
            /// 
            /// </summary>
            public void deleteVariables(string pattern)
                {
                m_ts.fn_deleteVariables(pattern);
                }

            /// <summary>
            /// @brief Dumps a description of GFX resources to a file or the console.
            ///    @param resourceTypes A space seperated list of resource types or an empty string for all resources.
            ///    @param filePath A file to dump the list to or an empty string to write to the console.
            ///    @param unflaggedOnly If true only unflagged resources are dumped. See flagCurrentGFXResources.
            ///    @note The resource types can be one or more of the following:
            ///      - texture
            ///      - texture target
            ///      - window target
            ///      - vertex buffers
            ///      - primitive buffers
            ///      - fences
            ///      - cubemaps
            ///      - shaders
            ///      - stateblocks
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public void describeGFXResources(string resourceTypes, string filePath, bool unflaggedOnly)
                {
                m_ts.fn_describeGFXResources(resourceTypes, filePath, unflaggedOnly);
                }

            /// <summary>
            /// Dumps a description of all state blocks.     
            ///    @param filePath A file to dump the state blocks to or an empty string to write to the console.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public void describeGFXStateBlocks(string filePath)
                {
                m_ts.fn_describeGFXStateBlocks(filePath);
                }

            /// <summary>
            /// @brief Returns the string from a tag string.
            /// 
            ///    Should only be used within the context of a function that receives a tagged 
            ///    string, and is not meant to be used outside of this context.  Use getTaggedString() 
            ///    to convert a tagged string ID back into a regular string at any time.
            /// 
            ///    @tsexample
            ///       // From scripts/client/message.cs
            ///       function clientCmdChatMessage(%sender, %voice, %pitch, %msgString, %a1, %a2, %a3, %a4, %a5, %a6, %a7, %a8, %a9, %a10)
            ///       {
            ///          onChatMessage(detag(%msgString), %voice, %pitch);
            ///       }
            /// 	@endtsexample
            /// 
            ///    @see \\ref syntaxDataTypes under Tagged %Strings
            ///    @see getTag()
            ///    @see getTaggedString()
            /// 
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public string detag(string str)
                {
                return m_ts.fn_detag(str);
                }

            /// <summary>
            /// Display a startup splash window suitable for showing while the engine still starts up.
            ///    @note This is currently only implemented on Windows.
            ///    @return True if the splash window could be successfully initialized.
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public bool displaySplashWindow()
                {
                return m_ts.fn_displaySplashWindow();
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public string dnt_testcase_1(string chr)
                {
                return m_ts.fn_dnt_testcase_1(chr);
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public Point4F dnt_testcase_10(Point4F chr)
                {
                return new Point4F(m_ts.fn_dnt_testcase_10(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public RectF dnt_testcase_12(RectF chr)
                {
                return new RectF(m_ts.fn_dnt_testcase_12(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public RectI dnt_testcase_13(RectI chr)
                {
                return new RectI(m_ts.fn_dnt_testcase_13(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public RectSpacingI dnt_testcase_14(RectSpacingI chr)
                {
                return new RectSpacingI(m_ts.fn_dnt_testcase_14(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public TransformF dnt_testcase_15(TransformF chr)
                {
                return new TransformF(m_ts.fn_dnt_testcase_15(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public AngAxisF dnt_testcase_2(AngAxisF chr)
                {
                return new AngAxisF(m_ts.fn_dnt_testcase_2(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public Box3F dnt_testcase_3(Box3F chr)
                {
                return new Box3F(m_ts.fn_dnt_testcase_3(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public ColorF dnt_testcase_4(ColorF chr)
                {
                return new ColorF(m_ts.fn_dnt_testcase_4(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public ColorI dnt_testcase_5(ColorI chr)
                {
                return new ColorI(m_ts.fn_dnt_testcase_5(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public EaseF dnt_testcase_6(EaseF chr)
                {
                return new EaseF(m_ts.fn_dnt_testcase_6(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public Point2F dnt_testcase_7(Point2F chr)
                {
                return new Point2F(m_ts.fn_dnt_testcase_7(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public Point2I dnt_testcase_8(Point2I chr)
                {
                return new Point2I(m_ts.fn_dnt_testcase_8(chr.AsString()));
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///     )
            /// 
            /// </summary>
            public Point3F dnt_testcase_9(Point3F chr)
                {
                return new Point3F(m_ts.fn_dnt_testcase_9(chr.AsString()));
                }

            /// <summary>
            /// @brief Dumps all declared console classes to the console.
            ///             @param dumpScript Optional parameter specifying whether or not classes defined in script should be dumped.
            ///             @param dumpEngine Optional parameter specifying whether or not classes defined in the engine should be dumped.
            /// 			@ingroup Logging)
            /// 
            /// </summary>
            public void dumpConsoleClasses(bool dumpScript, bool dumpEngine)
                {
                m_ts.fn_dumpConsoleClasses(dumpScript, dumpEngine);
                }

            /// <summary>
            /// @brief Dumps all declared console functions to the console.
            ///             @param dumpScript Optional parameter specifying whether or not functions defined in script should be dumped.
            ///             @param dumpEngine Optional parameter specitying whether or not functions defined in the engine should be dumped.
            /// 			@ingroup Logging)
            /// 
            /// </summary>
            public void dumpConsoleFunctions(bool dumpScript, bool dumpEngine)
                {
                m_ts.fn_dumpConsoleFunctions(dumpScript, dumpEngine);
                }

            /// <summary>
            /// Dumps to the console a full description of all cached fonts, along with 
            ///    info on the codepoints each contains.
            ///    @ingroup Font )
            /// 
            /// </summary>
            public void dumpFontCacheStatus()
                {
                m_ts.fn_dumpFontCacheStatus();
                }

            /// <summary>
            /// @brief Dumps network statistics for each class to the console.
            /// 
            ///    The returned i>avg/i>, i>min/i> and i>max/i> values are in bits sent per update.  
            ///    The i>num/i> value is the total number of events collected.
            /// 
            ///    @note This method only works when TORQUE_NET_STATS is defined in torqueConfig.h.
            ///    @ingroup Networking )
            /// 
            /// </summary>
            public void dumpNetStats()
                {
                m_ts.fn_dumpNetStats();
                }

            /// <summary>
            /// Creates a 64x64 normal map texture filled with noise. The texture is saved 
            ///    to randNormTex.png in the location of the game executable.
            ///    @ingroup GFX)
            /// 
            /// </summary>
            public void dumpRandomNormalMap()
                {
                m_ts.fn_dumpRandomNormalMap();
                }

            /// <summary>
            /// Copy the specified old font to a new name. The new copy will not have a 
            ///    platform font backing it, and so will never have characters added to it. 
            ///    But this is useful for making copies of fonts to add postprocessing effects 
            ///    to via exportCachedFont.
            ///    @param oldFontName The name of the font face to copy.
            ///    @param oldFontSize The size of the font to copy.
            ///    @param newFontName The name of the new font face.
            ///    @ingroup Font )
            /// 
            /// </summary>
            public void duplicateCachedFont(string oldFontName, int oldFontSize, string newFontName)
                {
                m_ts.fn_duplicateCachedFont(oldFontName, oldFontSize, newFontName);
                }

            /// <summary>
            /// @brief Test whether the given string ends with the given suffix.
            ///    @param str The string to test.
            ///    @param suffix The potential suffix of @a str.
            ///    @param caseSensitive If true, the comparison will be case-sensitive; if false, differences in casing will 
            ///       not be taken into account.
            ///    @return True if the last characters in @a str match the complete contents of @a suffix; false otherwise.
            ///    @tsexample
            ///    startsWith( \"TEST123\", \"123\" ) // Returns true.
            ///    @endtsexample
            ///    @see startsWith
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public bool endsWith(string str, string suffix, bool caseSensitive)
                {
                return m_ts.fn_endsWith(str, suffix, caseSensitive);
                }

            /// <summary>
            /// @brief Used to exclude/prevent all other instances using the same identifier specified
            /// 
            /// 					 @note Not used on OSX, Xbox, or in Win debug builds
            /// 
            /// 					 @param appIdentifier Name of the app set up for exclusive use.
            /// 
            /// 					 @return False if another app is running that specified the same appIdentifier
            /// 
            /// 					 @ingroup Platform
            /// 					 @ingroup GuiCore)
            /// 
            /// </summary>
            public bool excludeOtherInstance(string appIdentifer)
                {
                return m_ts.fn_excludeOtherInstance(appIdentifer);
                }

            /// <summary>
            /// Execute the given script file.
            ///    @param fileName Path to the file to execute
            ///    @param noCalls Deprecated
            ///    @param journalScript Deprecated
            ///    @return True if the script was successfully executed, false if not.
            ///    @tsexample
            ///       // Execute the init.cs script file found in the same directory as the current script file.
            ///       exec( \"./init.cs\" );
            ///    @endtsexample
            ///    @see compile
            ///    @see eval
            ///    @ingroup Scripting )
            /// 
            /// </summary>
            public bool exec(string fileName, bool noCalls, bool journalScript)
                {
                return m_ts.fn_exec(fileName, noCalls, journalScript);
                }

            /// <summary>
            /// @brief Replace all characters in @a text that need to be escaped for the string to be a valid string literal with their 
            ///    respective escape sequences.
            ///    All characters in @a text that cannot appear in a string literal will be replaced by an escape sequence (\\\, \\\\t, etc).
            ///    The primary use of this function is for converting strings suitable for being passed as string literals 
            ///    to the TorqueScript compiler.
            ///    @param text A string
            ///    @return A duplicate of the text parameter with all unescaped characters that cannot appear in string literals replaced by their respective 
            ///    escape sequences.
            ///    @tsxample
            ///    expandEscape( \"str\" NL \"ing\" ) // Returns \"str\ing\".
            ///    @endtsxample
            ///    @see collapseEscape
            ///    @ingroup Strings)
            /// 
            /// </summary>
            public string expandEscape(string text)
                {
                return m_ts.fn_expandEscape(text);
                }

            /// <summary>
            /// , false ),
            ///    Write out the definitions of all global variables matching the given name @a pattern.
            ///    If @a fileName is not \"\", the variable definitions are written to the specified file.  Otherwise the 
            ///    definitions will be printed to the console.
            ///    The output are valid TorqueScript statements that can be executed to restore the global variable 
            ///    values.
            ///    @param pattern A global variable name pattern.  Must begin with '$'.
            ///    @param filename %Path of the file to which to write the definitions or \"\" to write the definitions 
            ///       to the console.
            ///    @param append If true and @a fileName is not \"\", then the definitions are appended to the specified file. 
            ///       Otherwise existing contents of the file (if any) will be overwritten.
            ///    @tsexample
            ///       // Write out all preference variables to a prefs.cs file.
            ///       export( \"$prefs::*\", \"prefs.cs\" );
            ///    @endtsexample
            ///    @ingroup Scripting )
            /// 
            /// </summary>
            public void export(string pattern, string filename, bool append)
                {
                m_ts.fn_export(pattern, filename, append);
                }

            /// <summary>
            /// Export specified font to the specified filename as a PNG. The 
            ///    image can then be processed in Photoshop or another tool and 
            ///    reimported using importCachedFont. Characters in the font are 
            ///    exported as one long strip.
            ///    @param faceName The name of the font face.
            ///    @param fontSize The size of the font in pixels.
            ///    @param fileName The file name and path for the output PNG.
            ///    @param padding The padding between characters.   
            ///    @param kerning The kerning between characters.   
            ///    @ingroup Font )
            /// 
            /// </summary>
            public void exportCachedFont(string faceName, int fontSize, string fileName, int padding, int kerning)
                {
                m_ts.fn_exportCachedFont(faceName, fontSize, fileName, padding, kerning);
                }

            /// <summary>
            /// @brief Get the base of a file name (removes extension)
            /// 
            ///    @param fileName Name and path of file to check
            ///    @return String containing the file name, minus extension
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public string fileBase(string fileName)
                {
                return m_ts.fn_fileBase(fileName);
                }

            /// <summary>
            /// @brief Returns a platform specific formatted string with the creation time for the file.
            /// 
            ///    @param fileName Name and path of file to check
            ///    @return Formatted string (OS specific) containing created time, \"9/3/2010 12:33:47 PM\" for example
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public string fileCreatedTime(string fileName)
                {
                return m_ts.fn_fileCreatedTime(fileName);
                }

            /// <summary>
            /// @brief Delete a file from the hard drive
            /// 
            /// 	@param path Name and path of the file to delete
            /// 	@note THERE IS NO RECOVERY FROM THIS. Deleted file is gone for good.
            /// 	@return True if file was successfully deleted
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public bool fileDelete(string path)
                {
                return m_ts.fn_fileDelete(path);
                }

            /// <summary>
            /// @brief Get the extension of a file
            /// 
            /// 	@param fileName Name and path of file
            /// 	@return String containing the extension, such as \".exe\" or \".cs\"
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string fileExt(string fileName)
                {
                return m_ts.fn_fileExt(fileName);
                }

            /// <summary>
            /// @brief Returns a platform specific formatted string with the last modified time for the file.
            /// 
            /// 	@param fileName Name and path of file to check
            /// 	@return Formatted string (OS specific) containing modified time, \"9/3/2010 12:33:47 PM\" for example
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string fileModifiedTime(string fileName)
                {
                return m_ts.fn_fileModifiedTime(fileName);
                }

            /// <summary>
            /// @brief Get the file name of a file (removes extension and path)
            /// 
            /// 	@param fileName Name and path of file to check
            /// 	@return String containing the file name, minus extension and path
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string fileName(string fileName)
                {
                return m_ts.fn_fileName(fileName);
                }

            /// <summary>
            /// @brief Get the path of a file (removes name and extension)
            /// 
            /// 	@param fileName Name and path of file to check
            /// 	@return String containing the path, minus name and extension
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string filePath(string fileName)
                {
                return m_ts.fn_filePath(fileName);
                }

            /// <summary>
            /// @brief Determines the size of a file on disk
            /// 
            /// 	@param fileName Name and path of the file to check
            /// 	@return Returns filesize in KB, or -1 if no file
            /// 
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public int fileSize(string fileName)
                {
                return m_ts.fn_fileSize(fileName);
                }

            /// <summary>
            /// @brief Replaces the characters in a string with designated text
            /// 
            ///    Uses the bad word filter to determine which characters within the string will be replaced.
            /// 
            ///    @param baseString  The original string to filter.
            ///    @param replacementChars A string containing letters you wish to swap in the baseString.
            ///    @return The new scrambled string 
            /// 
            ///    @see addBadWord()
            ///    @see containsBadWords()
            /// 
            ///    @tsexample
            ///       // Create the base string, can come from anywhere
            ///       %baseString = \"Foobar\";
            ///       // Create a string of random letters
            ///       %replacementChars = \"knqwrtlzs\";
            ///       // Filter the string
            ///       %newString = filterString(%baseString, %replacementChars);
            ///       // Print the new string to console
            ///       echo(%newString);
            ///    @endtsexample
            /// 
            ///    @ingroup Game)
            /// 
            /// </summary>
            public string filterString(string baseString, string replacementChars)
                {
                return m_ts.fn_filterString(baseString, replacementChars);
                }

            /// <summary>
            /// @brief Returns the first file in the directory system matching the given pattern.
            /// 
            ///    Use the corresponding findNextFile() to step through 
            ///    the results.  If you're only interested in the number of files returned by the 
            ///    pattern match, use getFileCount().
            /// 
            ///    This function differs from findFirstFileMultiExpr() in that it supports a single search 
            ///    pattern being passed in.
            /// 
            ///    @note You cannot run multiple simultaneous file system searches with these functions.  Each 
            ///    call to findFirstFile() and findFirstFileMultiExpr() initiates a new search and renders 
            ///    a previous search invalid.
            /// 
            ///    @param pattern The path and file name pattern to match against.
            ///    @param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern.
            ///    @return The path of the first file matched by the search or an empty string if no matching file could be found.
            /// 
            ///    @tsexample
            ///       // Execute all .cs files in a subdirectory and its subdirectories.
            ///       for( %file = findFirstFile( \"subdirectory/*.cs\" ); %file !$= \"\"; %file = findNextFile() )
            ///          exec( %file );
            ///    @endtsexample
            /// 
            ///    @see findNextFile()
            ///    @see getFileCount()
            ///    @see findFirstFileMultiExpr()
            ///    @ingroup FileSearches )
            /// 
            /// </summary>
            public string findFirstFile(string pattern, bool recurse)
                {
                return m_ts.fn_findFirstFile(pattern, recurse);
                }

            /// <summary>
            /// @brief Returns the first file in the directory system matching the given patterns.
            /// 
            ///    Use the corresponding findNextFileMultiExpr() to step through 
            ///    the results.  If you're only interested in the number of files returned by the 
            ///    pattern match, use getFileCountMultiExpr().
            /// 
            ///    This function differs from findFirstFile() in that it supports multiple search patterns 
            ///    to be passed in.
            /// 
            ///    @note You cannot run multiple simultaneous file system searches with these functions.  Each 
            ///    call to findFirstFile() and findFirstFileMultiExpr() initiates a new search and renders 
            ///    a previous search invalid.
            /// 
            /// 	@param pattern The path and file name pattern to match against, such as *.cs.  Separate 
            ///    multiple patterns with TABs.  For example: \"*.cs\" TAB \"*.dso\"
            /// 	@param recurse If true, the search will exhaustively recurse into subdirectories 
            /// 	of the given path and match the given filename patterns.
            ///    @return String of the first matching file path, or an empty string if no matching 
            ///    files were found.
            /// 
            ///    @tsexample
            ///       // Find all DTS or Collada models
            ///       %filePatterns = \"*.dts\" TAB \"*.dae\";
            ///       %fullPath = findFirstFileMultiExpr( %filePatterns );
            ///       while ( %fullPath !$= \"\" )
            ///       {
            ///          echo( %fullPath );
            ///          %fullPath = findNextFileMultiExpr( %filePatterns );
            ///       }
            ///    @endtsexample
            /// 
            ///    @see findNextFileMultiExpr()
            ///    @see getFileCountMultiExpr()
            ///    @see findFirstFile()
            /// 	@ingroup FileSearches)
            /// 
            /// </summary>
            public string findFirstFileMultiExpr(string pattern, bool recurse)
                {
                return m_ts.fn_findFirstFileMultiExpr(pattern, recurse);
                }

            /// <summary>
            ///  ),
            ///    @brief Returns the next file matching a search begun in findFirstFile().
            /// 
            ///    @param pattern The path and file name pattern to match against.  This is optional 
            ///    and may be left out as it is not used by the code.  It is here for legacy reasons.
            ///    @return The path of the next filename matched by the search or an empty string if no more files match.
            /// 
            ///    @tsexample
            ///       // Execute all .cs files in a subdirectory and its subdirectories.
            ///       for( %file = findFirstFile( \"subdirectory/*.cs\" ); %file !$= \"\"; %file = findNextFile() )
            ///          exec( %file );
            ///    @endtsexample
            /// 
            ///    @see findFirstFile()
            ///    @ingroup FileSearches )
            /// 
            /// </summary>
            public string findNextFile(string pattern)
                {
                return m_ts.fn_findNextFile(pattern);
                }

            /// <summary>
            /// ),
            ///    @brief Returns the next file matching a search begun in findFirstFileMultiExpr().
            /// 
            /// 	@param pattern The path and file name pattern to match against.  This is optional 
            ///    and may be left out as it is not used by the code.  It is here for legacy reasons.
            ///    @return String of the next matching file path, or an empty string if no matching 
            ///    files were found.
            /// 
            ///    @tsexample
            ///       // Find all DTS or Collada models
            ///       %filePatterns = \"*.dts\" TAB \"*.dae\";
            ///       %fullPath = findFirstFileMultiExpr( %filePatterns );
            ///       while ( %fullPath !$= \"\" )
            ///       {
            ///          echo( %fullPath );
            ///          %fullPath = findNextFileMultiExpr( %filePatterns );
            ///       }
            ///    @endtsexample
            /// 
            ///    @see findFirstFileMultiExpr()
            /// 	@ingroup FileSearches)
            /// 
            /// </summary>
            public string findNextFileMultiExpr(string pattern)
                {
                return m_ts.fn_findNextFileMultiExpr(pattern);
                }

            /// <summary>
            /// Return the first word in @a text.
            ///    @param text A list of words separated by newlines, spaces, and/or tabs.
            ///    @return The word at index 0 in @a text or \"\" if @a text is empty.
            ///    @note This is equal to 
            ///    @tsexample_nopar
            ///       getWord( text, 0 )
            ///    @endtsexample
            ///    @see getWord
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string firstWord(string text)
                {
                return m_ts.fn_firstWord(text);
                }

            /// <summary>
            /// @brief Flags all currently allocated GFX resources.
            ///    Used for resource allocation and leak tracking by flagging 
            ///    current resources then dumping a list of unflagged resources 
            ///    at some later point in execution.
            ///    @ingroup GFX
            ///    @see listGFXResources, clearGFXResourceFlags, describeGFXResources )
            /// 
            /// </summary>
            public void flagCurrentGFXResources()
                {
                m_ts.fn_flagCurrentGFXResources();
                }

            /// <summary>
            /// Releases all textures and resurrects the texture manager.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public void flushTextureCache()
                {
                m_ts.fn_flushTextureCache();
                }

            /// <summary>
            /// Returns the count of active DDSs files in memory.
            ///    @ingroup Rendering )
            /// 
            /// </summary>
            public int getActiveDDSFiles()
                {
                return m_ts.fn_getActiveDDSFiles();
                }

            /// <summary>
            /// Returns the active light manager name.
            ///    @ingroup Lighting )
            /// 
            /// </summary>
            public string getActiveLightManager()
                {
                return m_ts.fn_getActiveLightManager();
                }

            /// <summary>
            /// Returns the best texture format for storage of HDR data for the active device.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public GFXFormat getBestHDRFormat()
                {
                return (GFXFormat) (m_ts.fn_getBestHDRFormat());
                }

            /// <summary>
            /// Returns image info in the following format: width TAB height TAB bytesPerPixel. 
            ///    It will return an empty string if the file is not found.
            ///    @ingroup Rendering )
            /// 
            /// </summary>
            public string getBitmapInfo(string filename)
                {
                return m_ts.fn_getBitmapInfo(filename);
                }

            /// <summary>
            /// Get the center point of an axis-aligned box.
            ///    @param b A Box3F, in string format using \"minExtentX minExtentY minExtentZ maxExtentX maxExtentY maxExtentZ\"
            ///    @return Center of the box.
            ///    @ingroup Math)
            /// 
            /// </summary>
            public Point3F getBoxCenter(Box3F box)
                {
                return new Point3F(m_ts.fn_getBoxCenter(box.AsString()));
                }

            /// <summary>
            /// @brief Returns the category of the given class.
            /// 				@param className The name of the class.
            /// 				@ingroup Console)
            /// 
            /// </summary>
            public string getCategoryOfClass(string className)
                {
                return m_ts.fn_getCategoryOfClass(className);
                }

            /// <summary>
            /// @brief Returns the current %ActionMap.
            ///    @see ActionMap
            /// 	@ingroup Input)
            /// 
            /// </summary>
            public string getCurrentActionMap()
                {
                return m_ts.fn_getCurrentActionMap();
                }

            /// <summary>
            /// @brief Return the current working directory.
            ///    @return The absolute path of the current working directory.
            ///    @note Only present in a Tools build of Torque.
            ///    @see getWorkingDirectory()
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public string getCurrentDirectory()
                {
                return m_ts.fn_getCurrentDirectory();
                }

            /// <summary>
            /// @brief Returns the description string for the named class.
            /// 				@param className The name of the class.
            /// 				@return The class description in string format.
            /// 				@ingroup Console)
            /// 
            /// </summary>
            public string getDescriptionOfClass(string className)
                {
                return m_ts.fn_getDescriptionOfClass(className);
                }

            /// <summary>
            /// Returns the width, height, and bitdepth of the screen/desktop.@ingroup GFX )
            /// 
            /// </summary>
            public Point3F getDesktopResolution()
                {
                return new Point3F(m_ts.fn_getDesktopResolution());
                }

            /// <summary>
            /// @brief Gathers a list of directories starting at the given path.
            /// 
            /// 	@param path String containing the path of the directory
            /// 	@param depth Depth of search, as in how many subdirectories to parse through
            /// 	@return Tab delimited string containing list of directories found during search, \"\" if no files were found
            /// 
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string getDirectoryList(string path, int depth)
                {
                return m_ts.fn_getDirectoryList(path, depth);
                }

            /// <summary>
            /// Get the string describing the active GFX device.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public string getDisplayDeviceInformation()
                {
                return m_ts.fn_getDisplayDeviceInformation();
                }

            /// <summary>
            /// Returns a tab-seperated string of the detected devices across all adapters.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public string getDisplayDeviceList()
                {
                return m_ts.fn_getDisplayDeviceList();
                }

            /// <summary>
            /// @brief Gets the name of the game's executable
            /// 
            /// 	@return String containing this game's executable name
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string getExecutableName()
                {
                return m_ts.fn_getExecutableName();
                }

            /// <summary>
            /// Extract the field at the given @a index in the newline and/or tab separated list in @a text.
            ///    Fields in @a text must be separated by newlines and/or tabs.
            ///    @param text A list of fields separated by newlines and/or tabs.
            ///    @param index The zero-based index of the field to extract.
            ///    @return The field at the given index or \"\" if the index is out of range.
            ///    @tsexample
            ///       getField( \"a b\" TAB \"c d\" TAB \"e f\", 1 ) // Returns \"c d\"
            ///    @endtsexample
            ///    @see getFields
            ///    @see getFieldCount
            ///    @see getWord
            ///    @see getRecord
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string getField(string text, int index)
                {
                return m_ts.fn_getField(text, index);
                }

            /// <summary>
            /// Return the number of newline and/or tab separated fields in @a text.
            ///    @param text A list of fields separated by newlines and/or tabs.
            ///    @return The number of newline and/or tab sepearated elements in @a text.
            ///    @tsexample
            ///       getFieldCount( \"a b\" TAB \"c d\" TAB \"e f\" ) // Returns 3
            ///    @endtsexample
            ///    @see getWordCount
            ///    @see getRecordCount
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public int getFieldCount(string text)
                {
                return m_ts.fn_getFieldCount(text);
                }

            /// <summary>
            /// Extract a range of fields from the given @a startIndex onwards thru @a endIndex.
            ///    Fields in @a text must be separated by newlines and/or tabs.
            ///    @param text A list of fields separated by newlines and/or tabs.
            ///    @param startIndex The zero-based index of the first field to extract from @a text.
            ///    @param endIndex The zero-based index of the last field to extract from @a text.  If this is -1, all fields beginning 
            ///       with @a startIndex are extracted from @a text.
            ///    @return A string containing the specified range of fields from @a text or \"\" if @a startIndex 
            ///       is out of range or greater than @a endIndex.
            ///    @tsexample
            ///       getFields( \"a b\" TAB \"c d\" TAB \"e f\", 1 ) // Returns \"c d\" TAB \"e f\"
            ///    @endtsexample
            ///    @see getField
            ///    @see getFieldCount
            ///    @see getWords
            ///    @see getRecords
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string getFields(string text, int startIndex, int endIndex)
                {
                return m_ts.fn_getFields(text, startIndex, endIndex);
                }

            /// <summary>
            /// @brief Returns the number of files in the directory tree that match the given patterns
            /// 
            ///    This function differs from getFileCountMultiExpr() in that it supports a single search 
            ///    pattern being passed in.
            /// 
            ///    If you're interested in a list of files that match the given pattern and not just 
            ///    the number of files, use findFirstFile() and findNextFile().
            /// 
            ///    @param pattern The path and file name pattern to match against.
            ///    @param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern 
            ///       counting files in subdirectories.
            ///    @return Number of files located using the pattern
            /// 
            ///    @tsexample
            ///       // Count the number of .cs files in a subdirectory and its subdirectories.
            ///       getFileCount( \"subdirectory/*.cs\" );
            ///    @endtsexample
            /// 
            ///    @see findFirstFile()
            ///    @see findNextFile()
            ///    @see getFileCountMultiExpr()
            ///    @ingroup FileSearches )
            /// 
            /// </summary>
            public int getFileCount(string pattern, bool recurse)
                {
                return m_ts.fn_getFileCount(pattern, recurse);
                }

            /// <summary>
            /// @brief Returns the number of files in the directory tree that match the given patterns
            /// 
            ///    If you're interested in a list of files that match the given patterns and not just 
            ///    the number of files, use findFirstFileMultiExpr() and findNextFileMultiExpr().
            /// 
            /// 	@param pattern The path and file name pattern to match against, such as *.cs.  Separate 
            ///    multiple patterns with TABs.  For example: \"*.cs\" TAB \"*.dso\"
            /// 	@param recurse If true, the search will exhaustively recurse into subdirectories 
            /// 	of the given path and match the given filename pattern.
            /// 	@return Number of files located using the patterns
            /// 
            ///    @tsexample
            ///       // Count all DTS or Collada models
            ///       %filePatterns = \"*.dts\" TAB \"*.dae\";
            ///       echo( \"Nunmer of shape files:\" SPC getFileCountMultiExpr( %filePatterns ) );
            ///    @endtsexample
            /// 
            ///    @see findFirstFileMultiExpr()
            ///    @see findNextFileMultiExpr()
            /// 	@ingroup FileSearches)
            /// 
            /// </summary>
            public int getFileCountMultiExpr(string pattern, bool recurse)
                {
                return m_ts.fn_getFileCountMultiExpr(pattern, recurse);
                }

            /// <summary>
            /// @brief Provides the CRC checksum of the given file.
            ///    
            ///    @param fileName The path to the file.
            ///    @return The calculated CRC checksum of the file, or -1 if the file 
            ///    could not be found.
            ///    
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public int getFileCRC(string fileName)
                {
                return m_ts.fn_getFileCRC(fileName);
                }

            /// <summary>
            /// Returns a tab seperated list of light manager names.
            ///    @ingroup Lighting )
            /// 
            /// </summary>
            public string getLightManagerNames()
                {
                return m_ts.fn_getLightManagerNames();
                }

            /// <summary>
            /// @brief Get the absolute path to the directory that contains the main.cs script from which the engine was started.
            /// 
            ///    This directory will usually contain all the game assets and, in a user-side game installation, will usually be 
            ///    read-only.
            ///    @return The path to the main game assets.
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public string getMainDotCsDir()
                {
                return m_ts.fn_getMainDotCsDir();
                }

            /// <summary>
            /// Calculate the greater of two specified numbers.
            ///     @param v1 Input value.
            ///     @param v2 Input value.
            ///     @returns The greater value of the two specified values.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float getMax(float v1, float v2)
                {
                return m_ts.fn_getMax(v1, v2);
                }

            /// <summary>
            /// Calculate the lesser of two specified numbers.
            ///     @param v1 Input value.
            ///     @param v2 Input value.
            ///     @returns The lesser value of the two specified values.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float getMin(float v1, float v2)
                {
                return m_ts.fn_getMin(v1, v2);
                }

            /// <summary>
            /// Get the MissionArea object, if any.
            /// 					 @ingroup enviroMisc)
            /// 
            /// </summary>
            public string getMissionAreaServerObject()
                {
                return m_ts.fn_getMissionAreaServerObject();
                }

            /// <summary>
            /// @brief Returns a space delimited list of the active packages in stack order.
            ///    @ingroup Packages)
            /// 
            /// </summary>
            public string getPackageList()
                {
                return m_ts.fn_getPackageList();
                }

            /// <summary>
            /// Returns the pixel shader version for the active device.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public float getPixelShaderVersion()
                {
                return m_ts.fn_getPixelShaderVersion();
                }

            /// <summary>
            /// Get the current seed used by the random number generator.
            ///    @return The current random number generator seed value.
            ///    @ingroup Random )
            /// 
            /// </summary>
            public int getRandomSeed()
                {
                return m_ts.fn_getRandomSeed();
                }

            /// <summary>
            /// Extract the record at the given @a index in the newline-separated list in @a text.
            ///    Records in @a text must be separated by newlines.
            ///    @param text A list of records separated by newlines.
            ///    @param index The zero-based index of the record to extract.
            ///    @return The record at the given index or \"\" if @a index is out of range.
            ///    @tsexample
            ///       getRecord( \"a b\" NL \"c d\" NL \"e f\", 1 ) // Returns \"c d\"
            ///    @endtsexample
            ///    @see getRecords
            ///    @see getRecordCount
            ///    @see getWord
            ///    @see getField
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string getRecord(string text, int index)
                {
                return m_ts.fn_getRecord(text, index);
                }

            /// <summary>
            /// Return the number of newline-separated records in @a text.
            ///    @param text A list of records separated by newlines.
            ///    @return The number of newline-sepearated elements in @a text.
            ///    @tsexample
            ///       getRecordCount( \"a b\" NL \"c d\" NL \"e f\" ) // Returns 3
            ///    @endtsexample
            ///    @see getWordCount
            ///    @see getFieldCount
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public int getRecordCount(string text)
                {
                return m_ts.fn_getRecordCount(text);
                }

            /// <summary>
            /// Extract a range of records from the given @a startIndex onwards thru @a endIndex.
            ///    Records in @a text must be separated by newlines.
            ///    @param text A list of records separated by newlines.
            ///    @param startIndex The zero-based index of the first record to extract from @a text.
            ///    @param endIndex The zero-based index of the last record to extract from @a text.  If this is -1, all records beginning 
            ///       with @a startIndex are extracted from @a text.
            ///    @return A string containing the specified range of records from @a text or \"\" if @a startIndex 
            ///       is out of range or greater than @a endIndex.
            ///    @tsexample
            ///       getRecords( \"a b\" NL \"c d\" NL \"e f\", 1 ) // Returns \"c d\" NL \"e f\"
            ///    @endtsexample
            ///    @see getRecord
            ///    @see getRecordCount
            ///    @see getWords
            ///    @see getFields
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string getRecords(string text, int startIndex, int endIndex)
                {
                return m_ts.fn_getRecords(text, startIndex, endIndex);
                }

            /// <summary>
            /// @brief Return a substring of @a str starting at @a start and continuing either through to the end of @a str 
            ///    (if @a numChars is -1) or for @a numChars characters (except if this would exceed the actual source 
            ///    string length).
            ///    @param str The string from which to extract a substring.
            ///    @param start The offset at which to start copying out characters.
            ///    @param numChars Optional argument to specify the number of characters to copy.  If this is -1, all characters up the end 
            ///       of the input string are copied.
            ///    @return A string that contains the given portion of the input string.
            ///    @tsexample
            ///    getSubStr( \"foobar\", 1, 2 ) // Returns \"oo\".
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string getSubStr(string str, int start, int numChars)
                {
                return m_ts.fn_getSubStr(str, start, numChars);
                }

            /// <summary>
            /// Returns a list of texture profiles in the format: ProfileName TextureCount TextureMB
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public string getTextureProfileStats()
                {
                return m_ts.fn_getTextureProfileStats();
                }

            /// <summary>
            /// Get the numeric suffix of the given input string.
            ///    @param str The string from which to read out the numeric suffix.
            ///    @return The numeric value of the number suffix of @a str or -1 if @a str has no such suffix.
            ///    @tsexample
            ///    getTrailingNumber( \"test123\" ) // Returns '123'.
            ///    @endtsexample
            ///    @see stripTrailingNumber
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int getTrailingNumber(string str)
                {
                return m_ts.fn_getTrailingNumber(str);
                }

            /// <summary>
            /// Test whether Torque is running in web-deployment mode.
            ///    In this mode, Torque will usually run within a browser and certain restrictions apply (e.g. Torque will not 
            ///    be able to enter fullscreen exclusive mode).
            ///    @return True if Torque is running in web-deployment mode.
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public bool getWebDeployment()
                {
                return m_ts.fn_getWebDeployment();
                }

            /// <summary>
            /// Extract the word at the given @a index in the whitespace-separated list in @a text.
            ///    Words in @a text must be separated by newlines, spaces, and/or tabs.
            ///    @param text A whitespace-separated list of words.
            ///    @param index The zero-based index of the word to extract.
            ///    @return The word at the given index or \"\" if the index is out of range.
            ///    @tsexample
            ///       getWord( \"a b c\", 1 ) // Returns \"b\"
            ///    @endtsexample
            ///    @see getWords
            ///    @see getWordCount
            ///    @see getField
            ///    @see getRecord
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string getWord(string text, int index)
                {
                return m_ts.fn_getWord(text, index);
                }

            /// <summary>
            /// Return the number of whitespace-separated words in @a text.
            ///    Words in @a text must be separated by newlines, spaces, and/or tabs.
            ///    @param text A whitespace-separated list of words.
            ///    @return The number of whitespace-separated words in @a text.
            ///    @tsexample
            ///       getWordCount( \"a b c d e\" ) // Returns 5
            ///    @endtsexample
            ///    @see getFieldCount
            ///    @see getRecordCount
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public int getWordCount(string text)
                {
                return m_ts.fn_getWordCount(text);
                }

            /// <summary>
            /// Extract a range of words from the given @a startIndex onwards thru @a endIndex.
            ///    Words in @a text must be separated by newlines, spaces, and/or tabs.
            ///    @param text A whitespace-separated list of words.
            ///    @param startIndex The zero-based index of the first word to extract from @a text.
            ///    @param endIndex The zero-based index of the last word to extract from @a text.  If this is -1, all words beginning 
            ///       with @a startIndex are extracted from @a text.
            ///    @return A string containing the specified range of words from @a text or \"\" if @a startIndex 
            ///       is out of range or greater than @a endIndex.
            ///    @tsexample
            ///       getWords( \"a b c d\", 1, 2, ) // Returns \"b c\"
            ///    @endtsexample
            ///    @see getWord
            ///    @see getWordCount
            ///    @see getFields
            ///    @see getRecords
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string getWords(string text, int startIndex, int endIndex)
                {
                return m_ts.fn_getWords(text, startIndex, endIndex);
                }

            /// <summary>
            /// @brief Reports the current directory
            /// 
            /// 	@return String containing full file path of working directory
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string getWorkingDirectory()
                {
                return m_ts.fn_getWorkingDirectory();
                }

            /// <summary>
            /// Open the given URL or file in the user's web browser.
            ///    @param address The address to open.  If this is not prefixed by a protocol specifier (\"...://\"), then 
            ///       the function checks whether the address refers to a file or directory and if so, prepends \"file://\" 
            ///       to @a adress; if the file check fails, \"http://\" is prepended to @a address.
            ///    @tsexample
            ///       gotoWebPage( \"http://www.garagegames.com\" );
            ///    @endtsexample
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public void gotoWebPage(string address)
                {
                m_ts.fn_gotoWebPage(address);
                }

            /// <summary>
            /// Import an image strip from exportCachedFont. Call with the 
            ///    same parameters you called exportCachedFont.
            ///    @param faceName The name of the font face.
            ///    @param fontSize The size of the font in pixels.
            ///    @param fileName The file name and path for the input PNG.
            ///    @param padding The padding between characters.   
            ///    @param kerning The kerning between characters.   
            ///    @ingroup Font )
            /// 
            /// </summary>
            public void importCachedFont(string faceName, int fontSize, string fileName, int padding, int kerning)
                {
                m_ts.fn_importCachedFont(faceName, fontSize, fileName, padding, kerning);
                }

            /// <summary>
            /// @brief Start a search for items at the given position and within the given radius, filtering by mask.
            /// 
            ///    @param pos Center position for the search
            ///    @param radius Search radius
            ///    @param mask Bitmask of object types to include in the search
            ///    @param useClientContainer Optionally indicates the search should be within the 
            ///    client container.
            /// 
            ///    @see containerSearchNext 
            ///    @ingroup Game)
            /// 
            /// </summary>
            public void initContainerRadiusSearch(Point3F pos, float radius, uint mask, bool useClientContainer)
                {
                m_ts.fn_initContainerRadiusSearch(pos.AsString(), radius, mask, useClientContainer);
                }

            /// <summary>
            /// @brief Start a search for all items of the types specified by the bitset mask.
            /// 
            ///    @param mask Bitmask of object types to include in the search
            ///    @param useClientContainer Optionally indicates the search should be within the 
            ///    client container.
            /// 
            ///    @see containerSearchNext 
            ///    @ingroup Game)
            /// 
            /// </summary>
            public void initContainerTypeSearch(uint mask, bool useClientContainer)
                {
                m_ts.fn_initContainerTypeSearch(mask, useClientContainer);
                }

            /// <summary>
            /// Test whether the character at the given position is an alpha-numeric character.
            ///    Alpha-numeric characters are characters that are either alphabetic (a-z, A-Z) or numbers (0-9).
            ///    @param str The string to test.
            ///    @param index The index of a character in @a str.
            ///    @return True if the character at the given index in @a str is an alpha-numeric character; false otherwise.
            ///    @see isspace
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public bool isalnum(string str, int index)
                {
                return m_ts.fn_isalnum(str, index);
                }

            /// <summary>
            /// @brief Returns true if the passed identifier is the name of a declared class.
            /// 				@ingroup Console)
            /// 
            /// </summary>
            public bool isClass(string identifier)
                {
                return m_ts.fn_isClass(identifier);
                }

            /// <summary>
            /// Test whether the engine has been compiled with TORQUE_DEBUG, i.e. if it includes debugging functionality.
            ///    @return True if this is a debug build; false otherwise.
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public bool isDebugBuild()
                {
                return m_ts.fn_isDebugBuild();
                }

            /// <summary>
            /// @brief Determines if a specified directory exists or not
            /// 
            /// 	@param directory String containing path in the form of \"foo/bar\"
            ///    @return Returns true if the directory was found.
            /// 
            /// 	@note Do not include a trailing slash '/'.
            /// 
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public bool IsDirectory(string directory)
                {
                return m_ts.fn_IsDirectory(directory);
                }

            /// <summary>
            /// @brief Determines if the specified file exists or not
            ///    
            ///    @param fileName The path to the file.
            ///    @return Returns true if the file was found.
            ///    
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public bool isFile(string fileName)
                {
                return m_ts.fn_isFile(fileName);
                }

            /// <summary>
            /// @brief Returns true if the class is derived from the super class.
            ///    If either class doesn't exist this returns false.
            ///    @param className The class name.
            ///    @param superClassName The super class to look for.
            ///    @ingroup Console)
            /// 
            /// </summary>
            public bool isMemberOfClass(string className, string superClassName)
                {
                return m_ts.fn_isMemberOfClass(className, superClassName);
                }

            /// <summary>
            /// @brief Returns true if the identifier is the name of a declared package.
            ///    @ingroup Packages)
            /// 
            /// </summary>
            public bool isPackage(string identifier)
                {
                return m_ts.fn_isPackage(identifier);
                }

            /// <summary>
            /// Test whether the engine has been compiled with TORQUE_SHIPPING, i.e. in a form meant for final release.
            ///    @return True if this is a shipping build; false otherwise.
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public bool isShippingBuild()
                {
                return m_ts.fn_isShippingBuild();
                }

            /// <summary>
            /// Test whether the character at the given position is a whitespace character.
            ///    Characters such as tab, space, or newline are considered whitespace.
            ///    @param str The string to test.
            ///    @param index The index of a character in @a str.
            ///    @return True if the character at the given index in @a str is a whitespace character; false otherwise.
            ///    @see isalnum
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public bool isspace(string str, int index)
                {
                return m_ts.fn_isspace(str, index);
                }

            /// <summary>
            /// Test whether the engine has been compiled with TORQUE_TOOLS, i.e. if it includes tool-related functionality.
            ///    @return True if this is a tool build; false otherwise.
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public bool isToolBuild()
                {
                return m_ts.fn_isToolBuild();
                }

            /// <summary>
            /// @brief Determines if a file name can be written to using File I/O
            /// 
            /// 	@param fileName Name and path of file to check
            /// 	@return Returns true if the file can be written to.
            /// 
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public bool isWriteableFileName(string fileName)
                {
                return m_ts.fn_isWriteableFileName(fileName);
                }

            /// <summary>
            /// Will generate static lighting for the scene if supported by the active light manager.
            ///    If mode is \"forceAlways\", the lightmaps will be regenerated regardless of whether 
            ///    lighting cache files can be written to. If mode is \"forceWritable\", then the lightmaps 
            ///    will be regenerated only if the lighting cache files can be written.
            ///    @param completeCallbackFn The name of the function to execute when the lighting is complete.
            ///    @param mode One of \"forceAlways\",  \"forceWritable\" or \"loadOnly\".
            ///    @return Returns true if the scene lighting process was started.
            ///    @ingroup Lighting )
            /// 
            /// </summary>
            public bool lightScene(string completeCallbackFn, string mode)
                {
                return m_ts.fn_lightScene(completeCallbackFn, mode);
                }

            /// <summary>
            /// Returns a list of the unflagged GFX resources. See flagCurrentGFXResources for usage details.
            ///    @ingroup GFX
            ///    @see flagCurrentGFXResources, clearGFXResourceFlags, describeGFXResources )
            /// 
            /// </summary>
            public void listGFXResources(bool unflaggedOnly)
                {
                m_ts.fn_listGFXResources(unflaggedOnly);
                }

            /// <summary>
            /// @brief Loads a serialized object from a file.
            /// 				@param Name and path to text file containing the object
            /// 				@ingroup Console)
            /// 
            /// </summary>
            public string loadObject(string filename)
                {
                return m_ts.fn_loadObject(filename);
                }

            /// <summary>
            /// @brief Logs a message to the console.
            ///    @param message The message text.
            ///    @note By default, messages will appear white in the console.
            ///    @ingroup Logging)
            /// 
            /// </summary>
            public void log(string message)
                {
                m_ts.fn_log(message);
                }

            /// <summary>
            /// @brief Logs an error message to the console.
            ///    @param message The message text.
            ///    @note By default, errors will appear red in the console.
            ///    @ingroup Logging)
            /// 
            /// </summary>
            public void logError(string message)
                {
                m_ts.fn_logError(message);
                }

            /// <summary>
            /// @brief Logs a warning message to the console.
            ///    @param message The message text.
            ///    @note By default, warnings will appear turquoise in the console.
            ///    @ingroup Logging)
            /// 
            /// </summary>
            public void logWarning(string message)
                {
                m_ts.fn_logWarning(message);
                }

            /// <summary>
            /// Remove leading whitespace from the string.
            ///    @param str A string.
            ///    @return A string that is the same as @a str but with any leading (i.e. leftmost) whitespace removed.
            ///    @tsexample
            ///    ltrim( \"   string  \" ); // Returns \"string  \".
            ///    @endtsexample
            ///    @see rtrim
            ///    @see trim
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string ltrim(string str)
                {
                return m_ts.fn_ltrim(str);
                }

            /// <summary>
            /// Return the value of 2*PI (full-circle in radians).
            ///     @returns The value of 2*PI.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float m2Pi()
                {
                return m_ts.fn_m2Pi();
                }

            /// <summary>
            /// Calculate absolute value of specified value.
            ///     @param v Input Value.
            ///     @returns Absolute value of specified value.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mAbs(float v)
                {
                return m_ts.fn_mAbs(v);
                }

            /// <summary>
            /// Calculate the arc-cosine of v.
            ///     @param v Input Value (in radians).
            ///     @returns The arc-cosine of the input value.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mAcos(float v)
                {
                return m_ts.fn_mAcos(v);
                }

            /// <summary>
            /// ),
            /// 	@brief Converts a relative file path to a full path
            /// 
            /// 	For example, \"./console.log\" becomes \"C:/Torque/t3d/examples/FPS Example/game/console.log\"
            /// 	@param path Name of file or path to check
            ///    @param cwd Optional current working directory from which to build the full path.
            /// 	@return String containing non-relative directory of path
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string makeFullPath(string path, string cwd)
                {
                return m_ts.fn_makeFullPath(path, cwd);
                }

            /// <summary>
            /// ),
            /// 	@brief Turns a full or local path to a relative one
            /// 
            ///    For example, \"./game/art\" becomes \"game/art\"
            ///    @param path Full path (may include a file) to convert
            ///    @param to Optional base path used for the conversion.  If not supplied the current 
            ///    working directory is used.
            /// 	@returns String containing relative path
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string makeRelativePath(string path, string to)
                {
                return m_ts.fn_makeRelativePath(path, to);
                }

            /// <summary>
            /// Calculate the arc-sine of v.
            ///     @param v Input Value (in radians).
            ///     @returns The arc-sine of the input value.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mAsin(float v)
                {
                return m_ts.fn_mAsin(v);
                }

            /// <summary>
            /// Calculate the arc-tangent (slope) of a line defined by rise and run.
            ///     @param rise of line.
            ///     @param run of line.
            ///     @returns The arc-tangent (slope) of a line defined by rise and run.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mAtan(float rise, float run)
                {
                return m_ts.fn_mAtan(rise, run);
                }

            /// <summary>
            /// Create a transform from the given translation and orientation.
            ///    @param position The translation vector for the transform.
            ///    @param orientation The axis and rotation that orients the transform.
            ///    @return A transform based on the given position and orientation.
            ///    @ingroup Matrices )
            /// 
            /// </summary>
            public TransformF MatrixCreate(Point3F position, AngAxisF orientation)
                {
                return new TransformF(m_ts.fn_MatrixCreate(position.AsString(), orientation.AsString()));
                }

            /// <summary>
            /// @Create a matrix from the given rotations.
            ///    @param Vector3F X, Y, and Z rotation in *radians*.
            ///    @return A transform based on the given orientation.
            ///    @ingroup Matrices )
            /// 
            /// </summary>
            public TransformF MatrixCreateFromEuler(Point3F angles)
                {
                return new TransformF(m_ts.fn_MatrixCreateFromEuler(angles.AsString()));
                }

            /// <summary>
            /// @brief Multiply the given point by the given transform assuming that w=1.
            ///    This function will multiply the given vector such that translation with take effect.
            ///    @param transform A transform.
            ///    @param point A vector.
            ///    @return The transformed vector.
            ///    @ingroup Matrices)
            /// 
            /// </summary>
            public Point3F MatrixMulPoint(TransformF transform, Point3F point)
                {
                return new Point3F(m_ts.fn_MatrixMulPoint(transform.AsString(), point.AsString()));
                }

            /// <summary>
            /// @brief Multiply the two matrices.
            ///    @param left First transform.
            ///    @param right Right transform.
            ///    @return Concatenation of the two transforms.
            ///    @ingroup Matrices )
            /// 
            /// </summary>
            public TransformF MatrixMultiply(TransformF left, TransformF right)
                {
                return new TransformF(m_ts.fn_MatrixMultiply(left.AsString(), right.AsString()));
                }

            /// <summary>
            /// @brief Multiply the vector by the transform assuming that w=0.
            ///    This function will multiply the given vector by the given transform such that translation will 
            ///    not affect the vector.
            ///    @param transform A transform.
            ///    @param vector A vector.
            ///    @return The transformed vector.
            ///    @ingroup Matrices)
            /// 
            /// </summary>
            public Point3F MatrixMulVector(TransformF transform, Point3F vector)
                {
                return new Point3F(m_ts.fn_MatrixMulVector(transform.AsString(), vector.AsString()));
                }

            /// <summary>
            /// Round v up to the nearest integer.
            ///     @param v Number to convert to integer.
            ///     @returns Number converted to integer.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public int mCeil(float v)
                {
                return m_ts.fn_mCeil(v);
                }

            /// <summary>
            /// Clamp the specified value between two bounds.
            ///     @param v Input value.
            ///     @param min Minimum Bound.
            ///     @param max Maximum Bound.
            ///     @returns The specified value clamped to the specified bounds.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mClamp(float v, float min, float max)
                {
                return m_ts.fn_mClamp(v, min, max);
                }

            /// <summary>
            /// Calculate the cosine of v.
            ///     @param v Input Value (in radians).
            ///     @returns The cosine of the input value.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mCos(float v)
                {
                return m_ts.fn_mCos(v);
                }

            /// <summary>
            /// Convert specified degrees into radians.
            ///     @param degrees Input Value (in degrees).
            ///     @returns The specified degrees value converted to radians.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mDegToRad(float degrees)
                {
                return m_ts.fn_mDegToRad(degrees);
                }

            /// <summary>
            /// Display a modal message box using the platform's native message box implementation.
            ///    @param title The title to display on the message box window.
            ///    @param message The text message to display in the box.
            ///    @param buttons Which buttons to put on the message box.
            ///    @param icons Which icon to show next to the message.
            ///    @return One of $MROK, $MRCancel, $MRRetry, and $MRDontSave identifying the button that the user pressed.
            ///    @tsexample
            ///       messageBox( \"Error\", \"\" );    @endtsexample
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public int messageBox(string title, string message, MBButtons buttons, MBIcons icons)
                {
                return m_ts.fn_messageBox(title, message, (int) buttons, (int) icons);
                }

            /// <summary>
            /// Formats the specified number to the given number of decimal places.
            ///     @param v Number to format.
            ///     @param precision Number of decimal places to format to (1-9).
            ///     @returns Number formatted to the specified number of decimal places.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public string mFloatLength(float v, uint precision)
                {
                return m_ts.fn_mFloatLength(v, precision);
                }

            /// <summary>
            /// Round v down to the nearest integer.
            ///     @param v Number to convert to integer.
            ///     @returns Number converted to integer.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public int mFloor(float v)
                {
                return m_ts.fn_mFloor(v);
                }

            /// <summary>
            /// Calculate the remainder of v/d.
            ///     @param v Input Value.
            ///     @param d Divisor Value.
            ///     @returns The remainder of v/d.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mFMod(float v, float d)
                {
                return m_ts.fn_mFMod(v, d);
                }

            /// <summary>
            /// Returns whether the value is an exact power of two.
            ///     @param v Input value.
            ///     @returns Whether the specified value is an exact power of two.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public bool mIsPow2(int v)
                {
                return m_ts.fn_mIsPow2(v);
                }

            /// <summary>
            /// Calculate linearly interpolated value between two specified numbers using specified normalized time.
            ///     @param v1 Interpolate From Input value.
            ///     @param v2 Interpolate To Input value.
            ///     @param time Normalized time used to interpolate values (0-1).
            ///     @returns The interpolated value between the two specified values at normalized time t.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mLerp(float v1, float v2, float time)
                {
                return m_ts.fn_mLerp(v1, v2, time);
                }

            /// <summary>
            /// Calculate the natural logarithm of v.
            ///     @param v Input Value.
            ///     @returns The natural logarithm of the input value.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mLog(float v)
                {
                return m_ts.fn_mLog(v);
                }

            /// <summary>
            /// Return the value of PI (half-circle in radians).
            ///     @returns The value of PI.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mPi()
                {
                return m_ts.fn_mPi();
                }

            /// <summary>
            /// Calculate b raised to the p-th power.
            ///     @param v Input Value.
            ///     @param p Power to raise value by.
            ///     @returns v raised to the p-th power.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mPow(float v, float p)
                {
                return m_ts.fn_mPow(v, p);
                }

            /// <summary>
            /// Convert specified radians into degrees.
            ///     @param radians Input Value (in radians).
            ///     @returns The specified radians value converted to degrees.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mRadToDeg(float radians)
                {
                return m_ts.fn_mRadToDeg(radians);
                }

            /// <summary>
            /// Round v to the nearest integer.
            ///     @param v Number to convert to integer.
            ///     @returns Number converted to integer.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public int mRound(float v)
                {
                return m_ts.fn_mRound(v);
                }

            /// <summary>
            /// Clamp the specified value between 0 and 1 (inclusive).
            ///     @param v Input value.
            ///     @returns The specified value clamped between 0 and 1 (inclusive).
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mSaturate(float v)
                {
                return m_ts.fn_mSaturate(v);
                }

            /// <summary>
            /// Calculate the sine of v.
            ///     @param v Input Value (in radians).
            ///     @returns The sine of the input value.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mSin(float v)
                {
                return m_ts.fn_mSin(v);
                }

            /// <summary>
            /// Solve a cubic equation (3rd degree polynomial) of form a*x^3 + b*x^2 + c*x + d = 0.
            ///     @param a First Coefficient.
            ///     @param b Second Coefficient.
            ///     @param c Third Coefficient.
            ///     @param d Fourth Coefficient.
            ///     @returns A 4-tuple, containing: (sol x0 x1 x2). (sol) is the number of solutions
            ///     (being 0, 1, 2 or 3), and (x0), (x1) and (x2) are the solutions, if any.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public string mSolveCubic(float a, float b, float c, float d)
                {
                return m_ts.fn_mSolveCubic(a, b, c, d);
                }

            /// <summary>
            /// Solve a quadratic equation (2nd degree polynomial) of form a*x^2 + b*x + c = 0.
            ///     @param a First Coefficient.
            ///     @param b Second Coefficient.
            ///     @param c Third Coefficient.
            ///     @returns A triple, containing: (sol x0 x1). (sol) is the number of solutions
            ///     (being 0, 1, or 2), and (x0) and (x1) are the solutions, if any.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public string mSolveQuadratic(float a, float b, float c)
                {
                return m_ts.fn_mSolveQuadratic(a, b, c);
                }

            /// <summary>
            /// Solve a quartic equation (4th degree polynomial) of form a*x^4 + b*x^3 + c*x^2 + d*x + e = 0.
            ///     @param a First Coefficient.
            ///     @param b Second Coefficient.
            ///     @param c Third Coefficient.
            ///     @param d Fourth Coefficient.
            ///     @param e Fifth Coefficient.
            ///     @returns A 5-tuple, containing: (sol x0 x1 x2 c3). (sol) is the number of solutions
            ///     (being 0, 1, 2, 3 or 4), and (x0), (x1), (x2) and (x3) are the solutions, if any.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public string mSolveQuartic(float a, float b, float c, float d, float e)
                {
                return m_ts.fn_mSolveQuartic(a, b, c, d, e);
                }

            /// <summary>
            /// Calculate the square-root of v.
            ///     @param v Input Value.
            ///     @returns The square-root of the input value.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mSqrt(float v)
                {
                return m_ts.fn_mSqrt(v);
                }

            /// <summary>
            /// Calculate the tangent of v.
            ///     @param v Input Value (in radians).
            ///     @returns The tangent of the input value.
            ///     @ingroup Math )
            /// 
            /// </summary>
            public float mTan(float v)
                {
                return m_ts.fn_mTan(v);
                }

            /// <summary>
            /// @brief Open the given @a file through the system.  This will usually open the file in its 
            ///    associated application.
            ///    @param file %Path of the file to open.
            ///    @note Only present in a Tools build of Torque.
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public void openFile(string file)
                {
                m_ts.fn_openFile(file);
                }

            /// <summary>
            /// @brief Open the given folder in the system's file manager.
            ///    @param path full path to a directory.
            ///    @note Only present in a Tools build of Torque.
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public void openFolder(string path)
                {
                m_ts.fn_openFolder(path);
                }

            /// <summary>
            /// @brief Combines two separate strings containing a file path and file name together into a single string
            /// 
            /// 	@param path String containing file path
            /// 	@param file String containing file name
            /// 	@return String containing concatenated file name and path
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public string pathConcat(string path, string file)
                {
                return m_ts.fn_pathConcat(path, file);
                }

            /// <summary>
            /// @brief Copy a file to a new location.
            ///    @param fromFile %Path of the file to copy.
            ///    @param toFile %Path where to copy @a fromFile to.
            ///    @param noOverwrite If true, then @a fromFile will not overwrite a file that may already exist at @a toFile.
            ///    @return True if the file was successfully copied, false otherwise.
            ///    @note Only present in a Tools build of Torque.
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public bool pathCopy(string fromFile, string toFile, bool noOverwrite)
                {
                return m_ts.fn_pathCopy(fromFile, toFile, noOverwrite);
                }

            /// <summary>
            /// @brief Load all Path information from the mission.
            /// 
            ///    This function is usually called from the loadMissionStage2() server-side function 
            ///    after the mission file has loaded.  Internally it places all Paths into the server's 
            ///    PathManager.  From this point the Paths are ready for transmission to the clients.
            /// 
            ///    @tsexample
            ///       // Inform the engine to load all Path information from the mission.
            ///       pathOnMissionLoadDone();
            ///    @endtsexample
            /// 
            ///    @see NetConnection::transmitPaths()
            ///    @see NetConnection::clearPaths()
            ///    @see Path
            /// 
            ///    @ingroup Networking)
            /// 
            /// </summary>
            public void pathOnMissionLoadDone()
                {
                m_ts.fn_pathOnMissionLoadDone();
                }

            /// <summary>
            /// THEORA, 30.0f, Point2I( 0, 0 ) ),
            ///    Load a journal file and capture it video.
            ///    @ingroup Rendering )
            /// 
            /// </summary>
            public void playJournalToVideo(string journalFile, string videoFile, string encoder, float framerate, Point2I resolution)
                {
                m_ts.fn_playJournalToVideo(journalFile, videoFile, encoder, framerate, resolution.AsString());
                }

            /// <summary>
            /// Populate the font cache for all fonts with Unicode code points in the specified range.
            ///    @param rangeStart The start Unicode point.
            ///    @param rangeEnd The end Unicode point.
            ///    @note We only support BMP-0, so code points range from 0 to 65535.
            ///    @ingroup Font )
            /// 
            /// </summary>
            public void populateAllFontCacheRange(uint rangeStart, uint rangeEnd)
                {
                m_ts.fn_populateAllFontCacheRange(rangeStart, rangeEnd);
                }

            /// <summary>
            /// Populate the font cache for all fonts with characters from the specified string.
            ///    @ingroup Font )
            /// 
            /// </summary>
            public void populateAllFontCacheString(string xstring)
                {
                m_ts.fn_populateAllFontCacheString(xstring);
                }

            /// <summary>
            /// Populate the font cache for the specified font with Unicode code points in the specified range.
            ///    @param faceName The name of the font face.
            ///    @param fontSize The size of the font in pixels.
            ///    @param rangeStart The start Unicode point.
            ///    @param rangeEnd The end Unicode point.
            ///    @note We only support BMP-0, so code points range from 0 to 65535.
            ///    @ingroup Font )
            /// 
            /// </summary>
            public void populateFontCacheRange(string faceName, int fontSize, uint rangeStart, uint rangeEnd)
                {
                m_ts.fn_populateFontCacheRange(faceName, fontSize, rangeStart, rangeEnd);
                }

            /// <summary>
            /// Populate the font cache for the specified font with characters from the specified string.
            ///     @param faceName The name of the font face.
            ///     @param fontSize The size of the font in pixels.
            ///     @param string The string to populate.
            ///     @ingroup Font )
            /// 
            /// </summary>
            public void populateFontCacheString(string faceName, int fontSize, string xstring)
                {
                m_ts.fn_populateFontCacheString(faceName, fontSize, xstring);
                }

            /// <summary>
            /// Preload all datablocks in client mode.
            ///    (Server parameter is set to false).  This will take some time to complete.)
            /// 
            /// </summary>
            public void preloadClientDataBlocks()
                {
                m_ts.fn_preloadClientDataBlocks();
                }

            /// <summary>
            /// @brief Dumps current profiling stats to the console window.
            /// 				@note Markers disabled with profilerMarkerEnable() will be skipped over. 
            /// 				If the profiler is currently running, it will be disabled.
            /// 				@ingroup Debugging)
            /// 
            /// </summary>
            public void profilerDump()
                {
                m_ts.fn_profilerDump();
                }

            /// <summary>
            /// @brief Dumps current profiling stats to a file.
            /// 				@note If the profiler is currently running, it will be disabled.
            /// 				@param fileName Name and path of file to save profiling stats to. Must use forward slashes (/). 
            /// 				Will attempt to create the file if it does not already exist.
            /// 				@tsexample
            /// 				profilerDumpToFile( \"C:/Torque/log1.txt\" );
            /// 				@endtsexample
            /// 				@ingroup Debugging )
            /// 
            /// </summary>
            public void profilerDumpToFile(string fileName)
                {
                m_ts.fn_profilerDumpToFile(fileName);
                }

            /// <summary>
            /// @brief Enables or disables the profiler.
            /// 				Data is only gathered while the profiler is enabled.
            /// 				@note Profiler is not available in shipping builds.
            /// 				T3D has predefined profiling areas surrounded by markers, 
            /// 				but you may need to define additional markers (in C++) around areas you wish to profile,
            /// 				 by using the PROFILE_START( markerName ); and PROFILE_END(); macros.
            /// 				@ingroup Debugging )
            /// 
            /// </summary>
            public void profilerEnable(bool enable)
                {
                m_ts.fn_profilerEnable(enable);
                }

            /// <summary>
            /// @brief Enable or disable a specific profile.
            ///    @param enable     Optional paramater to enable or disable the profile.
            ///    @param markerName Name of a specific marker to enable or disable.
            ///    @note Calling this function will first call profilerReset(), clearing all data from profiler. 
            ///    All profile markers are enabled by default.
            ///    @ingroup Debugging)
            /// 
            /// </summary>
            public void profilerMarkerEnable(string markerName, bool enable)
                {
                m_ts.fn_profilerMarkerEnable(markerName, enable);
                }

            /// <summary>
            /// @brief Resets the profiler, clearing it of all its data.
            /// 				If the profiler is currently running, it will first be disabled. 
            /// 				All markers will retain their current enabled/disabled status.
            /// 				@ingroup Debugging )
            /// 
            /// </summary>
            public void profilerReset()
                {
                m_ts.fn_profilerReset();
                }

            /// <summary>
            /// Shut down the engine and exit its process.
            ///    This function cleanly uninitializes the engine and then exits back to the system with a process 
            ///    exit status indicating a clean exit.
            ///    @see quitWithErrorMessage
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public void quit()
                {
                m_ts.fn_quit();
                }

            /// <summary>
            /// Display an error message box showing the given @a message and then shut down the engine and exit its process.
            ///    This function cleanly uninitialized the engine and then exits back to the system with a process 
            ///    exit status indicating an error.
            ///    @param message The message to log to the console and show in an error message box.
            ///    @see quit
            ///    @ingroup Platform )
            /// 
            /// </summary>
            public void quitWithErrorMessage(string message)
                {
                m_ts.fn_quitWithErrorMessage(message);
                }

            /// <summary>
            /// Force the resource at specified input path to be reloaded
            ///    @param path Path to the resource to be reloaded
            ///    @tsexample
            ///    reloadResource( \"art/shapes/box.dts\" );
            ///    @endtsexample
            ///    @note Currently used by editors only
            ///    @ingroup Editors
            ///    @internal)
            /// 
            /// </summary>
            public void reloadResource(string path)
                {
                m_ts.fn_reloadResource(path);
                }

            /// <summary>
            /// Reload all the textures from disk.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public void reloadTextures()
                {
                m_ts.fn_reloadTextures();
                }

            /// <summary>
            /// Remove the field in @a text at the given @a index.
            ///    Fields in @a text must be separated by newlines and/or tabs.
            ///    @param text A list of fields separated by newlines and/or tabs.
            ///    @param index The zero-based index of the field in @a text.
            ///    @return A new string with the field at the given index removed or the original string if @a index is 
            ///       out of range.
            ///    @tsexample
            ///       removeField( \"a b\" TAB \"c d\" TAB \"e f\", 1 ) // Returns \"a b\" TAB \"e f\"
            ///    @endtsexample
            ///    @see removeWord
            ///    @see removeRecord
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string removeField(string text, int index)
                {
                return m_ts.fn_removeField(text, index);
                }

            /// <summary>
            /// Removes an existing global macro by name.
            ///    @see addGlobalShaderMacro
            ///    @ingroup Rendering )
            /// 
            /// </summary>
            public void removeGlobalShaderMacro(string name)
                {
                m_ts.fn_removeGlobalShaderMacro(name);
                }

            /// <summary>
            /// Remove the record in @a text at the given @a index.
            ///    Records in @a text must be separated by newlines.
            ///    @param text A list of records separated by newlines.
            ///    @param index The zero-based index of the record in @a text.
            ///    @return A new string with the record at the given @a index removed or the original string if @a index is 
            ///       out of range.
            ///    @tsexample
            ///       removeRecord( \"a b\" NL \"c d\" NL \"e f\", 1 ) // Returns \"a b\" NL \"e f\"
            ///    @endtsexample
            ///    @see removeWord
            ///    @see removeField
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string removeRecord(string text, int index)
                {
                return m_ts.fn_removeRecord(text, index);
                }

            /// <summary>
            /// Remove the word in @a text at the given @a index.
            ///    Words in @a text must be separated by newlines, spaces, and/or tabs.
            ///    @param text A whitespace-separated list of words.
            ///    @param index The zero-based index of the word in @a text.
            ///    @return A new string with the word at the given index removed or the original string if @a index is 
            ///       out of range.
            ///    @tsexample
            ///       removeWord( \"a b c d\", 2 ) // Returns \"a b d\"
            ///    @endtsexample
            ///    @see removeField
            ///    @see removeRecord
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string removeWord(string text, int index)
                {
                return m_ts.fn_removeWord(text, index);
                }

            /// <summary>
            /// @brief Deactivates and then activates the currently active light manager.
            ///    This causes most shaders to be regenerated and is often used when global 
            ///    rendering changes have occured.
            ///    @ingroup Lighting )
            /// 
            /// </summary>
            public void resetLightManager()
                {
                m_ts.fn_resetLightManager();
                }

            /// <summary>
            /// Return all but the first word in @a text.
            ///    @param text A list of words separated by newlines, spaces, and/or tabs.
            ///    @return @a text with the first word removed.
            ///    @note This is equal to 
            ///    @tsexample_nopar
            ///       getWords( text, 1 )
            ///    @endtsexample
            ///    @see getWords
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string restWords(string text)
                {
                return m_ts.fn_restWords(text);
                }

            /// <summary>
            /// Remove trailing whitespace from the string.
            ///    @param str A string.
            ///    @return A string that is the same as @a str but with any trailing (i.e. rightmost) whitespace removed.
            ///    @tsexample
            ///    rtrim( \"   string  \" ); // Returns \"   string\".
            ///    @endtsexample
            ///    @see ltrim
            ///    @see trim
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string rtrim(string str)
                {
                return m_ts.fn_rtrim(str);
                }

            /// <summary>
            /// @brief Serialize the object to a file.
            /// 				@param object The object to serialize.
            /// 				@param filename The file name and path.
            /// 				@ingroup Console)
            /// 
            /// </summary>
            public bool saveObject(string xobject, string filename)
                {
                return m_ts.fn_saveObject(xobject, filename);
                }

            /// <summary>
            /// Dump the current zoning states of all zone spaces in the scene to the console.
            ///    @param updateFirst If true, zoning states are brought up to date first; if false, the zoning states 
            ///    are dumped as is.
            ///    @note Only valid on the client.
            ///    @ingroup Game )
            /// 
            /// </summary>
            public void sceneDumpZoneStates(bool updateFirst)
                {
                m_ts.fn_sceneDumpZoneStates(updateFirst);
                }

            /// <summary>
            /// Return the SceneObject that contains the given zone.
            ///    @param zoneId ID of zone.
            ///    @return A SceneObject or NULL if the given @a zoneId is invalid.
            ///    @note Only valid on the client.
            ///    @ingroup Game )
            /// 
            /// </summary>
            public string sceneGetZoneOwner(uint zoneId)
                {
                return m_ts.fn_sceneGetZoneOwner(zoneId);
                }

            /// <summary>
            /// Takes a screenshot with optional tiling to produce huge screenshots.
            ///    @param file The output image file path.
            ///    @param format Either JPEG or PNG.
            ///    @param tileCount If greater than 1 will tile the current screen size to take a large format screenshot.
            ///    @param tileOverlap The amount of horizontal and vertical overlap between the tiles used to remove tile edge artifacts from post effects.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public void screenShot(string file, string format, uint tileCount, float tileOverlap)
                {
                m_ts.fn_screenShot(file, format, tileCount, tileOverlap);
                }

            /// <summary>
            /// @brief Set the current working directory.
            ///    @param path The absolute or relative (to the current working directory) path of the directory which should be made the new 
            ///       working directory.
            ///    @return True if the working directory was successfully changed to @a path, false otherwise.
            ///    @note Only present in a Tools build of Torque.
            ///    @ingroup FileSystem)
            /// 
            /// </summary>
            public bool setCurrentDirectory(string path)
                {
                return m_ts.fn_setCurrentDirectory(path);
                }

            /// <summary>
            /// Replace the field in @a text at the given @a index with @a replacement.
            ///    Fields in @a text must be separated by newlines and/or tabs.
            ///    @param text A list of fields separated by newlines and/or tabs.
            ///    @param index The zero-based index of the field to replace.
            ///    @param replacement The string with which to replace the field.
            ///    @return A new string with the field at the given @a index replaced by @a replacement or the original 
            ///       string if @a index is out of range.
            ///    @tsexample
            ///       setField( \"a b\" TAB \"c d\" TAB \"e f\", 1, \"g h\" ) // Returns \"a b\" TAB \"g h\" TAB \"e f\"
            ///    @endtsexample
            ///    @see getField
            ///    @see setWord
            ///    @see setRecord
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string setField(string text, int index, string replacement)
                {
                return m_ts.fn_setField(text, index, replacement);
                }

            /// <summary>
            /// Globally changes how InteriorInstances are rendered. Useful for debugging geometry and rendering artifacts
            ///    
            ///    @note This does not work in shipping mode
            /// 
            ///    @param mode The render mode can be one of the following numbers:
            ///    NormalRender            = 0,
            ///    NormalRenderLines       = 1,
            ///    ShowDetail              = 2,
            ///    ShowAmbiguous           = 3,
            ///    ShowOrphan              = 4,
            ///    ShowLightmaps           = 5,
            ///    ShowTexturesOnly        = 6,
            ///    ShowPortalZones         = 7,
            ///    ShowOutsideVisible      = 8,
            ///    ShowCollisionFans       = 9,
            ///    ShowStrips              = 10,
            ///    ShowNullSurfaces        = 11,
            ///    ShowLargeTextures       = 12,
            ///    ShowHullSurfaces        = 13,
            ///    ShowVehicleHullSurfaces = 14,
            ///    ShowVertexColors        = 15,
            ///    ShowDetailLevel         = 16
            ///    
            ///    @ingroup Game )
            /// 
            /// </summary>
            public void setInteriorRenderMode(int mode)
                {
                m_ts.fn_setInteriorRenderMode(mode);
                }

            /// <summary>
            /// Finds and activates the named light manager.
            ///    @return Returns true if the light manager is found and activated.
            ///    @ingroup Lighting )
            /// 
            /// </summary>
            public bool setLightManager(string name)
                {
                return m_ts.fn_setLightManager(name);
                }

            /// <summary>
            /// @brief Determines how log files are written.
            /// 	Sets the operational mode of the console logging system.
            ///    @param mode Parameter specifying the logging mode.  This can be:
            ///       - 1: Open and close the console log file for each seperate string of output.  This will ensure that all 
            ///          parts get written out to disk and that no parts remain in intermediate buffers even if the process crashes.
            ///       - 2: Keep the log file open and write to it continuously.  This will make the system operate faster but 
            ///          if the process crashes, parts of the output may not have been written to disk yet and will be missing from 
            ///          the log.
            ///          
            ///       Additionally, when changing the log mode and thus opening a new log file, either of the two mode values may be 
            ///       combined by binary OR with 0x4 to cause the logging system to flush all console log messages that had already been 
            ///       issued to the console system into the newly created log file.
            /// 
            /// 	@note Xbox 360 does not support logging to a file. Use Platform::OutputDebugStr in C++ instead.
            /// 	@ingroup Logging )
            /// 
            /// </summary>
            public void setLogMode(int mode)
                {
                m_ts.fn_setLogMode(mode);
                }

            /// <summary>
            /// @brief Sets the pixel shader version for the active device.
            ///    This can be used to force a lower pixel shader version than is supported by 
            ///    the device for testing or performance optimization.
            ///    @param version The floating point shader version number.
            ///    @note This will only affect shaders/materials created after the call 
            ///    and should be used before the game begins.
            ///    @see $pref::Video::forcedPixVersion
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public void setPixelShaderVersion(float version)
                {
                m_ts.fn_setPixelShaderVersion(version);
                }

            /// <summary>
            /// Set the current seed for the random number generator.
            ///    Based on this seed, a repeatable sequence of numbers will be produced by getRandom().
            ///    @param seed The seed with which to initialize the randon number generator with.  The same seed will always leed to
            ///       the same sequence of pseudo-random numbers.
            ///       If -1, the current timestamp will be used as the seed which is a good basis for randomization.
            ///    @ingroup Random )
            /// 
            /// </summary>
            public void setRandomSeed(int seed)
                {
                m_ts.fn_setRandomSeed(seed);
                }

            /// <summary>
            /// Replace the record in @a text at the given @a index with @a replacement.
            ///    Records in @a text must be separated by newlines.
            ///    @param text A list of records separated by newlines.
            ///    @param index The zero-based index of the record to replace.
            ///    @param replacement The string with which to replace the record.
            ///    @return A new string with the record at the given @a index replaced by @a replacement or the original 
            ///       string if @a index is out of range.
            ///    @tsexample
            ///       setRecord( \"a b\" NL \"c d\" NL \"e f\", 1, \"g h\" ) // Returns \"a b\" NL \"g h\" NL \"e f\"
            ///    @endtsexample
            ///    @see getRecord
            ///    @see setWord
            ///    @see setField
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string setRecord(string text, int index, string replacement)
                {
                return m_ts.fn_setRecord(text, index, replacement);
                }

            /// <summary>
            /// Set the reflection texture format.
            ///    @ingroup GFX )
            /// 
            /// </summary>
            public void setReflectFormat(GFXFormat format)
                {
                m_ts.fn_setReflectFormat((int) format);
                }

            /// <summary>
            /// Replace the word in @a text at the given @a index with @a replacement.
            ///    Words in @a text must be separated by newlines, spaces, and/or tabs.
            ///    @param text A whitespace-separated list of words.
            ///    @param index The zero-based index of the word to replace.
            ///    @param replacement The string with which to replace the word.
            ///    @return A new string with the word at the given @a index replaced by @a replacement or the original 
            ///       string if @a index is out of range.
            ///    @tsexample
            ///       setWord( \"a b c d\", 2, \"f\" ) // Returns \"a b f d\"
            ///    @endtsexample
            ///    @see getWord
            ///    @see setField
            ///    @see setRecord
            ///    @ingroup FieldManip )
            /// 
            /// </summary>
            public string setWord(string text, int index, string replacement)
                {
                return m_ts.fn_setWord(text, index, replacement);
                }

            /// <summary>
            /// Try to create a new sound device using the given properties.
            ///    If a sound device is currently initialized, it will be uninitialized first.  However, be aware that in this case, 
            ///    if this function fails, it will not restore the previously active device but rather leave the sound system in an 
            ///    uninitialized state.
            ///    Sounds that are already playing while the new device is created will be temporarily transitioned to virtualized 
            ///    playback and then resume normal playback once the device has been created.
            ///    In the core scripts, sound is automatically set up during startup in the sfxStartup() function.
            ///    @param provider The name of the device provider as returned by sfxGetAvailableDevices().
            ///    @param device The name of the device as returned by sfxGetAvailableDevices().
            ///    @param useHardware Whether to enabled hardware mixing on the device or not.  Only relevant if supported by the given device.
            ///    @param maxBuffers The maximum number of concurrent voices for this device to use or -1 for the device to pick its own reasonable default.
            ///    @return True if the initialization was successful, false if not.
            ///    @note This function must be called before any of the sound playback functions can be used.
            ///    @see sfxGetAvailableDevices
            ///    @see sfxGetDeviceInfo
            ///    @see sfxDeleteDevice
            ///    @ref SFX_devices
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public bool sfxCreateDevice(string provider, string device, bool useHardware, int maxBuffers)
                {
                return m_ts.fn_sfxCreateDevice(provider, device, useHardware, maxBuffers);
                }

            /// <summary>
            /// Delete the currently active sound device and release all its resources.
            ///    SFXSources that are still playing will be transitioned to virtualized playback mode. 
            ///    When creating a new device, they will automatically transition back to normal playback.
            ///    In the core scripts, this is done automatically for you during shutdown in the sfxShutdown() function.
            ///    @see sfxCreateDevice
            ///    @ref SFX_devices
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public void sfxDeleteDevice()
                {
                m_ts.fn_sfxDeleteDevice();
                }

            /// <summary>
            /// Mark the given @a source for deletion as soon as it moves into stopped state.
            ///    This function will retroactively turn the given @a source into a play-once source (see @ref SFXSource_playonce).
            ///    @param source A sound source.
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public void sfxDeleteWhenStopped(string source)
                {
                m_ts.fn_sfxDeleteWhenStopped(source);
                }

            /// <summary>
            /// Dump information about all current SFXSource instances to the console.
            ///    The dump includes information about the playback status for each source, volume levels, virtualization, etc.
            ///    @param includeGroups If true, direct instances of SFXSources (which represent logical sound groups) will be included. 
            ///       Otherwise only instances of subclasses of SFXSources are included in the dump.
            ///    @see SFXSource
            ///    @see sfxDumpSourcesToString
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public void sfxDumpSources(bool includeGroups)
                {
                m_ts.fn_sfxDumpSources(includeGroups);
                }

            /// <summary>
            /// Dump information about all current SFXSource instances to a string.
            ///    The dump includes information about the playback status for each source, volume levels, virtualization, etc.
            ///    @param includeGroups If true, direct instances of SFXSources (which represent logical sound groups) will be included. 
            ///       Otherwise only instances of subclasses of SFXSources are included in the dump.
            ///    @return A string containing a dump of information about all currently instantiated SFXSources.
            ///    @see SFXSource
            ///    @see sfxDumpSources
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public string sfxDumpSourcesToString(bool includeGroups)
                {
                return m_ts.fn_sfxDumpSourcesToString(includeGroups);
                }

            /// <summary>
            /// Get a list of all available sound devices.
            ///    The return value will be a newline-separated list of entries where each line describes one available sound 
            ///    device.  Each such line will have the following format:
            ///    @verbatim
            ///       provider TAB device TAB hasHardware TAB numMaxBuffers
            ///    @endverbatim
            ///    - provider: The name of the device provider (e.g. \"FMOD\").
            ///    - device: The name of the device as returned by the device layer.
            ///    - hasHardware: Whether the device supports hardware mixing or not.
            ///    - numMaxBuffers: The maximum number of concurrent voices supported by the device's mixer.  If this limit 
            ///       limit is exceeded, i.e. if there are more active sounds playing at any one time, then voice virtualization 
            ///       will start culling voices and put them into virtualized playback mode.  Voice virtualization may or may not 
            ///       be provided by the device itself; if not provided by the device, it will be provided by Torque's sound system.
            ///    @return A newline-separated list of information about all available sound devices.
            ///    @see sfxCreateDevice
            ///    @see sfxGetDeviceInfo
            ///    @see $SFX::DEVICE_INFO_PROVIDER
            ///    @see $SFX::DEVICE_INFO_NAME
            ///    @see $SFX::DEVICE_INFO_USEHARDWARE
            ///    @see $SFX::DEVICE_INFO_MAXBUFFERS
            ///    @ref SFX_devices
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public string sfxGetAvailableDevices()
                {
                return m_ts.fn_sfxGetAvailableDevices();
                }

            /// <summary>
            /// Return information about the currently active sound device.
            ///    The return value is a tab-delimited string of the following format:
            ///    @verbatim
            ///       provider TAB device TAB hasHardware TAB numMaxBuffers TAB caps
            ///    @endverbatim
            ///    - provider: The name of the device provider (e.g. \"FMOD\").
            ///    - device: The name of the device as returned by the device layer.
            ///    - hasHardware: Whether the device supports hardware mixing or not.
            ///    - numMaxBuffers: The maximum number of concurrent voices supported by the device's mixer.  If this limit 
            ///       limit is exceeded, i.e. if there are more active sounds playing at any one time, then voice virtualization 
            ///       will start culling voices and put them into virtualized playback mode.  Voice virtualization may or may not 
            ///       be provided by the device itself; if not provided by the device, it will be provided by Torque's sound system.
            ///    - caps: A bitfield of capability flags.
            ///    @return A tab-separated list of properties of the currently active sound device or the empty string if no sound device has been initialized.
            ///    @see sfxCreateDevice
            ///    @see sfxGetAvailableDevices
            ///    @see $SFX::DEVICE_INFO_PROVIDER
            ///    @see $SFX::DEVICE_INFO_NAME
            ///    @see $SFX::DEVICE_INFO_USEHARDWARE
            ///    @see $SFX::DEVICE_INFO_MAXBUFFERS
            ///    @see $SFX::DEVICE_INFO_CAPS
            ///    @see $SFX::DEVICE_CAPS_REVERB
            ///    @see $SFX::DEVICE_CAPS_VOICEMANAGEMENT
            ///    @see $SFX::DEVICE_CAPS_OCCLUSION
            ///    @see $SFX::DEVICE_CAPS_DSPEFFECTS
            ///    @see $SFX::DEVICE_CAPS_MULTILISTENER
            ///    @see $SFX::DEVICE_CAPS_FMODDESIGNER
            ///    @ref SFX_devices
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public string sfxGetDeviceInfo()
                {
                return m_ts.fn_sfxGetDeviceInfo();
                }

            /// <summary>
            /// Get the falloff curve type currently being applied to 3D sounds.
            ///    @return The current distance model type.
            ///    @ref SFXSource_volume
            ///    @ref SFX_3d
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public SFXDistanceModel sfxGetDistanceModel()
                {
                return (SFXDistanceModel) (m_ts.fn_sfxGetDistanceModel());
                }

            /// <summary>
            /// Get the current global doppler effect setting.
            ///    @return The current global doppler effect scale factor (>=0).
            ///    @see sfxSetDopplerFactor
            ///    @ref SFXSource_doppler
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public float sfxGetDopplerFactor()
                {
                return m_ts.fn_sfxGetDopplerFactor();
                }

            /// <summary>
            /// Get the current global scale factor applied to volume attenuation of 3D sounds in the logarithmic model.
            ///    @return The current scale factor for logarithmic 3D sound falloff curves.
            ///    @see sfxGetDistanceModel
            ///    @see SFXDistanceModel
            ///    @ref SFXSource_volume
            ///    @ref SFX_3d
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public float sfxGetRolloffFactor()
                {
                return m_ts.fn_sfxGetRolloffFactor();
                }

            /// <summary>
            /// Set the falloff curve type to use for distance-based volume attenuation of 3D sounds.
            ///    @param model The distance model to use for 3D sound.
            ///    @note This setting takes effect globally and is applied to all 3D sounds.
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public void sfxSetDistanceModel(SFXDistanceModel model)
                {
                m_ts.fn_sfxSetDistanceModel((int) model);
                }

            /// <summary>
            /// Set the global doppler effect scale factor.
            ///    @param value The new doppler shift scale factor.
            ///    @pre @a value must be >= 0.
            ///    @see sfxGetDopplerFactor
            ///    @ref SFXSource_doppler
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public void sfxSetDopplerFactor(float value)
                {
                m_ts.fn_sfxSetDopplerFactor(value);
                }

            /// <summary>
            /// Set the global scale factor to apply to volume attenuation of 3D sounds in the logarithmic model.
            ///    @param value The new scale factor for logarithmic 3D sound falloff curves.
            ///    @pre @a value must be > 0.
            ///    @note This function has no effect if the currently distance model is set to SFXDistanceModel::Linear.
            ///    @see sfxGetDistanceModel
            ///    @see SFXDistanceModel
            ///    @ref SFXSource_volume
            ///    @ref SFX_3d
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public void sfxSetRolloffFactor(float value)
                {
                m_ts.fn_sfxSetRolloffFactor(value);
                }

            /// <summary>
            /// Stop playback of the given @a source.
            ///    This is equivalent to calling SFXSource::stop().
            ///    @param source The source to put into stopped state.
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public void sfxStop(string source)
                {
                m_ts.fn_sfxStop(source);
                }

            /// <summary>
            /// Stop playback of the given @a source (if it is not already stopped) and delete the @a source.
            ///    The advantage of this function over directly calling delete() is that it will correctly 
            ///    handle volume fades that may be configured on the source.  Whereas calling delete() would immediately 
            ///    stop playback and delete the source, this functionality will wait for the fade-out to play and only then 
            ///    stop the source and delete it.
            ///    @param source A sound source.
            ///    @ref SFXSource_fades
            ///    @ingroup SFX )
            /// 
            /// </summary>
            public void sfxStopAndDelete(string source)
                {
                m_ts.fn_sfxStopAndDelete(source);
                }

            /// <summary>
            /// Activates the shape replicator.
            /// 													@tsexample
            /// 														// Call the function
            /// 														StartClientReplication()
            /// 													@endtsexample
            /// 													@ingroup Foliage
            /// 					)
            /// 
            /// </summary>
            public void StartClientReplication()
                {
                m_ts.fn_StartClientReplication();
                }

            /// <summary>
            /// @brief Start watching resources for file changes
            ///    Typically this is called during initializeCore().
            ///    @see stopFileChangeNotifications()
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public void startFileChangeNotifications()
                {
                m_ts.fn_startFileChangeNotifications();
                }

            /// <summary>
            /// Activates the foliage replicator.
            /// 													@tsexample
            /// 														// Call the function
            /// 														StartFoliageReplication();
            /// 													@endtsexample
            /// 													@ingroup Foliage)
            /// 
            /// </summary>
            public void StartFoliageReplication()
                {
                m_ts.fn_StartFoliageReplication();
                }

            /// <summary>
            /// Test whether the given string begins with the given prefix.
            ///    @param str The string to test.
            ///    @param prefix The potential prefix of @a str.
            ///    @param caseSensitive If true, the comparison will be case-sensitive; if false, differences in casing will 
            ///       not be taken into account.
            ///    @return True if the first characters in @a str match the complete contents of @a prefix; false otherwise.
            ///    @tsexample
            ///    startsWith( \"TEST123\", \"test\" ) // Returns true.
            ///    @endtsexample
            ///    @see endsWith
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public bool startsWith(string str, string prefix, bool caseSensitive)
                {
                return m_ts.fn_startsWith(str, prefix, caseSensitive);
                }

            /// <summary>
            /// THEORA, 30.0f, Point2I( 0, 0 ) ),
            ///    Begins a video capture session.
            ///    @see stopVideoCapture
            ///    @ingroup Rendering )
            /// 
            /// </summary>
            public void startVideoCapture(string canvas, string filename, string encoder, float framerate, Point2I resolution)
                {
                m_ts.fn_startVideoCapture(canvas, filename, encoder, framerate, resolution.AsString());
                }

            /// <summary>
            /// @brief Stop watching resources for file changes
            ///    Typically this is called during shutdownCore().
            ///    @see startFileChangeNotifications()
            /// 	@ingroup FileSystem)
            /// 
            /// </summary>
            public void stopFileChangeNotifications()
                {
                m_ts.fn_stopFileChangeNotifications();
                }

            /// <summary>
            /// Stops the video capture session.
            ///    @see startVideoCapture   
            ///    @ingroup Rendering )
            /// 
            /// </summary>
            public void stopVideoCapture()
                {
                m_ts.fn_stopVideoCapture();
                }

            /// <summary>
            /// Return the integer character code value corresponding to the first character in the given string.
            ///    @param chr a (one-character) string.
            ///    @return the UTF32 code value for the first character in the given string.
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strasc(string chr)
                {
                return m_ts.fn_strasc(chr);
                }

            /// <summary>
            /// Find the first occurrence of the given character in @a str.
            ///    @param str The string to search.
            ///    @param chr The character to search for.  Only the first character from the string is taken.
            ///    @return The remainder of the input string starting with the given character or the empty string if the character could not be found.
            ///    @see strrchr
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string strchr(string str, string chr)
                {
                return m_ts.fn_strchr(str, chr);
                }

            /// <summary>
            /// Find the first occurrence of the given character in the given string.
            ///    @param str The string to search.
            ///    @param chr The character to look for.  Only the first character of this string will be searched for.
            ///    @param start The index into @a str at which to start searching for the given character.
            ///    @return The index of the first occurrence of @a chr in @a str or -1 if @a str does not contain the given character.
            ///    @tsexample
            ///    strchrpos( \"test\", \"s\" ) // Returns 2.
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strchrpos(string str, string chr, int start)
                {
                return m_ts.fn_strchrpos(str, chr, start);
                }

            /// <summary>
            /// Compares two strings using case-b>sensitive/b> comparison.
            ///    @param str1 The first string.
            ///    @param str2 The second string.
            ///    @return 0 if both strings are equal, a value 0 if the first character different in str1 has a smaller character code 
            ///       value than the character at the same position in str2, and a value >1 otherwise.
            ///    @tsexample
            ///    if( strcmp( %var, \"foobar\" ) == 0 )
            ///       echo( \"%var is equal to 'foobar'\" );
            ///    @endtsexample
            ///    @see stricmp
            ///    @see strnatcmp
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strcmp(string str1, string str2)
                {
                return m_ts.fn_strcmp(str1, str2);
                }

            /// <summary>
            /// Format the given value as a string using printf-style formatting.
            ///    @param format A printf-style format string.
            ///    @param value The value argument matching the given format string.
            ///    @tsexample
            ///    // Convert the given integer value to a string in a hex notation.
            ///    %hex = strformat( \"%x\", %value );
            ///    @endtsexample
            ///    @ingroup Strings
            ///    @see http://en.wikipedia.org/wiki/Printf )
            /// 
            /// </summary>
            public string strformat(string format, string value)
                {
                return m_ts.fn_strformat(format, value);
                }

            /// <summary>
            /// Compares two strings using case-b>insensitive/b> comparison.
            ///    @param str1 The first string.
            ///    @param str2 The second string.
            ///    @return 0 if both strings are equal, a value 0 if the first character different in str1 has a smaller character code 
            ///       value than the character at the same position in str2, and a value >0 otherwise.
            ///    @tsexample
            ///    if( stricmp( \"FOObar\", \"foobar\" ) == 0 )
            ///       echo( \"this is always true\" );
            ///    @endtsexample
            ///    @see strcmp
            ///    @see strinatcmp
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int stricmp(string str1, string str2)
                {
                return m_ts.fn_stricmp(str1, str2);
                }

            /// <summary>
            /// Compares two strings using \"natural order\" case-b>insensitive/b> comparison.
            ///    Natural order means that rather than solely comparing single character code values, strings are ordered in a 
            ///    natural way.  For example, the string \"hello10\" is considered greater than the string \"hello2\" even though 
            ///    the first numeric character in \"hello10\" actually has a smaller character value than the corresponding character 
            ///    in \"hello2\".  However, since 10 is greater than 2, strnatcmp will put \"hello10\" after \"hello2\".
            ///    @param str1 The first string.
            ///    @param str2 The second string.
            ///    @return 0 if the strings are equal, a value >0 if @a str1 comes after @a str2 in a natural order, and a value 
            ///       0 if @a str1 comes before @a str2 in a natural order.
            ///    @tsexample
            ///    // Bubble sort 10 elements of %array using natural order
            ///    do
            ///    {
            ///       %swapped = false;
            ///       for( %i = 0; %i  10 - 1; %i ++ )
            ///          if( strnatcmp( %array[ %i ], %array[ %i + 1 ] ) > 0 )
            ///          {
            ///             %temp = %array[ %i ];
            ///             %array[ %i ] = %array[ %i + 1 ];
            ///             %array[ %i + 1 ] = %temp;
            ///             %swapped = true;
            ///          }
            ///    }
            ///    while( %swapped );
            ///    @endtsexample
            ///    @see stricmp
            ///    @see strnatcmp
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strinatcmp(string str1, string str2)
                {
                return m_ts.fn_strinatcmp(str1, str2);
                }

            /// <summary>
            /// Remove all occurrences of characters contained in @a chars from @a str.
            ///    @param str The string to filter characters out from.
            ///    @param chars A string of characters to filter out from @a str.
            ///    @return A version of @a str with all occurrences of characters contained in @a chars filtered out.
            ///    @tsexample
            ///    stripChars( \"teststring\", \"se\" ); // Returns \"tttring\".
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string stripChars(string str, string chars)
                {
                return m_ts.fn_stripChars(str, chars);
                }

            /// <summary>
            /// @brief Strip TorqueML control characters from the specified string, returning a 'clean' version.
            /// 					 @param inString String to strip TorqueML control characters from.
            /// 					 @tsexample
            /// 					 // Define the string to strip TorqueML control characters from
            /// 					 %string = \"font:Arial:24>How Now color:c43c12>Brown color:000000>Cow\";
            /// 					 // Request the stripped version of the string
            /// 					 %strippedString = StripMLControlChars(%string);
            /// 					 @endtsexample
            /// 					 @return Version of the inputted string with all TorqueML characters removed.
            /// 					 @see References
            /// 					 @ingroup GuiCore)
            /// 
            /// </summary>
            public string StripMLControlChars(string inString)
                {
                return m_ts.fn_StripMLControlChars(inString);
                }

            /// <summary>
            /// Strip a numeric suffix from the given string.
            ///    @param str The string from which to strip its numeric suffix.
            ///    @return The string @a str without its number suffix or the original string @a str if it has no such suffix.
            ///    @tsexample
            ///    stripTrailingNumber( \"test123\" ) // Returns \"test\".
            ///    @endtsexample
            ///    @see getTrailingNumber
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string stripTrailingNumber(string str)
                {
                return m_ts.fn_stripTrailingNumber(str);
                }

            /// <summary>
            /// Match a pattern against a string.
            ///    @param pattern The wildcard pattern to match against.  The pattern can include characters, '*' to match 
            ///       any number of characters and '?' to match a single character.
            ///    @param str The string which should be matched against @a pattern.
            ///    @param caseSensitive If true, characters in the pattern are matched in case-sensitive fashion against 
            ///       this string.  If false, differences in casing are ignored.
            ///    @return True if @a str matches the given @a pattern.
            ///    @tsexample
            ///    strIsMatchExpr( \"f?o*R\", \"foobar\" ) // Returns true.
            ///    @endtsexample
            ///    @see strIsMatchMultipleExpr
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public bool strIsMatchExpr(string pattern, string str, bool caseSensitive)
                {
                return m_ts.fn_strIsMatchExpr(pattern, str, caseSensitive);
                }

            /// <summary>
            /// Match a multiple patterns against a single string.
            ///    @param patterns A tab-separated list of patterns.  Each pattern can include charaters, '*' to match 
            ///       any number of characters and '?' to match a single character.  Each of the patterns is tried in turn.
            ///    @param str The string which should be matched against @a patterns.
            ///    @param caseSensitive If true, characters in the pattern are matched in case-sensitive fashion against 
            ///       this string.  If false, differences in casing are ignored.
            ///    @return True if @a str matches any of the given @a patterns.
            ///    @tsexample
            ///    strIsMatchMultipleExpr( \"*.cs *.gui *.mis\", \"mymission.mis\" ) // Returns true.
            ///    @endtsexample
            ///    @see strIsMatchExpr
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public bool strIsMatchMultipleExpr(string patterns, string str, bool caseSensitive)
                {
                return m_ts.fn_strIsMatchMultipleExpr(patterns, str, caseSensitive);
                }

            /// <summary>
            /// Get the length of the given string in bytes.
            ///    @note This does b>not/b> return a true character count for strings with multi-byte characters!
            ///    @param str A string.
            ///    @return The length of the given string in bytes.
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strlen(string str)
                {
                return m_ts.fn_strlen(str);
                }

            /// <summary>
            /// Return an all lower-case version of the given string.
            ///    @param str A string.
            ///    @return A version of @a str with all characters converted to lower-case.
            ///    @tsexample
            ///    strlwr( \"TesT1\" ) // Returns \"test1\"
            ///    @endtsexample
            ///    @see strupr
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string strlwr(string str)
                {
                return m_ts.fn_strlwr(str);
                }

            /// <summary>
            /// Compares two strings using \"natural order\" case-b>sensitive/b> comparison.
            ///    Natural order means that rather than solely comparing single character code values, strings are ordered in a 
            ///    natural way.  For example, the string \"hello10\" is considered greater than the string \"hello2\" even though 
            ///    the first numeric character in \"hello10\" actually has a smaller character value than the corresponding character 
            ///    in \"hello2\".  However, since 10 is greater than 2, strnatcmp will put \"hello10\" after \"hello2\".
            ///    @param str1 The first string.
            ///    @param str2 The second string.
            ///    @return 0 if the strings are equal, a value >0 if @a str1 comes after @a str2 in a natural order, and a value 
            ///       0 if @a str1 comes before @a str2 in a natural order.
            ///    @tsexample
            ///    // Bubble sort 10 elements of %array using natural order
            ///    do
            ///    {
            ///       %swapped = false;
            ///       for( %i = 0; %i  10 - 1; %i ++ )
            ///          if( strnatcmp( %array[ %i ], %array[ %i + 1 ] ) > 0 )
            ///          {
            ///             %temp = %array[ %i ];
            ///             %array[ %i ] = %array[ %i + 1 ];
            ///             %array[ %i + 1 ] = %temp;
            ///             %swapped = true;
            ///          }
            ///    }
            ///    while( %swapped );
            ///    @endtsexample
            ///    @see strcmp
            ///    @see strinatcmp
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strnatcmp(string str1, string str2)
                {
                return m_ts.fn_strnatcmp(str1, str2);
                }

            /// <summary>
            /// Find the start of @a needle in @a haystack searching from left to right beginning at the given offset.
            ///    @param haystack The string to search.
            ///    @param needle The string to search for.
            ///    @return The index at which the first occurrence of @a needle was found in @a haystack or -1 if no match was found.
            ///    @tsexample
            ///    strpos( \"b ab\", \"b\", 1 ) // Returns 3.
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strpos(string haystack, string needle, int offset)
                {
                return m_ts.fn_strpos(haystack, needle, offset);
                }

            /// <summary>
            /// Find the last occurrence of the given character in @a str.
            ///    @param str The string to search.
            ///    @param chr The character to search for.  Only the first character from the string is taken.
            ///    @return The remainder of the input string starting with the given character or the empty string if the character could not be found.
            ///    @see strchr
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string strrchr(string str, string chr)
                {
                return m_ts.fn_strrchr(str, chr);
                }

            /// <summary>
            /// Find the last occurrence of the given character in the given string.
            ///    @param str The string to search.
            ///    @param chr The character to look for.  Only the first character of this string will be searched for.
            ///    @param start The index into @a str at which to start searching for the given character.
            ///    @return The index of the last occurrence of @a chr in @a str or -1 if @a str does not contain the given character.
            ///    @tsexample
            ///    strrchrpos( \"test\", \"t\" ) // Returns 3.
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strrchrpos(string str, string chr, int start)
                {
                return m_ts.fn_strrchrpos(str, chr, start);
                }

            /// <summary>
            ///  ),
            ///    Return a string that repeats @a str @a numTimes number of times delimiting each occurrence with @a delimiter.
            ///    @param str The string to repeat multiple times.
            ///    @param numTimes The number of times to repeat @a str in the result string.
            ///    @param delimiter The string to put between each repetition of @a str.
            ///    @return A string containing @a str repeated @a numTimes times.
            ///    @tsexample
            ///    strrepeat( \"a\", 5, \"b\" ) // Returns \"ababababa\".
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string strrepeat(string str, int numTimes, string delimiter)
                {
                return m_ts.fn_strrepeat(str, numTimes, delimiter);
                }

            /// <summary>
            /// Replace all occurrences of @a from in @a source with @a to.
            ///    @param source The string in which to replace the occurrences of @a from.
            ///    @param from The string to replace in @a source.
            ///    @param to The string with which to replace occurrences of @from.
            ///    @return A string with all occurrences of @a from in @a source replaced by @a to.
            ///    @tsexample
            ///    strreplace( \"aabbccbb\", \"bb\", \"ee\" ) // Returns \"aaeeccee\".
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string strreplace(string source, string from, string to)
                {
                return m_ts.fn_strreplace(source, from, to);
                }

            /// <summary>
            /// Find the start of @a substring in the given @a string searching from left to right.
            ///    @param string The string to search.
            ///    @param substring The string to search for.
            ///    @return The index into @a string at which the first occurrence of @a substring was found or -1 if @a substring could not be found.
            ///    @tsexample
            ///    strstr( \"abcd\", \"c\" ) // Returns 2.
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public int strstr(string xstring, string substring)
                {
                return m_ts.fn_strstr(xstring, substring);
                }

            /// <summary>
            /// Return an all upper-case version of the given string.
            ///    @param str A string.
            ///    @return A version of @a str with all characters converted to upper-case.
            ///    @tsexample
            ///    strupr( \"TesT1\" ) // Returns \"TEST1\"
            ///    @endtsexample
            ///    @see strlwr
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string strupr(string str)
                {
                return m_ts.fn_strupr(str);
                }

            /// <summary>
            /// Enable or disable tracing in the script code VM.
            ///    When enabled, the script code runtime will trace the invocation and returns 
            ///    from all functions that are called and log them to the console. This is helpful in 
            ///    observing the flow of the script program.
            ///    @param enable New setting for script trace execution, on by default.
            ///    @ingroup Debugging )
            /// 
            /// </summary>
            public void trace(bool enable)
                {
                m_ts.fn_trace(enable);
                }

            /// <summary>
            /// Remove leading and trailing whitespace from the string.
            ///    @param str A string.
            ///    @return A string that is the same as @a str but with any leading (i.e. leftmost) and trailing (i.e. rightmost) whitespace removed.
            ///    @tsexample
            ///    trim( \"   string  \" ); // Returns \"string\".
            ///    @endtsexample
            ///    @ingroup Strings )
            /// 
            /// </summary>
            public string trim(string str)
                {
                return m_ts.fn_trim(str);
                }

            /// <summary>
            /// Add two vectors.
            ///    @param a The first vector.
            ///    @param b The second vector.
            ///    @return The vector @a a + @a b.
            ///    @tsexample
            ///       //-----------------------------------------------------------------------------
            ///       //
            ///       // VectorAdd( %a, %b );
            ///       //
            ///       // The sum of vector a, (ax, ay, az), and vector b, (bx, by, bz) is:
            ///       //
            ///       //     a + b = ( ax + bx, ay + by, az + bz )
            ///       //
            ///       //-----------------------------------------------------------------------------
            ///       %a = \"1 0 0\";
            ///       %b = \"0 1 0\";
            ///       // %r = \"( 1 + 0, 0 + 1, 0 + 0 )\";
            ///       // %r = \"1 1 0\";
            ///       %r = VectorAdd( %a, %b );
            ///    @endtsexample
            ///    @ingroup Vectors)
            /// 
            /// </summary>
            public Point3F VectorAdd(Point3F a, Point3F b)
                {
                return new Point3F(m_ts.fn_VectorAdd(a.AsString(), b.AsString()));
                }

            /// <summary>
            /// Calculcate the cross product of two vectors.
            ///    @param a The first vector.
            ///    @param b The second vector.
            ///    @return The cross product @a x @a b.
            ///    @tsexample
            /// 	//-----------------------------------------------------------------------------
            /// 	//
            /// 	// VectorCross( %a, %b );
            /// 	//
            /// 	// The cross product of vector a, (ax, ay, az), and vector b, (bx, by, bz), is
            /// 	//
            /// 	//     a x b = ( ( ay * bz ) - ( az * by ), ( az * bx ) - ( ax * bz ), ( ax * by ) - ( ay * bx ) )
            /// 	//
            /// 	//-----------------------------------------------------------------------------
            /// 
            /// 	%a = \"1 1 0\";
            /// 	%b = \"2 0 1\";
            /// 
            /// 	// %r = \"( ( 1 * 1 ) - ( 0 * 0 ), ( 0 * 2 ) - ( 1 * 1 ), ( 1 * 0 ) - ( 1 * 2 ) )\";
            /// 	// %r = \"1 -1 -2\";
            /// 	%r = VectorCross( %a, %b );
            ///    @endtsexample	
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public Point3F VectorCross(Point3F a, Point3F b)
                {
                return new Point3F(m_ts.fn_VectorCross(a.AsString(), b.AsString()));
                }

            /// <summary>
            /// Compute the distance between two vectors.
            ///    @param a The first vector.
            ///    @param b The second vector.
            ///    @return The length( @a b - @a a ).
            ///    @tsexample
            /// 	//-----------------------------------------------------------------------------
            /// 	//
            /// 	// VectorDist( %a, %b );
            /// 	//
            /// 	// The distance between vector a, (ax, ay, az), and vector b, (bx, by, bz), is
            /// 	//
            /// 	//     a -> b = ||( b - a )||
            /// 	//            = ||( bx - ax, by - ay, bz - az )||
            /// 	//            = mSqrt( ( bx - ax ) * ( bx - ax ) + ( by - ay ) * ( by - ay ) + ( bz - az ) * ( bz - az ) )
            /// 	//
            /// 	//-----------------------------------------------------------------------------
            /// 
            /// 	%a = \"1 1 0\";
            /// 	%b = \"2 0 1\";
            /// 
            /// 	// %r = mSqrt( ( 2 - 1 ) * ( 2 - 1) + ( 0 - 1 ) * ( 0 - 1 ) + ( 1 - 0 ) * ( 1 - 0 ) );
            /// 	// %r = mSqrt( 3 );
            /// 	%r = VectorDist( %a, %b );
            ///    @endtsexample
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public float VectorDist(Point3F a, Point3F b)
                {
                return m_ts.fn_VectorDist(a.AsString(), b.AsString());
                }

            /// <summary>
            /// Compute the dot product of two vectors.
            ///    @param a The first vector.
            ///    @param b The second vector.
            ///    @return The dot product @a a * @a b.
            ///    @tsexample
            /// 	//-----------------------------------------------------------------------------
            /// 	//
            /// 	// VectorDot( %a, %b );
            /// 	//
            /// 	// The dot product between vector a, (ax, ay, az), and vector b, (bx, by, bz), is:
            /// 	//
            /// 	//     a . b = ( ax * bx + ay * by + az * bz )
            /// 	//
            /// 	//-----------------------------------------------------------------------------
            /// 
            /// 	%a = \"1 1 0\";
            /// 	%b = \"2 0 1\";
            /// 
            /// 	// %r = \"( 1 * 2 + 1 * 0 + 0 * 1 )\";
            /// 	// %r = 2;
            /// 	%r = VectorDot( %a, %b );
            ///    @endtsexample
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public float VectorDot(Point3F a, Point3F b)
                {
                return m_ts.fn_VectorDot(a.AsString(), b.AsString());
                }

            /// <summary>
            /// Calculate the magnitude of the given vector.
            ///    @param v A vector.
            ///    @return The length of vector @a v.
            ///    @tsexample
            /// 	//-----------------------------------------------------------------------------
            /// 	//
            /// 	// VectorLen( %a );
            /// 	//
            /// 	// The length or magnitude of  vector a, (ax, ay, az), is:
            /// 	//
            /// 	//     ||a|| = Sqrt( ax * ax + ay * ay + az * az )
            /// 	//
            /// 	//-----------------------------------------------------------------------------
            /// 
            /// 	%a = \"1 1 0\";
            /// 
            /// 	// %r = mSqrt( 1 * 1 + 1 * 1 + 0 * 0 );
            /// 	// %r = mSqrt( 2 );
            /// 	// %r = 1.414;
            /// 	%r = VectorLen( %a );
            ///    @endtsexample
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public float VectorLen(Point3F v)
                {
                return m_ts.fn_VectorLen(v.AsString());
                }

            /// <summary>
            /// Linearly interpolate between two vectors by @a t.
            ///    @param a Vector to start interpolation from.
            ///    @param b Vector to interpolate to.
            ///    @param t Interpolation factor (0-1).  At zero, @a a is returned and at one, @a b is returned.  In between, an interpolated vector 
            ///       between @a a and @a b is returned.
            ///    @return An interpolated vector between @a a and @a b.
            ///    @tsexample
            /// 	//-----------------------------------------------------------------------------
            /// 	//
            /// 	// VectorLerp( %a, %b );
            /// 	//
            /// 	// The point between vector a, (ax, ay, az), and vector b, (bx, by, bz), which is
            /// 	// weighted by the interpolation factor, t, is
            /// 	//
            /// 	//     r = a + t * ( b - a )
            /// 	//       = ( ax + t * ( bx - ax ), ay + t * ( by - ay ), az + t * ( bz - az ) )
            /// 	//
            /// 	//-----------------------------------------------------------------------------
            /// 
            /// 	%a = \"1 1 0\";
            /// 	%b = \"2 0 1\";
            /// 	%v = \"0.25\";
            /// 
            /// 	// %r = \"( 1 + 0.25 * ( 2 - 1 ), 1 + 0.25 * ( 0 - 1 ), 0 + 0.25 * ( 1 - 0 ) )\";
            /// 	// %r = \"1.25 0.75 0.25\";
            /// 	%r = VectorLerp( %a, %b );
            ///    @endtsexample
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public Point3F VectorLerp(Point3F a, Point3F b, float t)
                {
                return new Point3F(m_ts.fn_VectorLerp(a.AsString(), b.AsString(), t));
                }

            /// <summary>
            /// Brings a vector into its unit form, i.e. such that it has the magnitute 1.
            ///    @param v The vector to normalize.
            ///    @return The vector @a v scaled to length 1.
            ///    @tsexample
            /// 	//-----------------------------------------------------------------------------
            /// 	//
            /// 	// VectorNormalize( %a );
            /// 	//
            /// 	// The normalized vector a, (ax, ay, az), is:
            /// 	//
            /// 	//     a^ = a / ||a||
            /// 	//        = ( ax / ||a||, ay / ||a||, az / ||a|| )
            /// 	//
            /// 	//-----------------------------------------------------------------------------
            /// 
            /// 	%a = \"1 1 0\";
            /// 	%l = 1.414;
            /// 
            /// 	// %r = \"( 1 / 1.141, 1 / 1.141, 0 / 1.141 )\";
            /// 	// %r = \"0.707 0.707 0\";
            /// 	%r = VectorNormalize( %a );
            ///    @endtsexample
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public Point3F VectorNormalize(Point3F v)
                {
                return new Point3F(m_ts.fn_VectorNormalize(v.AsString()));
                }

            /// <summary>
            /// Create an orthogonal basis from the given vector.
            ///    @param aaf The vector to create the orthogonal basis from.
            ///    @return A matrix representing the orthogonal basis.
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public TransformF VectorOrthoBasis(AngAxisF aa)
                {
                return new TransformF(m_ts.fn_VectorOrthoBasis(aa.AsString()));
                }

            /// <summary>
            /// Scales a vector by a scalar.
            ///    @param a The vector to scale.
            ///    @param scalar The scale factor.
            ///    @return The vector @a a * @a scalar.
            ///    @tsexample
            /// 	//-----------------------------------------------------------------------------
            /// 	//
            /// 	// VectorScale( %a, %v );
            /// 	//
            /// 	// Scaling vector a, (ax, ay, az), but the scalar, v, is:
            /// 	//
            /// 	//     a * v = ( ax * v, ay * v, az * v )
            /// 	//
            /// 	//-----------------------------------------------------------------------------
            /// 
            /// 	%a = \"1 1 0\";
            /// 	%v = \"2\";
            /// 
            /// 	// %r = \"( 1 * 2, 1 * 2, 0 * 2 )\";
            /// 	// %r = \"2 2 0\";
            /// 	%r = VectorScale( %a, %v );
            ///    @endtsexample
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public Point3F VectorScale(Point3F a, float scalar)
                {
                return new Point3F(m_ts.fn_VectorScale(a.AsString(), scalar));
                }

            /// <summary>
            /// Subtract two vectors.
            ///    @param a The first vector.
            ///    @param b The second vector.
            ///    @return The vector @a a - @a b.
            ///    @tsexample
            /// 	//-----------------------------------------------------------------------------
            /// 	//
            /// 	// VectorSub( %a, %b );
            /// 	//
            /// 	// The difference of vector a, (ax, ay, az), and vector b, (bx, by, bz) is:
            /// 	//
            /// 	//     a - b = ( ax - bx, ay - by, az - bz )
            /// 	//
            /// 	//-----------------------------------------------------------------------------
            /// 
            /// 	%a = \"1 0 0\";
            /// 	%b = \"0 1 0\";
            /// 
            /// 	// %r = \"( 1 - 0, 0 - 1, 0 - 0 )\";
            /// 	// %r = \"1 -1 0\";
            /// 	%r = VectorSub( %a, %b );
            ///    @endtsexample
            ///    @ingroup Vectors )
            /// 
            /// </summary>
            public Point3F VectorSub(Point3F a, Point3F b)
                {
                return new Point3F(m_ts.fn_VectorSub(a.AsString(), b.AsString()));
                }

            /// <summary>
            /// Force all cached fonts to serialize themselves to the cache.
            ///    @ingroup Font )
            /// 
            /// </summary>
            public void writeFontCache()
                {
                m_ts.fn_writeFontCache();
                }
            }

        #endregion

        #region Nested type: WheeledVehicleObject

        /// <summary>
        /// 
        /// </summary>
        public class WheeledVehicleObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public WheeledVehicleObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Get the number of wheels on this vehicle.
            ///    @return the number of wheels (equal to the number of hub nodes defined in the model) )
            /// 
            /// </summary>
            public int getWheelCount(string wheeledvehicle)
                {
                return m_ts.fnWheeledVehicle_getWheelCount(wheeledvehicle);
                }

            /// <summary>
            /// @brief Set whether the wheel is powered (has torque applied from the engine).
            ///    A rear wheel drive car for example would set the front wheels to false, 
            ///    and the rear wheels to true.
            ///    @param wheel index of the wheel to set (hub node #)
            ///    @param powered flag indicating whether to power the wheel or not
            ///    @return true if successful, false if failed )
            /// 
            /// </summary>
            public bool setWheelPowered(string wheeledvehicle, int wheel, bool powered)
                {
                return m_ts.fnWheeledVehicle_setWheelPowered(wheeledvehicle, wheel, powered);
                }

            /// <summary>
            /// @brief Set the WheeledVehicleSpring datablock for this wheel.
            ///    @param wheel index of the wheel to set (hub node #)
            ///    @param spring WheeledVehicleSpring datablock
            ///    @return true if successful, false if failed
            ///    @tsexample
            ///    %obj.setWheelSpring( 0, FrontSpring );
            ///    @endtsexample )
            /// 
            /// </summary>
            public bool setWheelSpring(string wheeledvehicle, int wheel, string spring)
                {
                return m_ts.fnWheeledVehicle_setWheelSpring(wheeledvehicle, wheel, spring);
                }

            /// <summary>
            /// @brief Set how much the wheel is affected by steering.
            ///    The steering factor controls how much the wheel is rotated by the vehicle 
            ///    steering. For example, most cars would have their front wheels set to 1.0, 
            ///    and their rear wheels set to 0 since only the front wheels should turn.
            ///    Negative values will turn the wheel in the opposite direction to the steering 
            ///    angle.
            ///    @param wheel index of the wheel to set (hub node #)
            ///    @param steering steering factor from -1 (full inverse) to 1 (full)
            ///    @return true if successful, false if failed )
            /// 
            /// </summary>
            public bool setWheelSteering(string wheeledvehicle, int wheel, float steering)
                {
                return m_ts.fnWheeledVehicle_setWheelSteering(wheeledvehicle, wheel, steering);
                }

            /// <summary>
            /// @brief Set the WheeledVehicleTire datablock for this wheel.
            ///    @param wheel index of the wheel to set (hub node #)
            ///    @param tire WheeledVehicleTire datablock
            ///    @return true if successful, false if failed
            ///    @tsexample
            ///    %obj.setWheelTire( 0, FrontTire );
            ///    @endtsexample )
            /// 
            /// </summary>
            public bool setWheelTire(string wheeledvehicle, int wheel, string tire)
                {
                return m_ts.fnWheeledVehicle_setWheelTire(wheeledvehicle, wheel, tire);
                }
            }

        #endregion

        #region Nested type: WorldEditorObject

        /// <summary>
        /// 
        /// </summary>
        public class WorldEditorObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public WorldEditorObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// ( WorldEditor, addUndoState, void, 2, 2, )
            /// 
            /// </summary>
            public void addUndoState(string worldeditor = "")
                {
                m_ts.fnWorldEditor_addUndoState(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, alignByAxis, void, 3, 3, (int axis)
            ///               Align all selected objects along the given axis.)
            /// 
            /// </summary>
            public void alignByAxis(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_alignByAxis(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, alignByBounds, void, 3, 3, (int boundsAxis)
            ///               Align all selected objects against the given bounds axis.)
            /// 
            /// </summary>
            public void alignByBounds(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_alignByBounds(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, canPasteSelection, bool, 2, 2, )
            /// 
            /// </summary>
            public bool canPasteSelection(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_canPasteSelection(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, clearIgnoreList, void, 2, 2, )
            /// 
            /// </summary>
            public void clearIgnoreList(string worldeditor = "")
                {
                m_ts.fnWorldEditor_clearIgnoreList(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, clearSelection, void, 2, 2, )
            /// 
            /// </summary>
            public void clearSelection(string worldeditor = "")
                {
                m_ts.fnWorldEditor_clearSelection(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, colladaExportSelection, void, 3, 3, 
            ///               ( String path ) - Export the combined geometry of all selected objects to the specified path in collada format. )
            /// 
            /// </summary>
            public void colladaExportSelection(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_colladaExportSelection(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, copySelection, void, 2, 2, )
            /// 
            /// </summary>
            public void copySelection(string worldeditor = "")
                {
                m_ts.fnWorldEditor_copySelection(worldeditor);
                }

            /// <summary>
            /// Create a ConvexShape from the given polyhedral object. )
            /// 
            /// </summary>
            public string createConvexShapeFrom(string worldeditor, string polyObject)
                {
                return m_ts.fnWorldEditor_createConvexShapeFrom(worldeditor, polyObject);
                }

            /// <summary>
            /// Grab the geometry from @a geometryProvider, create a @a className object, and assign it the extracted geometry. )
            /// 
            /// </summary>
            public string createPolyhedralObject(string worldeditor, string className, string geometryProvider)
                {
                return m_ts.fnWorldEditor_createPolyhedralObject(worldeditor, className, geometryProvider);
                }

            /// <summary>
            /// ( WorldEditor, cutSelection, void, 2, 2, )
            /// 
            /// </summary>
            public void cutSelection(string worldeditor = "")
                {
                m_ts.fnWorldEditor_cutSelection(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, dropSelection, void, 2, 3, ( bool skipUndo = false ))
            /// 
            /// </summary>
            public void dropSelection(string worldeditor = "", string a2 = "")
                {
                m_ts.fnWorldEditor_dropSelection(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, explodeSelectedPrefab, void, 2, 2, () - Replace selected Prefab objects with a SimGroup containing all children objects defined in the .prefab. )
            /// 
            /// </summary>
            public void explodeSelectedPrefab(string worldeditor = "")
                {
                m_ts.fnWorldEditor_explodeSelectedPrefab(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, getActiveSelection, S32, 2, 2, () - Return the currently active WorldEditorSelection object. )
            /// 
            /// </summary>
            public int getActiveSelection(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_getActiveSelection(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, getSelectedObject, S32, 3, 3, (int index))
            /// 
            /// </summary>
            public int getSelectedObject(string worldeditor, string a2 = "")
                {
                return m_ts.fnWorldEditor_getSelectedObject(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, getSelectionCentroid, const char *, 2, 2, )
            /// 
            /// </summary>
            public string getSelectionCentroid(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_getSelectionCentroid(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, getSelectionExtent, const char *, 2, 2, )
            /// 
            /// </summary>
            public string getSelectionExtent(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_getSelectionExtent(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, getSelectionRadius, F32, 2, 2, )
            /// 
            /// </summary>
            public float getSelectionRadius(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_getSelectionRadius(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, getSelectionSize, S32, 2, 2, () - Return the number of objects currently selected in the editor.)
            /// 
            /// </summary>
            public int getSelectionSize(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_getSelectionSize(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, getSoftSnap, bool, 2, 2, getSoftSnap()
            ///               Is soft snapping always on?)
            /// 
            /// </summary>
            public bool getSoftSnap(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_getSoftSnap(worldeditor);
                }

            /// <summary>
            /// Get the soft snap alignment. )
            /// 
            /// </summary>
            public WorldEditor__AlignmentType getSoftSnapAlignment(string worldeditor)
                {
                return (WorldEditor__AlignmentType) (m_ts.fnWorldEditor_getSoftSnapAlignment(worldeditor));
                }

            /// <summary>
            /// ( WorldEditor, getSoftSnapBackfaceTolerance, F32, 2, 2, getSoftSnapBackfaceTolerance()
            ///               The fraction of the soft snap radius that backfaces may be included.)
            /// 
            /// </summary>
            public float getSoftSnapBackfaceTolerance(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_getSoftSnapBackfaceTolerance(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, getSoftSnapSize, F32, 2, 2, getSoftSnapSize()
            ///               Get the absolute size to trigger a soft snap.)
            /// 
            /// </summary>
            public float getSoftSnapSize(string worldeditor = "")
                {
                return m_ts.fnWorldEditor_getSoftSnapSize(worldeditor);
                }

            /// <summary>
            /// Get the terrain snap alignment.  )
            /// 
            /// </summary>
            public WorldEditor__AlignmentType getTerrainSnapAlignment(string worldeditor)
                {
                return (WorldEditor__AlignmentType) (m_ts.fnWorldEditor_getTerrainSnapAlignment(worldeditor));
                }

            /// <summary>
            /// ( WorldEditor, hideObject, void, 4, 4, (Object obj, bool hide))
            /// 
            /// </summary>
            public void hideObject(string worldeditor, string a2, string a3 = "")
                {
                m_ts.fnWorldEditor_hideObject(worldeditor, a2, a3);
                }

            /// <summary>
            /// ( WorldEditor, hideSelection, void, 3, 3, (bool hide))
            /// 
            /// </summary>
            public void hideSelection(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_hideSelection(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, ignoreObjClass, void, 3, 0, (string class_name, ...))
            /// 
            /// </summary>
            public void ignoreObjClass(string worldeditor, string a2 = "", string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
                {
                m_ts.fnWorldEditor_ignoreObjClass(worldeditor, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                }

            /// <summary>
            /// ( WorldEditor, invalidateSelectionCentroid, void, 2, 2, )
            /// 
            /// </summary>
            public void invalidateSelectionCentroid(string worldeditor = "")
                {
                m_ts.fnWorldEditor_invalidateSelectionCentroid(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, lockSelection, void, 3, 3, (bool lock))
            /// 
            /// </summary>
            public void lockSelection(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_lockSelection(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, makeSelectionPrefab, void, 3, 3, ( string filename ) - Save selected objects to a .prefab file and replace them in the level with a Prefab object. )
            /// 
            /// </summary>
            public void makeSelectionPrefab(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_makeSelectionPrefab(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, mountRelative, void, 4, 4, ( Object A, Object B ) )
            /// 
            /// </summary>
            public void mountRelative(string worldeditor, string a2, string a3 = "")
                {
                m_ts.fnWorldEditor_mountRelative(worldeditor, a2, a3);
                }

            /// <summary>
            /// ( WorldEditor, pasteSelection, void, 2, 2, )
            /// 
            /// </summary>
            public void pasteSelection(string worldeditor = "")
                {
                m_ts.fnWorldEditor_pasteSelection(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, redirectConsole, void, 3, 3, ( int objID ))
            /// 
            /// </summary>
            public void redirectConsole(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_redirectConsole(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, resetSelectedRotation, void, 2, 2, )
            /// 
            /// </summary>
            public void resetSelectedRotation(string worldeditor = "")
                {
                m_ts.fnWorldEditor_resetSelectedRotation(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, resetSelectedScale, void, 2, 2, )
            /// 
            /// </summary>
            public void resetSelectedScale(string worldeditor = "")
                {
                m_ts.fnWorldEditor_resetSelectedScale(worldeditor);
                }

            /// <summary>
            /// ( WorldEditor, selectObject, void, 3, 3, (SimObject obj))
            /// 
            /// </summary>
            public void selectObject(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_selectObject(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, setActiveSelection, void, 3, 3, ( id set ) - Set the currently active WorldEditorSelection object. )
            /// 
            /// </summary>
            public void setActiveSelection(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_setActiveSelection(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, setSoftSnap, void, 3, 3, setSoftSnap(bool)
            ///               Allow soft snapping all of the time.)
            /// 
            /// </summary>
            public void setSoftSnap(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_setSoftSnap(worldeditor, a2);
                }

            /// <summary>
            /// Set the soft snap alignment. )
            /// 
            /// </summary>
            public void setSoftSnapAlignment(string worldeditor, WorldEditor__AlignmentType type)
                {
                m_ts.fnWorldEditor_setSoftSnapAlignment(worldeditor, (int) type);
                }

            /// <summary>
            /// ( WorldEditor, setSoftSnapBackfaceTolerance, void, 3, 3, setSoftSnapBackfaceTolerance(F32 with range of 0..1)
            ///               The fraction of the soft snap radius that backfaces may be included.)
            /// 
            /// </summary>
            public void setSoftSnapBackfaceTolerance(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_setSoftSnapBackfaceTolerance(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, setSoftSnapSize, void, 3, 3, setSoftSnapSize(F32)
            ///               Set the absolute size to trigger a soft snap.)
            /// 
            /// </summary>
            public void setSoftSnapSize(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_setSoftSnapSize(worldeditor, a2);
                }

            /// <summary>
            /// Set the terrain snap alignment. )
            /// 
            /// </summary>
            public void setTerrainSnapAlignment(string worldeditor, WorldEditor__AlignmentType alignment)
                {
                m_ts.fnWorldEditor_setTerrainSnapAlignment(worldeditor, (int) alignment);
                }

            /// <summary>
            /// ( WorldEditor, softSnapDebugRender, void, 3, 3, softSnapDebugRender(bool)
            ///               Toggle soft snapping debug rendering.)
            /// 
            /// </summary>
            public void softSnapDebugRender(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_softSnapDebugRender(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, softSnapRender, void, 3, 3, softSnapRender(bool)
            ///               Render the soft snapping bounds.)
            /// 
            /// </summary>
            public void softSnapRender(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_softSnapRender(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, softSnapRenderTriangle, void, 3, 3, softSnapRenderTriangle(bool)
            ///               Render the soft snapped triangle.)
            /// 
            /// </summary>
            public void softSnapRenderTriangle(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_softSnapRenderTriangle(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, softSnapSizeByBounds, void, 3, 3, softSnapSizeByBounds(bool)
            ///               Use selection bounds size as soft snap bounds.)
            /// 
            /// </summary>
            public void softSnapSizeByBounds(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_softSnapSizeByBounds(worldeditor, a2);
                }

            /// <summary>
            /// ( WorldEditor, transformSelection, void, 13, 13, transformSelection(...)
            ///               Transform selection by given parameters.)
            /// 
            /// </summary>
            public void transformSelection(string worldeditor, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12 = "")
                {
                m_ts.fnWorldEditor_transformSelection(worldeditor, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
                }

            /// <summary>
            /// ( WorldEditor, unselectObject, void, 3, 3, (SimObject obj))
            /// 
            /// </summary>
            public void unselectObject(string worldeditor, string a2 = "")
                {
                m_ts.fnWorldEditor_unselectObject(worldeditor, a2);
                }
            }

        #endregion

        #region Nested type: ZipObjectObject

        /// <summary>
        /// 
        /// </summary>
        public class ZipObjectObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ZipObjectObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// @brief Add a file to the zip archive
            ///    
            ///    @param filename The path and name of the file to add to the zip archive.
            ///    @param pathInZip The path and name to be given to the file within the zip archive.
            ///    @param replace If a file already exists within the zip archive at the same location as this 
            ///    new file, this parameter indicates if it should be replaced.  By default, it will be replaced.
            ///    @return True if the file was successfully added to the zip archive.)
            /// 
            /// </summary>
            public bool addFile(string zipobject, string filename, string pathInZip, bool replace)
                {
                return m_ts.fnZipObject_addFile(zipobject, filename, pathInZip, replace);
                }

            /// <summary>
            /// @brief Close an already opened zip archive.
            ///    @see openArchive())
            /// 
            /// </summary>
            public void closeArchive(string zipobject)
                {
                m_ts.fnZipObject_closeArchive(zipobject);
                }

            /// <summary>
            /// @brief Close a previously opened file within the zip archive.
            ///    @param stream The StreamObject of a previously opened file within the zip archive.
            ///    @see openFileForRead()
            ///    @see openFileForWrite())
            /// 
            /// </summary>
            public void closeFile(string zipobject, string stream)
                {
                m_ts.fnZipObject_closeFile(zipobject, stream);
                }

            /// <summary>
            /// @brief Deleted the given file from the zip archive
            ///    @param pathInZip The path and name of the file to be deleted from the zip archive.
            ///    @return True of the file was successfully deleted.
            /// 
            ///    @note Files that have been deleted from the archive will still show up with a 
            ///    getFileEntryCount() until you close the archive.  If you need to have the file 
            ///    count up to date with only valid files within the archive, you could close and then 
            ///    open the archive again.
            /// 
            ///    @see getFileEntryCount()
            ///    @see closeArchive()
            ///    @see openArchive())
            /// 
            /// </summary>
            public bool deleteFile(string zipobject, string pathInZip)
                {
                return m_ts.fnZipObject_deleteFile(zipobject, pathInZip);
                }

            /// <summary>
            /// @brief Extact a file from the zip archive and save it to the requested location.
            ///    @param pathInZip The path and name of the file to be extracted within the zip archive.
            ///    @param filename The path and name to give the extracted file.
            ///    @return True if the file was successfully extracted.)
            /// 
            /// </summary>
            public bool extractFile(string zipobject, string pathInZip, string filename)
                {
                return m_ts.fnZipObject_extractFile(zipobject, pathInZip, filename);
                }

            /// <summary>
            /// @brief Get information on the requested file within the zip archive.
            /// 
            ///    This methods provides five different pieces of information for the requested file:
            ///    ul>li>filename - The path and name of the file within the zip archive/li>
            ///    li>uncompressed size/li>
            ///    li>compressed size/li>
            ///    li>compression method/li>
            ///    li>CRC32/li>/ul>
            /// 
            ///    Use getFileEntryCount() to obtain the total number of files within the archive.
            /// 
            ///    @param index The index of the file within the zip archive.  Use getFileEntryCount() to determine the number of files.
            ///    @return A tab delimited list of information on the requested file, or an empty string if the file could not be found.
            /// 
            ///    @see getFileEntryCount())
            /// 
            /// </summary>
            public string getFileEntry(string zipobject, int index)
                {
                return m_ts.fnZipObject_getFileEntry(zipobject, index);
                }

            /// <summary>
            /// @brief Get the number of files within the zip archive.
            /// 
            ///    Use getFileEntry() to retrive information on each file within the archive.
            /// 
            ///    @return The number of files within the zip archive.
            /// 
            ///    @note The returned count will include any files that have been deleted from 
            ///    the archive using deleteFile().  To clear out all deleted files, you could 
            ///    close and then open the archive again.
            /// 
            ///    @see getFileEntry()
            ///    @see closeArchive()
            ///    @see openArchive())
            /// 
            /// </summary>
            public int getFileEntryCount(string zipobject)
                {
                return m_ts.fnZipObject_getFileEntryCount(zipobject);
                }

            /// <summary>
            /// read ),
            ///    @brief Open a zip archive for manipulation.
            /// 
            ///    Once a zip archive is opened use the various ZipObject methods for 
            ///    working with the files within the archive.  Be sure to close the archive when 
            ///    you are done with it.
            /// 
            ///    @param filename The path and file name of the zip archive to open.
            ///    @param accessMode One of read, write or readwrite
            /// 
            ///    @return True is the archive was successfully opened.
            ///    
            ///    @note If you wish to make any changes to the archive, be sure to open it 
            ///    with a write or readwrite access mode.
            /// 
            ///    @see closeArchive())
            /// 
            /// </summary>
            public bool openArchive(string zipobject, string filename, string accessMode)
                {
                return m_ts.fnZipObject_openArchive(zipobject, filename, accessMode);
                }

            /// <summary>
            /// @brief Open a file within the zip archive for reading.
            /// 
            ///    Be sure to close the file when you are done with it.
            /// 
            ///    @param filename The path and name of the file to open within the zip archive.
            /// 
            ///    @return A standard StreamObject is returned for working with the file.
            ///    @note You must first open the zip archive before working with files within it.
            /// 
            ///    @see closeFile()
            ///    @see openArchive())
            /// 
            /// </summary>
            public string openFileForRead(string zipobject, string filename)
                {
                return m_ts.fnZipObject_openFileForRead(zipobject, filename);
                }

            /// <summary>
            /// @brief Open a file within the zip archive for writing to.
            ///    
            ///    Be sure to close the file when you are done with it.
            /// 
            ///    @param filename The path and name of the file to open within the zip archive.
            /// 
            ///    @return A standard StreamObject is returned for working with the file.
            ///    @note You must first open the zip archive before working with files within it.
            /// 
            ///    @see closeFile()
            ///    @see openArchive())
            /// 
            /// </summary>
            public string openFileForWrite(string zipobject, string filename)
                {
                return m_ts.fnZipObject_openFileForWrite(zipobject, filename);
                }
            }

        #endregion

        #region Nested type: ZoneObject

        /// <summary>
        /// 
        /// </summary>
        public class ZoneObject
            {
            private dnTorque m_ts;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="ts"></param> 
            public ZoneObject(ref dnTorque ts)
                {
                m_ts = ts;
                }

            /// <summary>
            /// Dump a list of all objects assigned to the zone to the console as well as a list 
            ///    of all connected zone spaces.
            ///    @param updateFirst Whether to update the contents of the zone before dumping.  Since zoning states of 
            ///       objects are updated on demand, the zone contents can be outdated. )
            /// 
            /// </summary>
            public void dumpZoneState(string zone, bool updateFirst)
                {
                m_ts.fnZone_dumpZoneState(zone, updateFirst);
                }

            /// <summary>
            /// Get the unique numeric ID of the zone in its scene.
            ///    @return The ID of the zone. )
            /// 
            /// </summary>
            public int getZoneId(string zone)
                {
                return m_ts.fnZone_getZoneId(zone);
                }
            }

        #endregion

        #region Nested type: mbglobals

        /// <summary>
        /// 
        /// </summary>
        public class mbglobals
            {
            /// <summary>
            /// /
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            public bool this[string key]
                {
                get { return m_ts.GetVar(key).AsBool(); }
                set { m_ts.SetVar(key, value); }
                }
            }

        #endregion

        #region Nested type: mdglobals

        /// <summary>
        /// 
        /// </summary>
        public class mdglobals
            {
            /// <summary>
            /// /
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            public double this[string key]
                {
                get { return m_ts.GetVar(key).AsDouble(); }
                set { m_ts.SetVar(key, value); }
                }
            }

        #endregion

        #region Nested type: mfglobals

        /// <summary>
        /// 
        /// </summary>
        public class mfglobals
            {
            /// <summary>
            /// /
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            public float this[string key]
                {
                get { return m_ts.GetVar(key).AsFloat(); }
                set { m_ts.SetVar(key, value); }
                }
            }

        #endregion

        #region Nested type: mglobalsIsDefined

        /// <summary>
        /// 
        /// </summary>
        public class mglobalsIsDefined
            {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            public bool this[string key]
                {
                get { return m_ts.fn__isDefined(key, ""); }
                }
            }

        #endregion

        #region Nested type: miglobals

        /// <summary>
        /// 
        /// </summary>
        public class miglobals
            {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            public int this[string key]
                {
                get { return m_ts.GetVar(key).AsInt(); }
                set { m_ts.SetVar(key, value); }
                }
            }

        #endregion

        #region Nested type: msglobals

        /// <summary>
        /// 
        /// </summary>
        public class msglobals
            {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            public string this[string key]
                {
                get { return m_ts.GetVar(key); }
                set { m_ts.SetVar(key, value); }
                }
            }

        #endregion
        }
    }
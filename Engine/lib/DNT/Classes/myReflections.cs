// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;

#endregion

namespace WinterLeaf.Classes
    {
    internal static class myReflections
        {
        #region "Reflection Helpers"

        /// <summary>
        ///   The Microsoft ChangeType method doesn't always work, especially when your dealling with constructor base object types. or, when your trying to deal with enumerations. This function overrides the buggy ones Microsoft wrote with work arounds, and leaves the functioning Microsoft ones in tack.
        /// </summary>
        /// <param name="value"> The value to be converted </param>
        /// <param name="type"> The target type </param>
        /// <returns>The passed object as the target type. </returns>
        /// 
        internal static object ChangeType(object value, Type type)
            {
            if (value == null)
                return null;
            if (value.GetType() == typeof (tsObject))
                value = ((tsObject) value)._mSimObjectId;
            object r = value;
            if (type == typeof (float))
                {
                double retval = (double) _ChangeType(value, typeof (double));
                return (float) retval;
                }
            return _ChangeType(value, type);
            }


        internal static object _ChangeType(object value, Type type)
            {
            if (type == typeof (bool) && value is string)
                return ((string) value).AsBool();
            if (value.GetType() == type)
                return value;
            if (type == null)
                return value;
            if (type == value.GetType())
                return value;
            if (type.IsEnum)
                {
                if (value is string)
                    return Enum.Parse(type, value as string, true);
                else
                    return Enum.ToObject(type, value);
                }
            if (!type.IsInterface && type.IsGenericType)
                {
                Type innerType = type.GetGenericArguments()[0];
                object innerValue = ChangeType(value, innerType);
                return Activator.CreateInstance(type, new[] {innerValue});
                }
            if (value is string && type == typeof (Guid))
                return new Guid(value as string);
            if (value is string && type == typeof (Version))
                return new Version(value as string);
            if (!(value is IConvertible))
                return value;

            if (value is string && !type.IsPrimitive)
                {
                try
                    {
                    TypeConverter conv = TypeDescriptor.GetConverter(type);
                    value = conv.ConvertFromInvariantString((string) value);
                    return value;
                    }
                catch (Exception)
                    {
                    }
                }

            if (value is string)
                if ((value.ToString().Trim() == "") && ((type == typeof (decimal)) || (type == typeof (double)) || (type == typeof (float)) || (type == typeof (int)) || (type == typeof (long)) || (type == typeof (short)) || (type == typeof (uint)) || (type == typeof (ulong)) || (type == typeof (ushort))))
                    {
                    value = "0";
                    }


            return Convert.ChangeType(value, type, CultureInfo.InvariantCulture);
            }

        /// <summary>
        ///   Returns the value of the property requested using reflections
        /// </summary>
        /// <param name="o"> The object to inspect </param>
        /// <param name="property"> The property to retrieve. </param>
        /// <returns> </returns>
        internal static PropertyInfo GetProperty(object o, string property)
            {
            PropertyInfo retpi = null;
            retpi = o.GetType().GetProperty(property);
            if (retpi == null)
                {
                foreach (PropertyInfo pi in o.GetType().GetProperties().Where(pi => pi.Name.ToLower() == property.ToLower()))
                    {
                    retpi = pi;
                    break;
                    }
                }
            return retpi;
            }

        /// <summary>
        ///   Returns a MethodInfo record for the request method(kinda like a function pointer)
        /// </summary>
        /// <param name="o"> The object to inspect </param>
        /// <param name="property"> The method to find. </param>
        /// <returns> </returns>
        internal static MethodInfo GetMethod(object o, string property)
            {
            MethodInfo retmi = null;
            retmi = o.GetType().GetMethod(property);
            if (retmi == null)
                {
                foreach (MethodInfo mi in o.GetType().GetMethods().Where(mi => mi.Name.ToLower() == property.ToLower()))
                    {
                    retmi = mi;
                    break;
                    }
                }
            return retmi;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
        /// <param name="o"></param>
        /// <param name="mi"></param>
        /// <param name="tparams"></param>
        /// <returns></returns>
        internal static object MethodCall(string key, object o, MethodInfo mi, string tparams)
            {
            bool ignorecomma = false;
            string tp1 = "";
            char lc = ' ';

            #region "Parse Params

            List<string> myparams = new List<string>();
            foreach (Char c in tparams)
                {
                if (c == '"' && (lc != '\\'))
                    {
                    ignorecomma = !ignorecomma;
                    }
                if ((c == ',') && (!ignorecomma))
                    {
                    myparams.Add(tp1.Trim());
                    tp1 = "";
                    }
                else
                    tp1 += c;
                lc = c;
                }
            //if it's empty params, then lets not add it to the collect.
            if (tp1 != "")
                myparams.Add(tp1.Trim());

            #endregion

            if (mi != null)
                {
                List<object> passargs = new List<object>();
                int counter = 0;
                foreach (ParameterInfo pi in mi.GetParameters())
                    {
                    Type targettype = pi.ParameterType;
                    object castedvalue = ChangeType(myparams[counter], targettype);
                    if (targettype == typeof (string))
                        {
                        if (((string) castedvalue).Length >= 2)
                            {
                            castedvalue = ((string) castedvalue).Substring(1);
                            castedvalue = ((string) castedvalue).Substring(0, ((string) castedvalue).Length - 1);
                            }
                        }
                    passargs.Add(castedvalue);
                    counter++;
                    }
                try
                    {
                    o = mi.Invoke(o, passargs.ToArray()) ?? "";
                    }
                catch (Exception s)
                    {
                    return string.Format("Error " + s.Message);
                    }
                }
            else
                {
                return string.Format("Syntax Error (Unable to find method '{0}' Function.)", key);
                }
            //Console.WriteLine("------------------------------------------------>End " + mi.Name + " output: '" + o.ToString() + "'");
            return o;
            }


        internal static object MethodCall(object o, MethodInfo mi, string[] tparams, ParameterInfo[] lpi)
            {
            List<object> passargs = new List<object>();

            for (int i = 0; i < lpi.Count(); i++)
                passargs.Add(ChangeType(tparams[i], lpi[i].ParameterType));

            try
                {
                o = mi.Invoke(o, passargs.ToArray()) ?? "";
                }
            catch (Exception s)
                {
                return string.Format("Error " + s.Message);
                }

            return o;
            }


        /// <summary>
        ///   This function takes a string of csharp code and walks the object. So assuming you have a complex class and you wanted to walk down a couple properties to a member function, you can pass. Object (Complex class instance) method ->mycomplexclass.aProperty.nestedProperty.someMemberFunction().anothernestedproperty.yetanothermemberfunction() and it will return the final value to the caller. If it fails, it will return the walk stack and the error.
        /// </summary>
        /// <param name="walkpath"> </param>
        /// <param name="o"> </param>
        /// <returns> </returns>
        internal static object ResolveObject(string walkpath, object o)
            {
            // object o = m_classinstance;
            //if the instance = null then lets exit out.
            if (o == null)
                return "Object is null!";
            List<string> myparts = new List<string>();
            bool ignoreperiod = false;
            string tp = "";
            char lastchar = ' ';

            #region "Parse String into Parts"

            foreach (Char c in walkpath)
                {
                if ((c == '"') && (lastchar != '\\'))
                    ignoreperiod = !ignoreperiod;
                if ((c == '.') && (!ignoreperiod))
                    {
                    myparts.Add(tp);
                    tp = "";
                    }
                else
                    tp += c;
                lastchar = c;
                }
            myparts.Add(tp);

            #endregion

            foreach (string p in myparts)
                {
                if (o == null)
                    return "syntax error (property Name: " + walkpath + ")";
                if (p.IndexOf('[') >= 0)
                    {
                    #region "Code to handle arrays and collections"

                    //We are dealing with either an array or a collection.
                    //lets talk shop here, if the character following the [ is a number.. then it's an array.
                    // else it's a collection.
                    int indexofbracStart = p.IndexOf('[');
                    int indexofbracEnd = p.IndexOf(']');
                    string wordpart = p.Substring(0, indexofbracStart);

                    string middle = p.Substring(indexofbracStart + 1, (indexofbracEnd - 1) - indexofbracStart);

                    PropertyInfo pi = GetProperty(o, wordpart);
                    if (pi != null)
                        {
                            {
                            o = pi.GetValue(o, null);
                            Type baseType = o.GetType().BaseType;
                            if (baseType != null && baseType.Name == "Array")

                                #region "Array Handler"

                                {
                                int idx = -1;
                                if (!int.TryParse(middle, out idx))
                                    {
                                    return "Syntax Error (Type is an array, but the index is not a int.)";
                                    }
                                else
                                    {
                                    if (idx < 0)
                                        {
                                        return "Syntax Error ('Type is an array, but the index is less than zero!.')";
                                        }
                                    object[] castarray = (object[]) o;
                                    try
                                        {
                                        o = castarray[idx];
                                        }
                                    catch (Exception err)
                                        {
                                        string errortext = err.Message;
                                        if (err.StackTrace != null)
                                            errortext += err.StackTrace;
                                        if (err.InnerException != null)
                                            errortext += err.InnerException;
                                        return string.Format("Syntax Error ({0})", errortext);
                                        }
                                    }
                                }
                                #endregion

                            else
                                #region "Generic's Handler"

                                {
                                MethodInfo mi = o.GetType().GetMethod("get_Item");
                                //Lets see if the get_item function exists... if it does than it is a generic.
                                if (mi == null)
                                    {
                                    return "Syntax Error (Unable to find 'get_Item' Function, is object a generic?)";
                                    }
                                else
                                    {
                                    Type paramtype = mi.GetParameters()[0].ParameterType;
                                    //If the param type is a string, lets rip off the starting and ending "
                                    if (paramtype == typeof (string))
                                        {
                                        middle = middle.Substring(1);
                                        middle = middle.Substring(0, middle.Length - 1);
                                        }
                                    object castedvalue = ChangeType(middle, paramtype);
                                    o = mi.Invoke(o, new[] {castedvalue});
                                    }
                                }

                            #endregion
                            }
                        }

                    #endregion
                    }
                else
                    {
                    if (p.IndexOf("(", StringComparison.Ordinal) == -1)
                        {
                        //Is this a standard get statement?
                        if (p.IndexOf("=", StringComparison.Ordinal) == -1)
                            {
                            #region "Standard child stuff"

                            PropertyInfo pi = GetProperty(o, p);
                            if (pi != null)
                                o = pi.GetValue(o, null);
                            else
                                return string.Format("Syntax Error (Unable to find property {0})", p);
                            }
                        else
                            {
                            try
                                {
                                string rproperty = "";
                                string value = "";
                                rproperty = p.Substring(0, p.IndexOf("=", StringComparison.Ordinal));
                                value = p.Substring(p.IndexOf("=", StringComparison.Ordinal) + 1);
                                if (value.EndsWith(";"))
                                    value = value.Substring(0, value.Length - 1);

                                PropertyInfo pi = GetProperty(o, rproperty);
                                Type targettype = pi.PropertyType;
                                object castedvalue = ChangeType(value, targettype);
                                if (targettype == typeof (string))
                                    {
                                    if (castedvalue.ToString().Length >= 2)
                                        if ((((string) castedvalue)[0] == '\"') && (((string) castedvalue)[((string) castedvalue).Length - 1] == '\"'))
                                            {
                                            castedvalue = ((string) castedvalue).Substring(1);
                                            castedvalue = ((string) castedvalue).Substring(0, ((string) castedvalue).Length - 1);
                                            }
                                    }
                                pi.SetValue(o, castedvalue, null);
                                }
                            catch (Exception err)
                                {
                                string errortext = err.Message;
                                if (err.StackTrace != null)
                                    errortext += err.StackTrace;
                                if (err.InnerException != null)
                                    errortext += err.InnerException;
                                return string.Format("Syntax Error ({0})", errortext);
                                }
                            return "";
                            }

                        #endregion
                        }
                    else
                        {
                        //ouch we need to call a function....
                        //new bug... what about when there is a () in the string parameter...
                        bool insidequote = false;
                        int lettercounter = 0;
                        int brStart = p.IndexOf('(');
                        int brEnd = p.IndexOf(')');
                        foreach (char c in p)
                            {
                            if (c == '"')
                                insidequote = !insidequote;
                            if (c == '(' && !insidequote)
                                brStart = lettercounter;
                            if (c == ')' && !insidequote)
                                brEnd = lettercounter;

                            lettercounter++;
                            }

                        //int brStart = p.IndexOf('(');
                        //int brEnd = p.IndexOf(')');
                        string functionname = p.Substring(0, brStart);
                        string tparams = "";
                        if (brEnd - brStart > 1)
                            tparams = p.Substring(brStart + 1, (brEnd - 1) - brStart);


                        bool ignorecomma = false;
                        string tp1 = "";
                        char lc = ' ';

                        #region "Parse Params

                        List<string> myparams = new List<string>();
                        foreach (Char c in tparams)
                            {
                            if (c == '"' && (lc != '\\'))
                                {
                                ignorecomma = !ignorecomma;
                                }
                            if ((c == ',') && (!ignorecomma))
                                {
                                myparams.Add(tp1.Trim());
                                tp1 = "";
                                }
                            else
                                tp1 += c;
                            lc = c;
                            }
                        //if it's empty params, then lets not add it to the collect.
                        if (tp1 != "")
                            myparams.Add(tp1.Trim());

                        #endregion

                        MethodInfo mi = GetMethod(o, functionname);
                        if (mi != null)
                            {
                            List<object> passargs = new List<object>();
                            int counter = 0;
                            foreach (ParameterInfo pi in mi.GetParameters())
                                {
                                Type targettype = pi.ParameterType;
                                object castedvalue = ChangeType(myparams[counter], targettype);
                                if (targettype == typeof (string))
                                    {
                                    if (((string) castedvalue).Length >= 2)
                                        {
                                        castedvalue = ((string) castedvalue).Substring(1);
                                        castedvalue = ((string) castedvalue).Substring(0, ((string) castedvalue).Length - 1);
                                        }
                                    }
                                passargs.Add(castedvalue);
                                counter++;
                                }
                            try
                                {
                                o = mi.Invoke(o, passargs.ToArray()) ?? "";
                                }
                            catch (Exception s)
                                {
                                return string.Format("Error " + s.Message);
                                }
                            }
                        else
                            {
                            return string.Format("Syntax Error (Unable to find method '{0}' Function.)", functionname);
                            }
                        }
                    }
                }
            return o;
            }

        #endregion
        }
    }
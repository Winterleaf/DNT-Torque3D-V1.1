// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using System.ComponentModel;
using WinterLeaf.Classes;

#endregion

namespace WinterLeaf.tsObjects
    {
    /// <summary>
    /// 
    /// </summary>
    internal class tsObjectConvertercoSimObject : TypeConverter
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="sourceType"></param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
            return (typeof (string) == sourceType);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="culture"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
            if (value is string)
                {
                return new coSimObject(value as string);
                }

            return null;
            }
        }


    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof (tsObjectConvertercoSimObject))]
    public class coSimObject : Classes.tsObject
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
        internal coSimObject(string simobjectid) : base(simobjectid)
            {
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
        internal coSimObject(uint simobjectid) : base(simobjectid)
            {
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
        internal coSimObject(int simobjectid) : base(simobjectid)
            {
            }


        /// <summary>
        /// Whether the object can be saved out. If false, the object is purely transient in nature. 
        /// </summary>
        public bool canSave
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".canSave").AsBool(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".canSave", value.AsString()); }
            }

        /// <summary>
        /// True if dynamic fields (added at runtime) should be saved. Defaults to true. 
        /// </summary>
        public bool canSaveDynamicFields
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".canSaveDynamicFields").AsBool(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".canSaveDynamicFields", value.AsString()); }
            }

        /// <summary>
        /// Script class of object. 
        /// </summary>
        public String classx
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".class").AsString(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".class", value.AsString()); }
            }

        /// <summary>
        /// Script class of object., AbstractClassRep::FIELD_HideInInspectors 
        /// </summary>
        public String className
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".className").AsString(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".className", value.AsString()); }
            }

        /// <summary>
        /// Whether the object is visible. 
        /// </summary>
        public bool hidden
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".hidden").AsBool(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".hidden", value.AsString()); }
            }

        /// <summary>
        /// Optional name that may be used to lookup this object within a SimSet.
        /// </summary>
        public String internalName
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".internalName").AsString(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".internalName", value.AsString()); }
            }

        /// <summary>
        /// Whether the object can be edited. 
        /// </summary>
        public bool lockedx
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".locked").AsBool(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".locked", value.AsString()); }
            }

        /// <summary>
        /// Optional global name of this object. 
        /// </summary>
        public String name
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".name").AsString(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".name", value.AsString()); }
            }

        /// <summary>
        /// Group hierarchy parent of the object. 
        /// </summary>
        public coSimObject parentGroup
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".parentGroup"); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".parentGroup", value.ToString()); }
            }

        /// <summary>
        /// The universally unique identifier for the object. 
        /// </summary>
        public int persistentId
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".persistentId").AsInt(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".persistentId", value.AsString()); }
            }

        /// <summary>
        /// Script super-class of object. 
        /// </summary>
        public String superClass
            {
            get { return dnTorque.self.GetVar(_mSimObjectId + ".superClass").AsString(); }
            set { dnTorque.self.SetVar(_mSimObjectId + ".superClass", value.AsString()); }
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator ==(coSimObject ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return object.ReferenceEquals(simobjectid, null);
            return ts.Equals(simobjectid);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
            {
            throw new NotImplementedException();
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
            {
            return (this._mSimObjectId == (string) myReflections.ChangeType(obj, typeof (string)));
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator !=(coSimObject ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return !object.ReferenceEquals(simobjectid, null);
            return !ts.Equals(simobjectid);
            }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator string(coSimObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                return "0";
            return ts._mSimObjectId;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSimObject(string ts)
            {
            return new coSimObject(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator int(coSimObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                return 0;
            int i;
            return int.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSimObject(int ts)
            {
            return new coSimObject(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator uint(coSimObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                return 0;
            uint i;
            return uint.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSimObject(uint ts)
            {
            return new coSimObject(ts);
            }

        /// <summary>
        /// Copy fields from another object onto this one.  The objects must 
        ///    be of same type. Everything from the object will overwrite what's 
        ///    in this object; extra fields in this object will remain. This 
        ///    includes dynamic fields.
        ///    @param fromObject The object from which to copy fields. )
        /// 
        /// </summary>
        public void assignFieldsFrom(string fromObject)
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_assignFieldsFrom(_mSimObjectId, fromObject);
            }

        /// <summary>
        /// Delete and remove the object. )
        /// 
        /// </summary>
        public void delete()
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_delete(_mSimObjectId);
            }

        /// <summary>
        /// Dump the native C++ class hierarchy of this object's C++ class to the console. )
        /// 
        /// </summary>
        public void dumpClassHierarchy()
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_dumpClassHierarchy(_mSimObjectId);
            }

        /// <summary>
        /// List the methods defined on this object.
        ///    Each description is a newline-separated vector with the following elements:
        ///    - Minimum number of arguments.
        ///    - Maximum number of arguments.
        ///    - Prototype string.
        ///    - Full script file path (if script method).
        ///    - Line number of method definition in script (if script method).
        ///    - Documentation string (not including prototype).  This takes up the remainder of the vector.
        ///    @return An ArrayObject populated with (name,description) pairs of all methods defined on the object. )
        /// 
        /// </summary>
        public string dumpMethods()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_dumpMethods(_mSimObjectId);
            }

        /// <summary>
        /// Get whether the object will be included in saves.
        ///    @return True if the object will be saved; false otherwise. )
        /// 
        /// </summary>
        public bool getCanSave()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getCanSave(_mSimObjectId);
            }

        /// <summary>
        /// Get the name of the C++ class which the object is an instance of.
        ///    @return The name of the C++ class of the object. )
        /// 
        /// </summary>
        public string getClassName()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getClassName(_mSimObjectId);
            }

        /// <summary>
        /// Get the name of the class namespace assigned to this object.
        ///    @return The name of the 'class' namespace. )
        /// 
        /// </summary>
        public string getClassNamespace()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getClassNamespace(_mSimObjectId);
            }

        /// <summary>
        /// Get the line number at which the object is defined in its file.
        ///    @return The line number of the object's definition in script.
        ///    @see getFilename())
        /// 
        /// </summary>
        public int getDeclarationLine()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getDeclarationLine(_mSimObjectId);
            }

        /// <summary>
        /// Get a value of a dynamic field by index.
        ///    @param index The index of the dynamic field.
        ///    @return The value of the dynamic field at the given index or \"\". )
        /// 
        /// </summary>
        public string getDynamicField(int index)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getDynamicField(_mSimObjectId, index);
            }

        /// <summary>
        /// Get the number of dynamic fields defined on the object.
        ///    @return The number of dynamic fields defined on the object. )
        /// 
        /// </summary>
        public int getDynamicFieldCount()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getDynamicFieldCount(_mSimObjectId);
            }

        /// <summary>
        /// Retrieve the value of a static field by index.
        ///    @param index The index of the static field.
        ///    @return The value of the static field with the given index or \"\". )
        /// 
        /// </summary>
        public string getField(int index)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getField(_mSimObjectId, index);
            }

        /// <summary>
        /// Get the number of static fields on the object.
        ///    @return The number of static fields defined on the object. )
        /// 
        /// </summary>
        public int getFieldCount()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getFieldCount(_mSimObjectId);
            }

        /// <summary>
        /// Get the console type code of the given field.
        ///    @return The numeric type code for the underlying console type of the given field. )
        /// 
        /// </summary>
        public string getFieldType(string fieldName)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getFieldType(_mSimObjectId, fieldName);
            }

        /// <summary>
        /// Return the value of the given field on this object.
        ///    @param fieldName The name of the field.  If it includes a field index, the index is parsed out.
        ///    @param index Optional parameter to specify the index of an array field separately.
        ///    @return The value of the given field or \"\" if undefined. )
        /// 
        /// </summary>
        public string getFieldValue(string fieldName, int index)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getFieldValue(_mSimObjectId, fieldName, index);
            }

        /// <summary>
        /// Returns the filename the object is attached to.
        ///    @return The name of the file the object is associated with; usually the file the object was loaded from. )
        /// 
        /// </summary>
        public string getFilename()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getFilename(_mSimObjectId);
            }

        /// <summary>
        /// Get the name of the superclass namespace assigned to this object.
        ///    @return The name of the 'superClass' namespace. )
        /// 
        /// </summary>
        public string getSuperClassNamespace()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_getSuperClassNamespace(_mSimObjectId);
            }

        /// <summary>
        /// Get whether the object has been marked as expanded. (in editor)
        ///    @return True if the object is marked expanded. )
        /// 
        /// </summary>
        public bool isExpanded()
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_isExpanded(_mSimObjectId);
            }

        /// <summary>
        /// Test whether the given field is defined on this object.
        ///    @param fieldName The name of the field.
        ///    @return True if the object implements the given field. )
        /// 
        /// </summary>
        public bool isField(string fieldName)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_isField(_mSimObjectId, fieldName);
            }

        /// <summary>
        /// Test whether the namespace of this object is a direct or indirect child to the given namespace.
        ///    @param name The name of a namespace.
        ///    @return True if the given namespace name is within the namespace hierarchy of this object. )
        /// 
        /// </summary>
        public bool isInNamespaceHierarchy(string name)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_isInNamespaceHierarchy(_mSimObjectId, name);
            }

        /// <summary>
        /// Test whether this object is a member of the specified class.
        ///    @param className Name of a native C++ class.
        ///    @return True if this object is an instance of the given C++ class or any of its super classes. )
        /// 
        /// </summary>
        public bool isMemberOfClass(string className)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_isMemberOfClass(_mSimObjectId, className);
            }

        /// <summary>
        /// Test whether the given method is defined on this object.
        ///    @param The name of the method.
        ///    @return True if the object implements the given method. )
        /// 
        /// </summary>
        public bool isMethod(string methodName)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_isMethod(_mSimObjectId, methodName);
            }

        /// <summary>
        ///  ),
        ///    Save out the object to the given file.
        ///    @param fileName The name of the file to save to.
        ///    @param selectedOnly If true, only objects marked as selected will be saved out.
        ///    @param preAppendString Text which will be preprended directly to the object serialization.
        ///    @param True on success, false on failure. )
        /// 
        /// </summary>
        public bool save(string fileName, bool selectedOnly, string preAppendString)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_save(_mSimObjectId, fileName, selectedOnly, preAppendString);
            }

        /// <summary>
        /// Set whether the object will be included in saves.
        ///    @param value If true, the object will be included in saves; if false, it will be excluded. )
        /// 
        /// </summary>
        public void setCanSave(bool value)
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_setCanSave(_mSimObjectId, value);
            }

        /// <summary>
        /// Assign a class namespace to this object.
        ///    @param name The name of the 'class' namespace for this object. )
        /// 
        /// </summary>
        public void setClassNamespace(string name)
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_setClassNamespace(_mSimObjectId, name);
            }

        /// <summary>
        /// Set the console type code for the given field.
        ///    @param fieldName The name of the dynamic field to change to type for.
        ///    @param type The name of the console type.
        ///    @note This only works for dynamic fields.  Types of static fields cannot be changed. )
        /// 
        /// </summary>
        public void setFieldType(string fieldName, string type)
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_setFieldType(_mSimObjectId, fieldName, type);
            }

        /// <summary>
        /// Set the value of the given field on this object.
        ///    @param fieldName The name of the field to assign to.  If it includes an array index, the index will be parsed out.
        ///    @param value The new value to assign to the field.
        ///    @param index Optional argument to specify an index for an array field.
        ///    @return True. )
        /// 
        /// </summary>
        public bool setFieldValue(string fieldName, string value, int index)
            {
            return TorqueScriptTemplate.m_ts.fn_SimObject_setFieldValue(_mSimObjectId, fieldName, value, index);
            }

        /// <summary>
        /// Sets the object's file name and path
        ///    @param fileName The name of the file to associate this object with. )
        /// 
        /// </summary>
        public void setFilename(string fileName)
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_setFilename(_mSimObjectId, fileName);
            }

        /// <summary>
        /// Set whether the object has been marked as expanded. (in editor)
        ///    @param state True if the object is to be marked expanded; false if not. )
        /// 
        /// </summary>
        public void setIsExpanded(bool state)
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_setIsExpanded(_mSimObjectId, state);
            }

        /// <summary>
        /// Assign a superclass namespace to this object.
        ///    @param name The name of the 'superClass' namespace for this object. )
        /// 
        /// </summary>
        public void setSuperClassNamespace(string name)
            {
            TorqueScriptTemplate.m_ts.fn_SimObject_setSuperClassNamespace(_mSimObjectId, name);
            }

        /// <summary>
        /// Assign a persistent ID to the object if it does not already have one. )
        /// 
        /// </summary>
        public void assignPersistentId()
            {
            TorqueScriptTemplate.m_ts.fnSimObject_assignPersistentId(_mSimObjectId);
            }

        /// <summary>
        /// ( SimObject, call, const char*, 3, 0, ( string method, string args... ) Dynamically call a method on an object.
        ///    @param method Name of method to call.
        ///    @param args Zero or more arguments for the method.
        ///    @return The result of the method call. )
        /// 
        /// </summary>
        public string call(string a2, string a3 = "", string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_call(_mSimObjectId, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
            }

        /// <summary>
        /// Create a copy of this object.
        ///    @return An exact duplicate of this object. )
        /// 
        /// </summary>
        public string clone()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_clone(_mSimObjectId);
            }

        /// <summary>
        /// Create a copy of this object and all its subobjects.
        ///    @return An exact duplicate of this object and all objects it references. )
        /// 
        /// </summary>
        public string deepClone()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_deepClone(_mSimObjectId);
            }

        /// <summary>
        /// Dump a description of all fields and methods defined on this object to the console.
        ///    @param detailed Whether to print detailed information about members. )
        /// 
        /// </summary>
        public void dump(bool detailed)
            {
            TorqueScriptTemplate.m_ts.fnSimObject_dump(_mSimObjectId, detailed);
            }

        /// <summary>
        /// Dump the hierarchy of this object up to RootGroup to the console. )
        /// 
        /// </summary>
        public void dumpGroupHierarchy()
            {
            TorqueScriptTemplate.m_ts.fnSimObject_dumpGroupHierarchy(_mSimObjectId);
            }

        /// <summary>
        /// Return some behind-the-scenes information on the object.
        ///    @return An ArrayObject filled with internal information about the object. )
        /// 
        /// </summary>
        public string getDebugInfo()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_getDebugInfo(_mSimObjectId);
            }

        /// <summary>
        /// Get the group that this object is contained in.
        ///    @note If not assigned to particular SimGroup, an object belongs to RootGroup.
        ///    @return The SimGroup object to which the object belongs. )
        /// 
        /// </summary>
        public string getGroup()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_getGroup(_mSimObjectId);
            }

        /// <summary>
        /// Get the underlying unique numeric ID of the object.
        ///    @note Object IDs are unique only during single engine runs.
        ///    @return The unique numeric ID of the object. )
        /// 
        /// </summary>
        public int getId()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_getId(_mSimObjectId);
            }

        /// <summary>
        /// Get the internal name of the object.
        ///    @return The internal name of the object. )
        /// 
        /// </summary>
        public string getInternalName()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_getInternalName(_mSimObjectId);
            }

        /// <summary>
        /// Get the global name of the object.
        ///    @return The global name assigned to the object. )
        /// 
        /// </summary>
        public string getName()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_getName(_mSimObjectId);
            }

        /// <summary>
        /// Test whether the object belongs directly or indirectly to the given group.
        ///    @param group The SimGroup object.
        ///    @return True if the object is a child of the given group or a child of a group that the given group is directly or indirectly a child to. )
        /// 
        /// </summary>
        public bool isChildOfGroup(string group)
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_isChildOfGroup(_mSimObjectId, group);
            }

        /// <summary>
        /// Return true if the object is only used by the editor.
        ///    @return True if this object exists only for the sake of editing. )
        /// 
        /// </summary>
        public bool isEditorOnly()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_isEditorOnly(_mSimObjectId);
            }

        /// <summary>
        /// Get whether this object may be renamed.
        ///    @return True if this object can be renamed; false otherwise. )
        /// 
        /// </summary>
        public bool isNameChangeAllowed()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_isNameChangeAllowed(_mSimObjectId);
            }

        /// <summary>
        /// Get whether the object has been marked as selected. (in editor)
        ///    @return True if the object is currently selected. )
        /// 
        /// </summary>
        public bool isSelected()
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_isSelected(_mSimObjectId);
            }

        /// <summary>
        /// ( SimObject,schedule, S32, 4, 0, ( float time, string method, string args... ) Delay an invocation of a method.
        ///    @param time The number of milliseconds after which to invoke the method.  This is a soft limit.
        ///    @param method The method to call.
        ///    @param args The arguments with which to call the method.
        ///    @return The numeric ID of the created schedule.  Can be used to cancel the call. )
        /// 
        /// </summary>
        public int schedule(string a2, string a3, string a4 = "", string a5 = "", string a6 = "", string a7 = "", string a8 = "", string a9 = "", string a10 = "", string a11 = "", string a12 = "", string a13 = "", string a14 = "", string a15 = "", string a16 = "", string a17 = "", string a18 = "", string a19 = "")
            {
            return TorqueScriptTemplate.m_ts.fnSimObject_schedule(_mSimObjectId, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
            }

        /// <summary>
        /// Set/clear the editor-only flag on this object.
        ///    @param value If true, the object is marked as existing only for the editor. )
        /// 
        /// </summary>
        public void setEditorOnly(bool value)
            {
            TorqueScriptTemplate.m_ts.fnSimObject_setEditorOnly(_mSimObjectId, value);
            }

        /// <summary>
        /// Hide/unhide the object.
        ///    @param value If true, the object will be hidden; if false, the object will be unhidden. )
        /// 
        /// </summary>
        public void setHidden(bool value)
            {
            TorqueScriptTemplate.m_ts.fnSimObject_setHidden(_mSimObjectId, value);
            }

        /// <summary>
        /// Set the internal name of the object.
        ///    @param newInternalName The new internal name for the object. )
        /// 
        /// </summary>
        public void setInternalName(string newInternalName)
            {
            TorqueScriptTemplate.m_ts.fnSimObject_setInternalName(_mSimObjectId, newInternalName);
            }

        /// <summary>
        /// Set whether the object has been marked as selected. (in editor)
        ///    @param state True if object is to be marked selected; false if not. )
        /// 
        /// </summary>
        public void setIsSelected(bool state)
            {
            TorqueScriptTemplate.m_ts.fnSimObject_setIsSelected(_mSimObjectId, state);
            }

        /// <summary>
        /// Lock/unlock the object in the editor.
        ///    @param value If true, the object will be locked; if false, the object will be unlocked. )
        /// 
        /// </summary>
        public void setLocked(bool value)
            {
            TorqueScriptTemplate.m_ts.fnSimObject_setLocked(_mSimObjectId, value);
            }

        /// <summary>
        /// Set the global name of the object.
        ///    @param newName The new global name to assign to the object.
        ///    @note If name changing is disallowed on the object, the method will fail with a console error. )
        /// 
        /// </summary>
        public void setName(string newName)
            {
            TorqueScriptTemplate.m_ts.fnSimObject_setName(_mSimObjectId, newName);
            }

        /// <summary>
        /// Set whether this object can be renamed from its first name.
        ///    @param value If true, renaming is allowed for this object; if false, trying to change the name of the object will generate a console error. )
        /// 
        /// </summary>
        public void setNameChangeAllowed(bool value)
            {
            TorqueScriptTemplate.m_ts.fnSimObject_setNameChangeAllowed(_mSimObjectId, value);
            }
        }
    }
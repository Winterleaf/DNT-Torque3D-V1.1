
// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.

#region
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using System.ComponentModel;
#endregion

namespace WinterLeaf.tsObjects
    {
    /// <summary>
    /// 
    /// </summary>
    internal class tsObjectConvertercoGameConnection : TypeConverter
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="sourceType"></param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
            return (typeof(string) == sourceType);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="culture"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
            if (value is string)
                {
                return new coGameConnection(value as string);
                }

            return null;
            }
        }

      
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(tsObjectConvertercoGameConnection))]
    public class coGameConnection: coNetConnection
{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
public coGameConnection(string simobjectid) : base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
public coGameConnection(uint simobjectid): base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
public coGameConnection(int simobjectid): base(simobjectid){ }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator ==(coGameConnection ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return object.ReferenceEquals(simobjectid, null);
            return ts.Equals(simobjectid);


            }
  /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
            {
            throw new NotImplementedException();
            }
  /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
            {
            
            return (this._mSimObjectId ==(string)myReflections.ChangeType( obj,typeof(string)));
            }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator !=(coGameConnection ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return !object.ReferenceEquals(simobjectid, null);
            return !ts.Equals(simobjectid);

            }


            /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator string( coGameConnection ts)
            {
            return ts._mSimObjectId;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGameConnection(string ts)
            {
            return new coGameConnection(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator int( coGameConnection ts)
            {
            int i;
            return int.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGameConnection(int ts)
            {
            return new coGameConnection(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator uint( coGameConnection ts)
            {
            uint i;
            return uint.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGameConnection(uint ts)
            {
            return new coGameConnection(ts);
            }
/// <summary>
/// @brief Called by the server during phase 2 of the mission download to start sending ghosts to the client.
///    
///    Ghosts represent objects on the server that are in scope for the client.  These need 
///    to be synchronized with the client in order for the client to see and interact with them.  
///    This is typically done during the standard mission start phase 2 when following Torque's 
///    example mission startup sequence.
/// 
///    @tsexample
///    function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
///    {
///       // Make sure to ignore calls from a previous mission load
///       if (%seq != $missionSequence || !$MissionRunning)
///          return;
///       if (%client.currentPhase != 1.5)
///          return;
///       %client.currentPhase = 2;
///    
///       // Set the player datablock choice
///       %client.playerDB = %playerDB;
///    
///       // Update mod paths, this needs to get there before the objects.
///       %client.transmitPaths();
///    
///       // Start ghosting objects to the client
///       %client.activateGhosting();
///    }
///    @endtsexample
/// 
///    @see @ref ghosting_scoping for a description of the ghosting system.)
/// 
/// </summary>
public  void activateGhosting(){
TorqueScriptTemplate.m_ts.fnGameConnection_activateGhosting(_mSimObjectId);
}
/// <summary>
/// @brief Sets the size of the chase camera's matrix queue.
///    @note This sets the queue size across all GameConnections.
///    @note This is not currently hooked up.)
/// 
/// </summary>
public  bool chaseCam(int size){
return TorqueScriptTemplate.m_ts.fnGameConnection_chaseCam(_mSimObjectId, size);
}
/// <summary>
/// @brief Clear the connection's camera object reference.
///    
///    @see GameConnection::setCameraObject() and GameConnection::getCameraObject())
/// 
/// </summary>
public  void clearCameraObject(){
TorqueScriptTemplate.m_ts.fnGameConnection_clearCameraObject(_mSimObjectId);
}
/// <summary>
/// ),
///    @brief On the server, disconnect a client and pass along an optional reason why.
/// 
///    This method performs two operations: it disconnects a client connection from the server, 
///    and it deletes the connection object.  The optional reason is sent in the disconnect packet 
///    and is often displayed to the user so they know why they've been disconnected.
///    
///    @param reason [optional] The reason why the user has been disconnected from the server.
///    
///    @tsexample
///    function kick(%client)
///    {
///       messageAll( 'MsgAdminForce', '\\c2The Admin has kicked %1.', %client.playerName);
///    
///       if (!%client.isAIControlled())
///          BanList::add(%client.guid, %client.getAddress(), $Pref::Server::KickBanTime);
///       %client.delete(\"You have been kicked from this server\");
///    }
///    @endtsexample)
/// 
/// </summary>
public  void delete(string reason){
TorqueScriptTemplate.m_ts.fnGameConnection_delete(_mSimObjectId, reason);
}
/// <summary>
/// @brief Returns the connection's camera object used when not viewing through the control object.
///    
///    @see GameConnection::setCameraObject() and GameConnection::clearCameraObject())
/// 
/// </summary>
public  string getCameraObject(){
return TorqueScriptTemplate.m_ts.fnGameConnection_getCameraObject(_mSimObjectId);
}
/// <summary>
/// @brief Returns the default field of view as used by the control object's camera.)
/// 
/// </summary>
public  float getControlCameraDefaultFov(){
return TorqueScriptTemplate.m_ts.fnGameConnection_getControlCameraDefaultFov(_mSimObjectId);
}
/// <summary>
/// @brief Returns the field of view as used by the control object's camera.)
/// 
/// </summary>
public  float getControlCameraFov(){
return TorqueScriptTemplate.m_ts.fnGameConnection_getControlCameraFov(_mSimObjectId);
}
/// <summary>
/// @brief On the server, returns the object that the client is controlling.
///    By default the control object is an instance of the Player class, but can also be an instance 
///    of Camera (when editing the mission, for example), or any other ShapeBase derived class as 
///    appropriate for the game.
///    @see GameConnection::setControlObject())
/// 
/// </summary>
public  string getControlObject(){
return TorqueScriptTemplate.m_ts.fnGameConnection_getControlObject(_mSimObjectId);
}
/// <summary>
/// @brief On the client, get the control object's damage flash level.
///    @return flash level)
/// 
/// </summary>
public  float getDamageFlash(){
return TorqueScriptTemplate.m_ts.fnGameConnection_getDamageFlash(_mSimObjectId);
}
/// <summary>
/// @brief On the client, get the control object's white-out level.
///    @return white-out level)
/// 
/// </summary>
public  float getWhiteOut(){
return TorqueScriptTemplate.m_ts.fnGameConnection_getWhiteOut(_mSimObjectId);
}
/// <summary>
/// @brief Returns true if this connection is AI controlled.
///    @see AIConnection)
/// 
/// </summary>
public  bool isAIControlled(){
return TorqueScriptTemplate.m_ts.fnGameConnection_isAIControlled(_mSimObjectId);
}
/// <summary>
/// @brief Returns true if the object being controlled by the client is making use 
///    of a rotation damped camera.
///    @see Camera)
/// 
/// </summary>
public  bool isControlObjectRotDampedCamera(){
return TorqueScriptTemplate.m_ts.fnGameConnection_isControlObjectRotDampedCamera(_mSimObjectId);
}
/// <summary>
/// @brief Returns true if a previously recorded demo file is now playing.
///    
///    @see GameConnection::playDemo())
/// 
/// </summary>
public  bool isDemoPlaying(){
return TorqueScriptTemplate.m_ts.fnGameConnection_isDemoPlaying(_mSimObjectId);
}
/// <summary>
/// @brief Returns true if a demo file is now being recorded.
///    
///    @see GameConnection::startRecording(), GameConnection::stopRecording())
/// 
/// </summary>
public  bool isDemoRecording(){
return TorqueScriptTemplate.m_ts.fnGameConnection_isDemoRecording(_mSimObjectId);
}
/// <summary>
/// @brief Returns true if this connection is in first person mode.
/// 
///    @note Transition to first person occurs over time via mCameraPos, so this 
///    won't immediately return true after a set.)
/// 
/// </summary>
public  bool isFirstPerson(){
return TorqueScriptTemplate.m_ts.fnGameConnection_isFirstPerson(_mSimObjectId);
}
/// <summary>
/// @brief List all of the classes that this connection knows about, and what their IDs are. Useful for debugging network problems.
///    @note The list is sent to the console.)
/// 
/// </summary>
public  void listClassIDs(){
TorqueScriptTemplate.m_ts.fnGameConnection_listClassIDs(_mSimObjectId);
}
/// <summary>
/// @brief Used on the server to play a 2D sound that is not attached to any object.
/// 
///    @param profile The SFXProfile that defines the sound to play.
/// 
///    @tsexample
///    function ServerPlay2D(%profile)
///    {
///       // Play the given sound profile on every client.
///       // The sounds will be transmitted as an event, not attached to any object.
///       for(%idx = 0; %idx  ClientGroup.getCount(); %idx++)
///          ClientGroup.getObject(%idx).play2D(%profile);
///    }
///    @endtsexample)
/// 
/// </summary>
public  bool play2D(string profile){
return TorqueScriptTemplate.m_ts.fnGameConnection_play2D(_mSimObjectId, profile);
}
/// <summary>
/// @brief Used on the server to play a 3D sound that is not attached to any object.
///    
///    @param profile The SFXProfile that defines the sound to play.
///    @param location The position and orientation of the 3D sound given in the form of \"x y z ax ay az aa\".
/// 
///    @tsexample
///    function ServerPlay3D(%profile,%transform)
///    {
///       // Play the given sound profile at the given position on every client
///       // The sound will be transmitted as an event, not attached to any object.
///       for(%idx = 0; %idx  ClientGroup.getCount(); %idx++)
///          ClientGroup.getObject(%idx).play3D(%profile,%transform);
///    }
///    @endtsexample)
/// 
/// </summary>
public  bool play3D(string profile, TransformF location){
return TorqueScriptTemplate.m_ts.fnGameConnection_play3D(_mSimObjectId, profile, location.AsString());
}
/// <summary>
/// @brief On the client, play back a previously recorded game session.
///    
///    It is often useful to play back a game session.  This could be for producing a 
///    demo of the game that will be shown at a later time, or for debugging a game.  
///    By recording the entire network stream it is possible to later play game the game 
///    exactly as it unfolded during the actual play session.  This is because all user 
///    control and server results pass through the connection.
/// 
///    @returns True if the playback was successful.  False if there was an issue, such as 
///    not being able to open the demo file for playback.
///    
///    @see GameConnection::startRecording(), GameConnection::stopRecording())
/// 
/// </summary>
public  bool playDemo(string demoFileName){
return TorqueScriptTemplate.m_ts.fnGameConnection_playDemo(_mSimObjectId, demoFileName);
}
/// <summary>
/// @brief On the server, resets the connection to indicate that ghosting has been disabled.
/// 
///    Typically when a mission has ended on the server, all connected clients are informed of this change 
///    and their connections are reset back to a starting state.  This method resets a connection on the 
///    server to indicate that ghosts are no longer being transmitted.  On the client end, all ghost 
///    information will be deleted.
/// 
///    @tsexample
///       // Inform the clients
///       for (%clientIndex = 0; %clientIndex  ClientGroup.getCount(); %clientIndex++)
///       {
///          // clear ghosts and paths from all clients
///          %cl = ClientGroup.getObject(%clientIndex);
///          %cl.endMission();
///          %cl.resetGhosting();
///          %cl.clearPaths();
///       }
///    @endtsexample
/// 
///    @see @ref ghosting_scoping for a description of the ghosting system.)
/// 
/// </summary>
public  void resetGhosting(){
TorqueScriptTemplate.m_ts.fnGameConnection_resetGhosting(_mSimObjectId);
}
/// <summary>
/// @brief On the server, sets the client's 3D display to fade to black.
///    @param doFade Set to true to fade to black, and false to fade from black.
///    @param timeMS Time it takes to perform the fade as measured in ms.
///    @note Not currently hooked up, and is not synchronized over the network.)
/// 
/// </summary>
public  void setBlackOut(bool doFade, int timeMS){
TorqueScriptTemplate.m_ts.fnGameConnection_setBlackOut(_mSimObjectId, doFade, timeMS);
}
/// <summary>
/// @brief On the server, set the connection's camera object used when not viewing 
///    through the control object.
///    
///    @see GameConnection::getCameraObject() and GameConnection::clearCameraObject())
/// 
/// </summary>
public  bool setCameraObject(string camera){
return TorqueScriptTemplate.m_ts.fnGameConnection_setCameraObject(_mSimObjectId, camera);
}
/// <summary>
/// (GameConnection, setConnectArgs, void, 3, 17,
///    (const char* args) @brief On the client, pass along a variable set of parameters to the server.
///    
///    Once the connection is established with the server, the server calls its onConnect() method 
///    with the client's passed in parameters as aruments.
///    
///    @see GameConnection::onConnect())
/// 
/// </summary>
public  void setConnectArgs(string a2, string a3= "", string a4= "", string a5= "", string a6= "", string a7= "", string a8= "", string a9= "", string a10= "", string a11= "", string a12= "", string a13= "", string a14= "", string a15= "", string a16= ""){
TorqueScriptTemplate.m_ts.fnGameConnection_setConnectArgs(_mSimObjectId, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
}
/// <summary>
/// @brief On the server, sets the control object's camera's field of view.
///    @param newFOV New field of view (in degrees) to force the control object's camera to use.  This value 
///    is clamped to be within the range of 1 to 179 degrees.
///    @note When transmitted over the network to the client, the resolution is limited to 
///    one degree.  Any fraction is dropped.)
/// 
/// </summary>
public  void setControlCameraFov(float newFOV){
TorqueScriptTemplate.m_ts.fnGameConnection_setControlCameraFov(_mSimObjectId, newFOV);
}
/// <summary>
/// @brief On the server, sets the object that the client will control.
///    By default the control object is an instance of the Player class, but can also be an instance 
///    of Camera (when editing the mission, for example), or any other ShapeBase derived class as 
///    appropriate for the game.
///    @param ctrlObj The GameBase object on the server to control.)
/// 
/// </summary>
public  bool setControlObject(string ctrlObj){
return TorqueScriptTemplate.m_ts.fnGameConnection_setControlObject(_mSimObjectId, ctrlObj);
}
/// <summary>
/// @brief On the server, sets this connection into or out of first person mode.
///    
///    @param firstPerson Set to true to put the connection into first person mode.)
/// 
/// </summary>
public  void setFirstPerson(bool firstPerson){
TorqueScriptTemplate.m_ts.fnGameConnection_setFirstPerson(_mSimObjectId, firstPerson);
}
/// <summary>
/// @brief On the client, set the password that will be passed to the server.
///               
///               On the server, this password is compared with what is stored in $pref::Server::Password.  
///               If $pref::Server::Password is empty then the client's sent password is ignored.  Otherwise, 
///               if the passed in client password and the server password do not match, the CHR_PASSWORD 
///               error string is sent back to the client and the connection is immediately terminated.
///               
///               This password checking is performed quite early on in the connection request process so as 
///               to minimize the impact of multiple failed attempts -- also known as hacking.)
/// 
/// </summary>
public  void setJoinPassword(string password){
TorqueScriptTemplate.m_ts.fnGameConnection_setJoinPassword(_mSimObjectId, password);
}
/// <summary>
/// @brief On the server, transmits the mission file's CRC value to the client.
/// 
///    Typically, during the standard mission start phase 1, the mission file's CRC value 
///    on the server is send to the client.  This allows the client to determine if the mission 
///    has changed since the last time it downloaded this mission and act appropriately, such as 
///    rebuilt cached lightmaps.
/// 
///    @param CRC The mission file's CRC value on the server.
/// 
///    @tsexample
///    function serverCmdMissionStartPhase1Ack(%client, %seq)
///    {
///       // Make sure to ignore calls from a previous mission load
///       if (%seq != $missionSequence || !$MissionRunning)
///          return;
///       if (%client.currentPhase != 0)
///          return;
///       %client.currentPhase = 1;
///    
///       // Start with the CRC
///       %client.setMissionCRC( $missionCRC );
///    
///       // Send over the datablocks...
///       // OnDataBlocksDone will get called when have confirmation
///       // that they've all been received.
///       %client.transmitDataBlocks($missionSequence);
///    }
///    @endtsexample)
/// 
/// </summary>
public  void setMissionCRC(int CRC){
TorqueScriptTemplate.m_ts.fnGameConnection_setMissionCRC(_mSimObjectId, CRC);
}
/// <summary>
/// @brief On the client, starts recording the network connection's traffic to a demo file.
///    
///    It is often useful to play back a game session.  This could be for producing a 
///    demo of the game that will be shown at a later time, or for debugging a game.  
///    By recording the entire network stream it is possible to later play game the game 
///    exactly as it unfolded during the actual play session.  This is because all user 
///    control and server results pass through the connection.
///    
///    @param fileName The file name to use for the demo recording.
///    
///    @see GameConnection::stopRecording(), GameConnection::playDemo())
/// 
/// </summary>
public  void startRecording(string fileName){
TorqueScriptTemplate.m_ts.fnGameConnection_startRecording(_mSimObjectId, fileName);
}
/// <summary>
/// @brief On the client, stops the recording of a connection's network traffic to a file.
///    
///    @see GameConnection::startRecording(), GameConnection::playDemo())
/// 
/// </summary>
public  void stopRecording(){
TorqueScriptTemplate.m_ts.fnGameConnection_stopRecording(_mSimObjectId);
}
/// <summary>
/// @brief Sent by the server during phase 1 of the mission download to send the datablocks to the client.
///    
///    SimDataBlocks, also known as just datablocks, need to be transmitted to the client 
///    prior to the client entering the game world.  These represent the static data that 
///    most objects in the world reference.  This is typically done during the standard 
///    mission start phase 1 when following Torque's example mission startup sequence.
/// 
///    When the datablocks have all been transmitted, onDataBlocksDone() is called to move 
///    the mission start process to the next phase.
/// 
///    @param sequence The sequence is common between the server and client and ensures 
///    that the client is acting on the most recent mission start process.  If an errant 
///    network packet (one that was lost but has now been found) is received by the client 
///    with an incorrect sequence, it is just ignored.  This sequence number is updated on 
///    the server every time a mission is loaded.
/// 
///    @tsexample
///    function serverCmdMissionStartPhase1Ack(%client, %seq)
///    {
///       // Make sure to ignore calls from a previous mission load
///       if (%seq != $missionSequence || !$MissionRunning)
///          return;
///       if (%client.currentPhase != 0)
///          return;
///       %client.currentPhase = 1;
///    
///       // Start with the CRC
///       %client.setMissionCRC( $missionCRC );
///    
///       // Send over the datablocks...
///       // OnDataBlocksDone will get called when have confirmation
///       // that they've all been received.
///       %client.transmitDataBlocks($missionSequence);
///    }
///    @endtsexample
///    
///    @see GameConnection::onDataBlocksDone())
/// 
/// </summary>
public  void transmitDataBlocks(int sequence){
TorqueScriptTemplate.m_ts.fnGameConnection_transmitDataBlocks(_mSimObjectId, sequence);
}
}}
